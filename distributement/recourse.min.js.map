{"version":3,"file":"recourse.min.js","sources":["../development/variables/index.js","../development/type-of/index.js","../development/typed-object-literal/index.js","../development/regular-expressions/index.js","../development/tree/index.js","../development/expand-tree/index.js","../development/impand-tree/index.js","../development/is-array-like/index.js","../development/compand-tree/index.js","../development/accessors/index.js","../development/assign/index.js","../development/assign-concat/index.js","../development/get-own-property-descriptors/options.js","../development/get-own-property-descriptor/index.js","../development/get-own-property-descriptors/index.js","../development/define-properties/options.js","../development/define-property/index.js","../development/define-properties/index.js","../development/freeze/index.js"],"sourcesContent":["const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","export default ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase()","import typeOf from '../type-of/index.js'\nexport default function typedObjectLiteral($value) {\n  let _typedObjectLiteral\n  const typeOfValue = typeOf($value)\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase()\n    if(value === 'object') { _typedObjectLiteral = {} }\n    else if(value === 'array') { _typedObjectLiteral = [] }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {} }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = [] }\n  }\n  return _typedObjectLiteral\n}","export default {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n}","import typedObjectLiteral from '../typed-object-literal/index.js'\nimport regularExpressions from '../regular-expressions/index.js'\nfunction get($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  let subtarget = $source\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath] }\n  return subtarget[key]\n}\nfunction set($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  const target = (key && !isNaN(key)) ? [] : {}\n  let subtarget = target\n  let subpathIndex = 0\n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex]\n    if(isNaN($subpath)) { subtarget[$subpath] = {} }\n    else { subtarget[$subpath] = {} }\n    subtarget = subtarget[$subpath]\n    subpathIndex++\n  }\n  subtarget[key] = $source\n  return target\n}\nexport { get, set }","import { ObjectKeys } from '../variables/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nconst ValidPropertyTypes = ['string', 'function']\nexport default function expandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    const sourceValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expandTree($sourceValue, $property) : $sourceValue\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$sourceKey] = Tree.set($property, sourceValue)\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$sourceKey] = $property(sourceValue)\n    }\n  }\n  return target\n}","import * as Variables from '../variables/index.js'\n// import * as PropertyPath from '../property-path/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nexport default function impandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = Tree.get($property, $sourceValue) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property)\n    }\n  }\n  return target\n}","import typeOf from '../type-of/index.js'\nexport default ($source) => {\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey)\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","import Accessors from '../accessors/index.js'\nconst Options = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n}\nexport default function compandTree($object, $options) {\n  const _compandTree = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors)\n  })\n  options.depth++\n  if(options.depth > options.maxDepth) { return _compandTree }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object)\n    const object = accessor($object)\n    if(!object) { continue iterateAccessors }\n    if(!options.ancestors.includes(object)) { options.ancestors.unshift(object) }\n    iterateObjectProperties: \n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _compandTree.push($key) }\n      else if(options.values) { _compandTree.push([$key, $value]) }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, object) && \n        !options.ancestors.includes($value)\n      ) {\n        const subtargets = compandTree($value, options)\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.')\n            _compandTree.push(path)\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.')\n            _compandTree.push([path, $subtarget])\n          }\n        }\n      }\n    }\n  }\n  return _compandTree\n}","const defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n}\nconst getAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target.get($property) }\n}\nexport default {\n  default: defaultAccessor,\n  get: getAccessor,\n}","import typeOf from '../type-of/index.js'\nexport default function assign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assign($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nexport default function assignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assignConcat($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","export default {\n  ancestors: [],\n  delimiter: '.',\n  depth: 0,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n}","import typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js'\nimport Options from '../get-own-property-descriptors/options.js'\nexport default function getOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey)\n  if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties) }\n  if(options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey\n    propertyDescriptor.path = options.path\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value) }\n  if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyDescriptor.value) }\n  if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyDescriptor.value) }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = getOwnPropertyDescriptors(propertyDescriptor.value, options)\n  }\n  return propertyDescriptor\n}","import getOwnPropertyDescriptor from '../get-own-property-descriptor/index.js'\nimport Options from './options.js'\nexport default function getOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {}\n  const options = Object.assign({}, Options, $options)\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++ }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($properties, $propertyKey, options)\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor }\n  }\n  return propertyDescriptors\n}","export default {\n  typeCoercion: false,\n}","import isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport defineProperties from '../define-properties/index.js'\nimport * as Variables from '../variables/index.js'\nimport Options from '../define-properties/options.js'\nexport default function defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor)\n  const options = Object.assign({}, Options, $options)\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value)\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {}\n    propertyDescriptor.value = defineProperties(propertyValue, propertyDescriptor.value, options)\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Variables.Primitives[propertyDescriptor.type](propertyDescriptor.value)\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor)\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]) }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]) }\n  return $target\n}","import defineProperty from '../define-property/index.js'\nimport Options from './options.js'\nexport default function defineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options)\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, options)\n  }\n  return $target\n}","function freeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      freeze($propertyValue)\n    }\n  }\n  return Object.freeze($target)\n}\nexport default freeze"],"names":["Primitives","string","String","number","Number","boolean","Boolean","bigint","BigInt","undefined","null","PrimitiveKeys","Object","keys","PrimitiveValues","values","Objects","object","array","Array","ObjectKeys","ObjectValues","Types","assign","TypeKeys","TypeValues","TypeMethods","typeOf","$data","prototype","toString","call","slice","toLowerCase","typedObjectLiteral","$value","_typedObjectLiteral","typeOfValue","value","regularExpressions","quotationEscape","get","$path","$source","subpaths","split","RegExp","key","pop","subtarget","$subpath","set","target","isNaN","subpathIndex","length","keypaths","ValidPropertyTypes","expandTree","$property","typeOfProperty","typeOfSource","includes","$sourceKey","$sourceValue","entries","sourceValue","Tree.set","impandTree","Tree.get","isArrayLike","isInteger","iterateSourceKeys","getOwnPropertyDescriptors","Options","depth","maxDepth","accessors","default","$target","ancestors","compandTree","$object","$options","_compandTree","options","concat","$accessor","bind","accessor","unshift","$key","push","is","subtargets","$subtargetKey","$subtarget","path","join","$sources","$sourcePropertyKey","$sourcePropertyValue","typeOfTargetPropertyValue","typeOfSourcePropertyValue","assignConcat","Options$1","delimiter","frozen","nonenumerable","sealed","type","getOwnPropertyDescriptor","$properties","$propertyKey","propertyDescriptor","enumerable","isFrozen","isSealed","propertyDescriptors","$propertyDescriptor","typeCoercion","defineProperty","typeOfPropertyValue","propertyValue","defineProperties","Variables.Primitives","seal","freeze","$propertyDescriptors","$propertyValue"],"mappings":"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"}