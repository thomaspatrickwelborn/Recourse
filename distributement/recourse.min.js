var e=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function t(t,n,...s){if(!t)return t;for(const r of s)if(r)for(const[s,o]of Object.entries(r)){const r=e(t[s]),c=e(o);t[s]="object"===r&&"object"===c?assignConcat(t[s],o):"assignConcat"===n&&"array"===r&&"array"===c?t[s].concat(o):o}return t}function n(e,...n){return t(e,"assign",...n)}function s(e,...n){return t(e,"assignConcat",...n)}const r={enumerable:!0,nonenumerable:!0};function o(e,t){const n=[],s=Object.assign({},r,t),{enumerable:o,nonenumerable:c}=s;if(!o&&!c)return[];const a=Object.getOwnPropertyDescriptors(e);for(const[e,t]of Object.entries(a))(o&&t.enumerable||c&&!t.enumerable)&&n.push([e,t.value]);return n}const c={depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1};function a(t,n,s){const r=[],i=Object.assign({},c,s,{ancestors:[].concat(s.ancestors)}),{ancestors:u,maxDepth:l,nonenumerable:p}=i;if(i.depth>=l)return r;i.depth++,u.includes(t)||u.push(t);for(const[s,c]of o(t,{enumerable:!0,nonenumerable:p})){const t=e(c);["array","object"].includes(t)&&!u.includes(c)?"entries"===n?r.push([s,a(c,n,i)]):"values"===n?r.push(a(c,n,i)):"keys"===n&&r.push(s,a(c,n,i)):"entries"===n?r.push([s,c]):"values"===n?r.push(c):"keys"===n&&r.push(s)}return r}function i(e,t){return a(e,"entries",t)}const u={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default],ancestors:[],values:!1,nonenumerable:!1};function l(e,t){const n=[],s=Object.assign({},u,t,{ancestors:[].concat(t.ancestors)}),{accessors:r,ancestors:o,nonenumerable:c,values:a}=s;if(s.depth++,s.depth>maxDepth)return n;e:for(const t of r){const r=t(e);if(!r)continue e;o.includes(r)||o.unshift(r);const u=i(r,{nonenumerable:c});for(const[e,t]of u)if(a?a&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,r)&&!o.includes(t)){const r=l(t,s);if(a){if(a)for(const[t,s]of r){const r=[e,t].join(".");n.push([r,s])}}else for(const t of r){const s=[e,t].join(".");n.push(s)}}}return n}var p={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};function f(e,t){const n=$path.split(new RegExp(p.quotationEscape)),s=n.pop(),r=s&&!isNaN(s)?[]:{};let o=r,c=0;for(;c<n.length-2;){const e=keypaths[c];isNaN(e),o[e]={},o=o[e],c++}return o[s]=e,r}var b=t=>{let n;const s=e(t);if("array"===s)n=!0;else if("object"===s&&Number.isInteger(t.length)&&t.length>=0){e:for(const e of Object.keys(Object.getOwnPropertyDescriptors(t)))if("length"!==e&&(n=!isNaN(e),!n))break e}else n=!1;return n};function d(t){let n;const s=e(t);if("string"===s){const e=t.toLowerCase();"object"===e?n={}:"array"===e&&(n=[])}else"object"===s?n={}:"array"===s&&(n=[]);return n}const j={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},O=Object.keys(j),y=Object.values(j),g={object:Object,array:Array},h=Object.keys(g),m=Object.values(g),v=Object.assign({},j,g),P=Object.keys(v),x=Object.values(v),D=[j.String,j.Number,j.Boolean,g.Object,g.Array];var k=Object.freeze({__proto__:null,ObjectKeys:h,ObjectValues:m,Objects:g,PrimitiveKeys:O,PrimitiveValues:y,Primitives:j,TypeKeys:P,TypeMethods:D,TypeValues:x,Types:v}),w={typeCoercion:!1};function N(t,n,s,r){const o=Object.assign({},s),c=Object.assign({},w,r),a=e(o.value);if(["array","object"].includes(a)){const e=b(Object.defineProperties(d(a),o.value))?[]:{};o.value=E(e,o.value,c)}else c.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(o,"type")&&!["undefined","null"].includes(a)&&(o.value=j[o.type](o.value));return Object.defineProperty(t,n,o),s.sealed&&Object.seal(t[n]),s.frozen&&Object.freeze(t[n]),t}function E(e,t,n){const s=Object.assign({},w,n);for(const[n,r]of Object.entries(t))N(e,n,r,s);return e}function z(e,t,n){const s=t.split(new RegExp(regularExpressions.quotationEscape)),r=s.pop(),o=r&&!isNaN(r)?[]:{};let c=o,a=0;for(;a<s.length-2;){const e=keypaths[a];isNaN(e),c[e]={},c=c[e],a++}return c[r]=n,o}const C=["string","function"];function T(t,n){const s=e(n),r=e(t);if(!C.includes(s)||!h.includes(r))return t;let o=d(t);for(const[r,c]of Object.entries(t)){const t=h.includes(e(c))?T(c,n):c;s===C[0]?o[r]=z(0,t):s===C[1]&&(o[r]=n(t))}return o}function L(e){for(const[t,n]of Object.entries(e))Object.is(n,e)||n&&"object"==typeof n&&L(n);return Object.freeze(e)}function q(e,t){const n=t.split(new RegExp(p.quotationEscape)),s=n.pop();let r=e;for(const e of n)r=r[e];return r[s]}function A(t,n){const s=e(n),r=e(t);if(!["string","function"].includes(s)||!["array","object"].includes(r))return t;let o=d(t);for(const[e,r]of Object.entries(t))"string"===s?o[e]=Tree.getTreeNode(n,r):"function"===s&&(o[e]=n(r)),o[e]&&"object"==typeof o[e]&&(o[e]=A(o[e],n));return o}var S={ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function _(t,n,s){const r=Object.assign({},S,s,{ancestors:Object.assign([],s.ancestors)}),o=Object.getOwnPropertyDescriptor(t,n);if((r.nonenumerable||o.enumerable)&&(r.ancestors.includes(t)||r.ancestors.unshift(t),!r.ancestors.includes(o.value)))return r.path&&(r.path="string"===e(r.path)?[r.path,n].join(r.delimiter):n,o.path=r.path),r.type&&(o.type=e(o.value)),r.frozen&&(o.frozen=Object.isFrozen(o.value)),r.sealed&&(o.sealed=Object.isSealed(o.value)),["array","object"].includes(e(o.value))&&(o.value=B(o.value,r)),o}function B(e,t){const n={},s=Object.assign({},S,t);if(s.depth>=s.maxDepth)return n;s.depth++;for(const[t,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=_(e,t,s);void 0!==r&&(n[t]=r)}return n}function K(e){for(const[t,n]of Object.entries(e))Object.is(n,e)||n&&"object"==typeof n&&K(n);return Object.seal(e)}function R(e,t){return a(e,"keys",t)}function V(e,t){return a(e,"values",t)}class I extends EventTarget{static compand=l;static decompand=f;static expand=T;static impand=A;static keys=R;static values=V;static entries=i;static numerableEntries=o;static get=q;static set=z;static delete=q;static assign=n;static assignConcat=s;static defineProperties=E;static defineProperty=N;static freeze=L;static seal=K;static getOwnPropertyDescriptors=B;static getOwnPropertyDescriptor=_;static isArrayLike=b;static typeOf=e;static typedObjectLiteral=d;static regularExpressions=p;static variables=k;constructor(t){super();const n=d(e(t));for(const e of[I.compand,I.decompand,I.expand,I.impand,I.keys,I.values,I.entries,I.numerableEntries,I.get,I.set,I.delete,I.assign,I.assignConcat,I.defineProperties,I.defineProperty,I.freeze,I.seal,I.getOwnPropertyDescriptors,I.getOwnPropertyDescriptor,I.isArrayLike,I.typeOf])Object.defineProperty(this,e.name,{value:e.bind(this,n)})}}export{I as default};
//# sourceMappingURL=recourse.min.js.map
