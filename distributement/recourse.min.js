var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/},t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();class s extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}const n={default:function(e,t){return void 0===t?e:e[t]}},r={default:function(){if("string"===t(arguments[1])){const[e,t,s,n]=[...arguments];return e[t]=s,e[t]}{let[e,t,s]=[...arguments];return t}}},c={accessors:[n.default]};function o(){const[t,n,r]=[...arguments],o=Object.assign({},c,r);if(void 0===n)return arguments[0];const i=new s(o.accessors),a=n.split(new RegExp(e.quotationEscape));let u=t;e:for(const e of a)try{if(u=i.cess(u,e),void 0===u)break e}catch(e){break e}return u}const i={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},a=Object.keys(i),u=Object.values(i),l={object:Object,array:Array},f=Object.keys(l),p=Object.values(l),b=Object.assign({},i,l),d=Object.keys(b),O=Object.values(b),g=[i.String,i.Number,i.Boolean,l.Object,l.Array];var j=Object.freeze({__proto__:null,ObjectKeys:f,ObjectValues:p,Objects:l,PrimitiveKeys:a,PrimitiveValues:u,Primitives:i,TypeKeys:d,TypeMethods:g,TypeValues:O,Types:b});const y={accessors:[n.default],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function h(e,r,c){const o=[],i=Object.assign({},y,c,{ancestors:[].concat(c.ancestors||[])}),{ancestors:a,maxDepth:u,enumerable:l,nonenumerable:p,recurse:b}=(new s([n.default]).cess(e),i);if(i.depth>=u)return o;i.depth++,a.includes(e)||a.push(e);for(const[s,n]of Object.entries(Object.getOwnPropertyDescriptors(e)))if(l&&n.enumerable||p&&!n.enumerable){const e=n.value,c=t(e);b&&f.includes(c)&&!a.includes(e)?"entries"===r?o.push([s,h(e,r,i)]):"values"===r?o.push(h(e,r,i)):"keys"===r&&o.push(s,h(e,r,i)):"entries"===r?o.push([s,e]):"values"===r?o.push(e):"keys"===r&&o.push(s)}return o}function m(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();"object"===t?s={}:"array"===t&&(s=[])}else"object"===n?s={}:"array"===n&&(s=[]);return s}const v={enumerable:!0,nonenumerable:!1,accessors:[n.default],processors:[r.default]};function P(){const n=[...arguments];if("string"===t(n[1])){const[t,r,c,o]=n,i=Object.assign({},v,o),a=new s(i.accessors),u=new s(i.processors),{enumerable:l,nonenumerable:f}=i,p=a.cess(t),b=r.split(new RegExp(e.quotationEscape)),d=b.pop();let O=p;for(const e of b)O=a.cess(O,e,i)||u.cess(O,e,isNaN(e)?{}:[],i);return u.cess(O,d,c),t}{const[e,t]=n;return e}}function w(t,s){const n=s.split(new RegExp(e.quotationEscape)),r=n.pop();let c=t;for(const e of n)c=c[e];delete c[r]}var k=(e,t)=>h(e,"entries",t);const D={ancestors:[],nonenumerable:!1},x=["string","function"];function E(e,s,n={}){const r=Object.assign({},D,n,{ancestors:[].concat(n.ancestors||[])}),{ancestors:c}=r,o=t(s),i=t(e);if(!x.includes(o)||!f.includes(i))return e;c.includes(e)||c.unshift(e);let a=m(e);for(const[n,i]of k(e,Object.assign({},r,{recurse:!1}))){const u=f.includes(t(i))?E(i,s):i;o!==x[0]||null===i||Object.is(i,e)||c.includes(i)?o===x[1]&&(a[n]=s(u)):a[n]=P({},s,u,r)}return a}const z={};function C(e,s,n){const r=Object.assign({},z,n),c=t(s);let i=m(e);for(const[t,n]of k(e,Object.assign({},r,{recurse:!1})))"string"===c?i[t]=o(n,s):"function"===c&&(i[t]=s(n)),i[t]&&"object"==typeof i[t]&&(i[t]=C(i[t],s));return i}const A={accessors:[n.default],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,values:!1};function N(e,t){const n=[],r=Object.assign({},A,t,{ancestors:[].concat(t.ancestors||[])}),{ancestors:c,nonenumerable:o,values:i}=r;if(r.depth++,r.depth>r.maxDepth)return n;const a=new s(r.accessors).cess(e);c.includes(a)||c.unshift(a);const u=h(a,"entries",{nonenumerable:o,recurse:!1});for(const[e,t]of u)if(i?i&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,a)&&!c.includes(t)){const s=N(t,r);if(i){if(i)for(const[t,r]of s){const s=[e,t].join(".");n.push([s,r])}}else for(const t of s){const s=[e,t].join(".");n.push(s)}}return n}const L={processors:[r.default],values:!1};function T(e,s){const n=Object.assign({},L,s),r="object"===t(e)?Object.entries(e):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)P(c,e,t,n);return c}function S(e,s,...n){if(!e)return e;const r=t(e);for(const c of n)if(c)for(const[n,o]of Object.entries(c)){const c=e[n],i=t(c);t(o);"array"===r&&"assignConcat"===s?e.push(o):f.includes(i)?S(c,s,o):Object.assign(e,{[n]:o})}return e}var q=(e,...t)=>S(e,"assign",...t),_=(e,...t)=>S(e,"assignConcat",...t);const B={strict:!0};function K(e,s){const n=Object.assign({},B,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of h(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const R={typeCoercion:!1};function V(e,s,n,r){const c=Object.assign({},n);let o=c.value;const a=Object.assign({},R,r),u=t(c.value),l=e[s],p=t(l);if(f.includes(u))if(f.includes(p))c.value=I(l,o,a);else{const e=m(K(Object.defineProperties({},o))?"array":"object");c.value=I(e,o,a)}else a.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined","null"].includes(u)&&(c.value=i[c.type](o));return Object.defineProperty(e,s,c),n.sealed&&Object.seal(e[s]),n.frozen&&Object.freeze(e[s]),e}function I(e,t,s){for(const[n,r]of Object.entries(t))V(e,n,r,s);return e}const F={ancestors:[]};function M(e,s){const{ancestors:n}=Object.assign({},F,s,{ancestors:Object.assign([],s.ancestors)});options.ancestors.includes(e)||options.ancestors.unshift(e);for(const[s,n]of Object.entries(e)){const e=t(n);options.ancestors.includes(n)||f.includes(e)&&M(n,options)}return Object.freeze(e)}const $={ancestors:[]};function G(e,s){const{ancestors:n}=Object.assign({},$,s,{ancestors:Object.assign([],s.ancestors)});options.ancestors.includes(e)||options.ancestors.unshift(e);for(const[s,n]of Object.entries(e)){const e=t(n);options.ancestors.includes(n)||f.includes(e)&&G(n,options)}return Object.seal(e)}const H={strict:!0,isArrayLike:!1};function J(e,s){const n=Object.assign({},H,s);if("array"!==t(e)){if(!n.isArrayLike||!K(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var Q=(e,t)=>h(e,"keys",t),U=(e,t)=>h(e,"values",t);const W={accessors:[n.default],ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function X(e,n,r={}){const c=Object.assign({},W,r,{ancestors:Object.assign([],r.ancestors)});if(c.depth>=c.maxDepth)return;c.depth++;const o=new s(c.accessors).cess(e,n);if(o){const s=Object.getOwnPropertyDescriptor(e,n);if(!c.nonenumerable&&!s.enumerable)return;if(c.ancestors.includes(e)||c.ancestors.unshift(e),c.ancestors.includes(o))return;return c.path&&(c.path="string"===t(c.path)?[c.path,n].join(c.delimiter):n,s.path=c.path),c.type&&(s.type=t(o)),c.frozen&&(s.frozen=Object.isFrozen(o)),c.sealed&&(s.sealed=Object.isSealed(o)),f.includes(t(o))&&(s.value=Y(o,c)),s}}function Y(e,t){const s={};for(const[n,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=X(e,n,t);r&&(s[n]=r)}return s}function Z(e,t){}function ee(e,t){}class te extends EventTarget{static compand=N;static decompand=T;static expand=E;static impand=C;static keys=Q;static values=U;static entries=k;static entities=h;static get=o;static set=P;static delete=w;static assign=q;static assignConcat=_;static defineProperties=I;static defineProperty=V;static freeze=M;static seal=G;static getOwnPropertyDescriptors=Y;static getOwnPropertyDescriptor=X;static isArrayLike=K;static isEntries=J;static typeOf=t;static toString=Z;static valueOf=ee;constructor(e){super();for(const[t,s]of Object.entries({compand:te.compand,decompand:te.decompand,expand:te.expand,impand:te.impand,entities:te.entities,keys:te.keys,values:te.values,entries:te.entries,get:te.get,set:te.set,delete:te.delete,assign:te.assign,assignConcat:te.assignConcat,defineProperties:te.defineProperties,defineProperty:te.defineProperty,freeze:te.freeze,seal:te.seal,getOwnPropertyDescriptors:te.getOwnPropertyDescriptors,getOwnPropertyDescriptor:te.getOwnPropertyDescriptor,isArrayLike:te.isArrayLike,isEntries:te.isEntries,typeOf:te.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{te as Recourse,q as assign,_ as assignConcat,N as compand,T as decompand,I as defineProperties,V as defineProperty,w as delete,h as entities,k as entries,E as expand,M as freeze,o as get,X as getOwnPropertyDescriptor,Y as getOwnPropertyDescriptors,C as impand,K as isArrayLike,J as isEntries,Q as keys,e as regularExpressions,G as seal,P as set,t as typeOf,m as typedObjectLiteral,U as values,j as variables};
//# sourceMappingURL=recourse.min.js.map
