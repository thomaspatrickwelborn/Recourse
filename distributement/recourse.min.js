function e(e){if(e.length<3)return"{"+e+"}";for(var t=-1,s=2;s<e.length;s++)if("."===e[s]&&"."===e[s-1]&&(s<2||"\\"!==e[s-2])){if(t>-1)return"{"+e+"}";t=s-1}if(t>-1){var n=e.substr(0,t),r=e.substr(t+2);if(n.length>0&&r.length>0)return"["+e.substr(0,t)+"-"+e.substr(t+2)+"]"}return"{"+e+"}"}function t(s){if("string"!=typeof s)throw new TypeError("A pattern must be a string, but "+typeof s+" given");for(var n,r=!1,a=0,c=0,o=-1,i=[""],u=[],p=0;p<s.length;p++){var l=s[p];if("\\"!==l){if("{"===l)if(r)a++;else if(p>o&&!a){n=s.substring(o+1,p);for(var f=0;f<i.length;f++)i[f]+=n;u=[],o=p,r=!0,a++}else a--;else if("}"===l)if(r)c++;else if(1===c){if(n=s.substring(o+1,p),u.length>0){var g=[];u.push(t(n));for(f=0;f<i.length;f++)for(var h=0;h<u.length;h++)for(var d=0;d<u[h].length;d++)g.push(i[f]+u[h][d]);i=g}else{n=e(n);for(f=0;f<i.length;f++)i[f]+=n}o=p,c--}else c--;else r||","!==l||c-a!==1||(n=s.substring(o+1,p),u.push(t(n)),o=p);!r||c!==a&&p!==s.length-1||(r=!1,p=o-1)}else p++}if(-1===o)return[s];var b="{"===s[o]?o:o+1;if(b<s.length){n=s.substr(b);for(f=0;f<i.length;f++)i[f]+=n}return i}function s(e,t){var s,n=!1!==t["!"],r=!1!==t["()"],a=!1;if(n){for(s=0;s<e.length&&"!"===e[s];s++){if(r&&"("===e[s+1]){s--;break}a=!a}s>0&&(e=e.substr(s))}return{pattern:e,isNegated:a}}function n(e){return"-"===e||"^"===e||"$"===e||"+"===e||"."===e||"("===e||")"===e||"|"===e||"["===e||"]"===e||"{"===e||"}"===e||"*"===e||"?"===e||"\\"===e?"\\"+e:e}function r(e,t,s){var r=void 0===t.separator||t.separator,a="",c="",o=".";!0===r?(a="/",c="[/\\\\]",o="[^/\\\\]"):o=r?(c=function(e){for(var t="",s=0;s<e.length;s++)t+=n(e[s]);return t}(a=r)).length>1?"((?!"+(c="(?:"+c+")")+").)":"[^"+c+"]":".";var i=r?c+"+?":"",u=r?c+"*?":"",p=r?e.split(a):[e];return{source:e,segments:p,options:t,separator:r,separatorSplitter:a,separatorMatcher:c,optionalSeparator:u,requiredSeparator:i,wildcard:o,support:{qMark:!1!==t["?"],star:!1!==t["*"],globstar:r&&!1!==t["**"],brackets:!1!==t["[]"],extglobs:!1!==t["()"],excludeDot:s&&!1!==t.excludeDot}}}function a(e,t,s,n){return{source:e,isFirst:s,isLast:n,end:e.length-1}}var c="(?!\\.)";function o(e,t,s){return e.addToUnmatch&&(e.result.unmatch+=t),e.addToMatch&&(s&&!e.dotHandled&&(t=c+t),e.dotHandled=!0,e.result.match+=t),e.result}function i(e,t,s){var r=e.support,a=function(e,t,s){return{pattern:e,segment:t,result:s,openingBracket:t.end+1,closingBracket:-1,openingParens:0,closingParens:0,parensHandledUntil:-1,extglobModifiers:[],scanningForParens:!1,escapeChar:!1,addToMatch:!0,addToUnmatch:e.support.extglobs,dotHandled:!1,i:-1,char:"",nextChar:""}}(e,t,s),i=t.isLast?e.optionalSeparator:e.requiredSeparator;if(r.excludeDot||(a.dotHandled=!0),-1===t.end)return t.isLast&&!t.isFirst?s:o(a,i);if(r.globstar&&"**"===t.source)return o(a,"(?:"+((a.dotHandled?"":c)+e.wildcard+"*?"+i)+")*?");for(;++a.i<=t.end;){if(a.char=a.segment.source[a.i],a.nextChar=a.i<t.end?t.source[a.i+1]:"","\\"===a.char){if(a.i<a.segment.end){a.escapeChar=!0;continue}a.char=""}e=a.pattern,t=a.segment;var u=a.char,p=a.i;if(e.support.brackets&&!a.scanningForParens){if(p>a.openingBracket&&p<=a.closingBracket){a.escapeChar?o(a,n(u)):p===a.closingBracket?(o(a,"]"),a.openingBracket=t.source.length):"-"===u&&p===a.closingBracket-1?o(a,"\\-"):"!"===u&&p===a.openingBracket+1?o(a,"^"):o(a,"]"===u?"\\]":u),a.escapeChar=!1;continue}if(p>a.openingBracket){"]"===u&&!a.escapeChar&&p>a.openingBracket+1&&p>a.closingBracket?(a.closingBracket=p,a.i=a.openingBracket,e.separator?o(a,"(?!"+e.separatorMatcher+")[",!0):o(a,"[",!0)):p===t.end&&(o(a,"\\["),a.i=a.openingBracket,a.openingBracket=t.source.length,a.closingBracket=t.source.length),a.escapeChar=!1;continue}if("["===u&&!a.escapeChar&&p>a.closingBracket&&p<t.end){a.openingBracket=p,a.escapeChar=!1;continue}}if(a.pattern.support.extglobs){var l=a.extglobModifiers,f=(u=a.char,a.nextChar);p=a.i;if("("!==f||a.escapeChar||"@"!==u&&"?"!==u&&"*"!==u&&"+"!==u&&"!"!==u){if(")"!==u||a.escapeChar){if("|"===u&&a.closingParens&&!a.scanningForParens&&!a.escapeChar){o(a,"|");continue}}else if(a.scanningForParens)a.closingParens++;else if(l.length){var g=l.pop();if("!"===g&&-1!==l.indexOf("!"))throw new Error("Nested negated extglobs aren't supported");o(a,")"+(g="!"===g||"@"===g?"":g)),a.addToMatch=!0,a.addToUnmatch=!0,a.closingParens--;continue}}else if(a.scanningForParens)a.openingParens++;else if(p>a.parensHandledUntil&&!a.closingParens)a.parensHandledUntil=p,a.scanningForParens=!0,a.openingParens++;else{if(a.closingParens>=a.openingParens){"!"===u&&(a.addToMatch=!0,a.addToUnmatch=!1,o(a,a.pattern.wildcard+"*?",!0),a.addToMatch=!1,a.addToUnmatch=!0,a.result.useUnmatch=!0),l.push(u),o(a,"(?:",!0),a.openingParens--,a.i++;continue}a.openingParens--}if(a.scanningForParens){a.closingParens!==a.openingParens&&p!==a.segment.end||(a.scanningForParens=!1,a.i=a.parensHandledUntil-1),a.escapeChar=!1;continue}}r=(e=a.pattern).support;!a.escapeChar&&r.star&&"*"===a.char?a.i!==a.segment.end&&"*"===a.nextChar||o(a,e.wildcard+"*?",!0):!a.escapeChar&&r.qMark&&"?"===a.char?o(a,e.wildcard,!0):o(a,n(a.char)),a.escapeChar=!1}return o(a,i)}function u(e,t,s){for(var n=r(e,t,s),c={match:"",unmatch:"",useUnmatch:!1},o=n.segments,u=0;u<o.length;u++){i(n,a(o[u],0,0===u,u===o.length-1),c)}return c.useUnmatch?"(?!^"+c.unmatch+"$)"+c.match:c.match}function p(e,t){if("string"!=typeof t)throw new TypeError("Sample must be a string, but "+typeof t+" given");return e.test(t)}function l(e,n){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("The first argument must be a single pattern string or an array of patterns, but "+typeof e+" given");if("string"!=typeof n&&"boolean"!=typeof n||(n={separator:n}),2===arguments.length&&void 0!==n&&("object"!=typeof n||null===n||Array.isArray(n)))throw new TypeError("The second argument must be an options object or a string/boolean separator, but "+typeof n+" given");if("\\"===(n=n||{}).separator)throw new Error("\\ is not a valid separator");var r=function(e,n){e=Array.isArray(e)?e:[e],!1!==n["{}"]&&(e=function(e,t){for(var s=[],n=0;n<e.length;n++)for(var r=t(e[n]),a=0;a<r.length;a++)s.push(r[a]);return s}(e,t));for(var r=[],a=[],c="",o=0;o<e.length;o++){var i=s(e[o],n),p=u(i.pattern,n,!i.isNegated);i.isNegated?a.push(p):r.push(p)}return a.length&&(c="(?!(?:"+a.join("|")+")$)"),r.length>1?c+="(?:"+r.join("|")+")":1===r.length?c+=r[0]:c.length&&(c+=u("**",n,!0)),"^"+c+"$"}(e,n),a=new RegExp(r,n.flags),c=p.bind(null,a);return c.options=n,c.pattern=e,c.regexp=a,c}function f(e,t){const s=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,n=[];let r;for(;null!==(r=s.exec(e));)r[1]?n.push(r[1]):r[2]?t?n.push(parseInt(r[2],10)):n.push(r[2]):r[3]?n.push(r[3]):r[4]&&n.push(r[4]);return n}var g=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const h={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},d=Object.keys(h),b=Object.values(h),j={object:Object,array:Array,eventtarget:EventTarget,map:Map},O=Object.keys(j),y=Object.values(j),m=Object.assign({},h,j),v=Object.keys(m),M=Object.values(m),P=[h.String,h.Number,h.Boolean,j.Object,j.Array];var k=Object.freeze({__proto__:null,ObjectKeys:O,ObjectValues:y,Objects:j,PrimitiveKeys:d,PrimitiveValues:b,Primitives:h,TypeKeys:v,TypeMethods:P,TypeValues:M,Types:m});const w={Object:function(...e){if(1===e.length){const[t]=e;return t}{const[t,s]=e;return t[s]}},Map:function(...e){if(1===e.length){let[t]=e;return t}{let[t,s]=e;return t.get(s)}}},x={Object:function(...e){if(["string","number"].includes(g(e[1]))){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,n]of Object.entries(s))t[e]=n;return t}},Map:function(...e){if(2===e.length){let[t,s]=e;t.clear();const n="map"===g(s)?s.entries():Object.entries(s);for(const[e,s]of n)t.set(e,s);return t}{let[t,s,n]=e;return t.set(s,n),t.get(s)}}},V={Object:function(...e){const[t,s]=e;if(["string","number"].includes(g(s)))return delete t[s];for(const e of Object.keys(t))delete t[e]},Map:function(...e){if(2===e.length){let[t,s]=e;return t.delete(s)}{let[t]=e;return t.clear()}}},C={Object:e=>!(e instanceof Map)&&["array","object"].includes(typeof e),Map:e=>e instanceof Map};class D extends EventTarget{constructor(e,t){super(),Object.defineProperties(this,{cess:{value:function(...s){const[n]=s;let r=0;for(const a of t){if(a(n))return e[r](...s);if(r++,r===t.length)throw new Error(null)}}}})}}var T=Object.freeze({__proto__:null,Deleters:V,Getters:w,Setters:x,Tensors:D,TypeValidators:C});function B(e,t={}){const s=Object.assign({},t),n={},r=g(e),a=["array","object"].includes(r)?Object.keys(Object.getOwnPropertyDescriptors(e)):"map"==r?Array.from(e.keys()):[];for(const t of a){const r=I(e,t,s);r&&(n[t]=r)}return n}const A={getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map],delimiter:".",depth:0,enumerable:!0,frozen:!1,maxDepth:10,nonenumerable:!1,path:!1,pathMatch:!1,recurse:!0,returnValue:"receiver",sealed:!1,type:!1};function I(e,t,s={}){const n=Object.assign({},A,s,{ancestors:Object.assign([],s.ancestors)});if(n.depth>=n.maxDepth)return;n.depth++,n.ancestors.includes(e)||n.ancestors.unshift(e);const r=new D(n.getters,n.typeValidators).cess(e,t);if(void 0!==r){if(O.includes(g(r))){if(n.ancestors.includes(r))return;n.ancestors.unshift(r)}const s=g(e),a="map"!==s?Object.getOwnPropertyDescriptor(e,t):"map"===s?{configurable:!1,enumerable:!0,value:r[1],writable:!0}:void 0;if(!a)return;if(!n.nonenumerable&&!a.enumerable)return;return n.path&&(n.path="string"===g(n.path)?[n.path,t].join(n.delimiter):t,a.path=n.path),n.type&&(a.type=g(r)),n.frozen&&(a.frozen=Object.isFrozen(r)),n.sealed&&(a.sealed=Object.isSealed(r)),n.recurse&&O.includes(g(r))?a.value=B(r,n):a.value=r,a}}const N={pathParseInteger:!1,getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function z(e,t,s={}){const n=[],r=Object.assign({},N,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:a,maxDepth:c,enumerable:o,nonenumerable:i,recurse:u}=r;if(r.depth>=c)return n;a.includes(e)||a.unshift(e),r.depth++;const p=new D(r.getters,r.typeValidators),l=p.cess(e);if(!l)return n;const f="map"===g(l)?l.keys():i?Object.keys(Object.getOwnPropertyDescriptors(l)):Object.keys(l);for(let s of f){!isNaN(s)&&r.pathParseInteger&&(s=parseInt(s,10));const c=p.cess(e,s),l=I(e,s,Object.assign({},r,{recurse:!1}));if(l&&(o&&l.enumerable||i&&!l.enumerable)){const e=g(c);if(u&&O.includes(e)&&!a.includes(c)){a.unshift(c);const e=z(c,t,r);e.length?"entries"===t?n.push([s,e]):"values"===t?n.push(e):"keys"===t&&n.push(s,e):"entries"===t?n.push([s,c]):"values"===t?n.push(c):"keys"===t&&n.push(s)}else"entries"===t?n.push([s,c]):"values"===t?n.push(c):"keys"===t&&n.push(s)}}return n}const S={depth:0,getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map],maxDepth:10,values:!1,returnValue:"receiver"};function U(e,t={}){const s=[],n=Object.assign({},S,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:a}=n;if(n.depth++,n.depth>n.maxDepth)return s;const c=new D(n.getters,n.typeValidators).cess(e);r.includes(e)||r.unshift(e);const o=z(e,"entries",Object.assign({},n,{recurse:!1}));for(const[e,t]of o)if(a?a&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,c)&&!r.includes(t)){const r=U(t,n);if(a){if(a)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const E={pathMatch:!1,pathMatchMaxResults:1e3,pathParseInteger:!1,getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map]};function F(){const[e,t,s]=[...arguments],n=Object.assign({},E,s),r=new D(n.getters,n.typeValidators);if(void 0===t)return r.cess(e,n);const a=f(t,n.pathParseInteger);if(n.pathMatch){const s=[],r=U(e,Object.assign({},n,{values:!0})),a=l(t,{separator:"."});for(const[e,t]of r){!0===a(e)&&s.push([e,t])}return s}{let t=e;e:for(const e of a)try{if(t=r.cess(t,e),void 0===t)break e}catch(e){break e}return t}}const L={strict:!0};function _(e,t){const s=Object.assign({},L,t);let n;const r=g(e);if("array"===r)n=!0;else if("object"===r&&e.length>=0&&Number.isInteger(e.length))if(!1===s.strict)n=!0;else{e:for(const t of z(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){n=!0;break e}}void 0===n&&(n=!1)}else n=!1;return n}const H={strict:!0};function $(e,t){const s=Object.assign({},H,t);let n;const r=g(e);if("map"===r)n=!0;else if("object"===r&&e.size>=0&&Number.isInteger(e.size))if(!1===s.strict)n=!0;else{e:for(const t of z(e,"entries",{nonenumerable:!0,recurse:!1})){if(!_(t,s)&&2!==t.length){n=!1;break e}n=!0}void 0===n&&(n=!1)}else n=!1;return n}function q(e,t=!0){let s;const n=g(e);if("string"===n){const t=e.toLowerCase();if("object"===t)return Object();if("array"===t)return Array();if("map"===t)return new Map;s={}}else{if("object"===n)return Object();if(_(e,{strict:t}))return Array();if($(e,{strict:t}))return new Map;s={}}}const K={pathMatch:!1,pathMatchMaxResults:1e3,pathParseInteger:!1,getters:[w.Object,w.Map],setters:[x.Object,x.Map],typeValidators:[C.Object,C.Map]};function R(){const e=[...arguments],[t,s,n,r]=e,a=Object.assign({},K,r),c=new D(a.getters,a.typeValidators),o=new D(a.setters,a.typeValidators);if(a.pathMatch){const e=[],r=U(t,Object.assign({},a,{values:!0})),c=l(s,{separator:"."});for(const[s,o]of r){!0===c(s,{separator:"."})&&(R(t,s,n,{pathMatch:!1,pathParseInteger:a.pathParseInteger}),e.push([s,n]))}return e}if("string"===g(e[1])){const{enumerable:e,nonenumerable:r}=a,i=(c.cess(t),f(s,a.pathParseInteger)),u=i.pop();let p=t;e:for(const e of i)if(p=c.cess(p,e,a)||o.cess(p,e,isNaN(e)?{}:[]),void 0===p)break e;return o.cess(p,u,n,a),t}{const[t,s]=e;return t}}const Z={pathMatch:!1,pathMatchMax:100,pathParseInteger:!1,deleters:[V.Object,V.Map],typeValidators:[C.Object,C.Map]};function G(e,t,s){const n=Object.assign({},Z,s),r=new D(n.deleters,n.typeValidators);if(n.pathMatch){const s=[],r=U(e,Object.assign({},n,{values:!0})),a=l(t,{separator:"."});for(const[t,c]of r){!0===a(t,{separator:"."})&&(G(e,t,{pathMatch:!1,pathParseInteger:n.pathParseInteger}),s.push([t,void 0]))}return s}{const s=f(t,n.pathParseInteger),a=s.pop(),c=F(e,s.join("."),n)||e;r.cess(c,a)}}const J=["string","function"];function Q(e,t,s={}){const n=Object.assign({},s),r=g(t),a=g(e);if(!J.includes(r)||!O.includes(a))return e;let c=q(e);for(const[s,a]of z(e,"entries",Object.assign({},n,{recurse:!1}))){const e=O.includes(g(a))?Q(a,t,n):a;r===J[0]?c[s]=R({},t,e,n):r===J[1]&&(c[s]=t(e))}return c}const W={ancestors:[],getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map],depth:0,maxDepth:10};function X(e,t,s={}){const n=Object.assign({},W,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:a}=n;if(n.depth>n.maxDepth)return;n.depth++;const c=new D(n.getters,n.typeValidators).cess(e);r.includes(c)||r.unshift(c);const o=g(t);let i=q(e);for(const[s,r]of z(e,"entries",Object.assign({},n,{recurse:!1})))"string"===o?i[s]=F(r,t):"function"===o&&(i[s]=t(r)),i[s]&&"object"==typeof i[s]&&(i[s]=X(i[s],t));return i}const Y={setters:[x.Object,x.Map]};function ee(e,t){const s=Object.assign({},Y,t),n="object"===g(e)?z(e,"entries",s):e;if(!n)return;const r=isNaN(n[0][0])?{}:[];for(const[e,t]of n)R(r,e,t,s);return r}const te={getters:[w.Object,w.Map],setters:[x.Object,x.Map],typeValidators:[C.Object,C.Map]};function se(e,t,...s){if(!e)return e;const n=Object.assign({},te),r=new D(n.getters,n.typeValidators),a=new D(n.setters,n.typeValidators),c=g(e);e:for(const n of s){if(!O.includes(g(n)))continue e;const s=z(n,"entries",{recurse:!1});for(const[n,o]of s){const s=r.cess(e,n),i=g(s),u=g(o);"array"===c&&"assignConcat"===t?a.cess(e,e.length,o):O.includes(u)&&O.includes(i)?se(s,t,o):a.cess(e,n,o)}}return e}var ne=(e,...t)=>se(e,"assign",...t),re=(e,...t)=>se(e,"assignConcat",...t);const ae={typeCoercion:!1};function ce(e,t,s,n){const r=Object.assign({},s);let a=r.value;const c=Object.assign({},ae,n),o=g(r.value),i=e[t],u=g(i);if(O.includes(o))if(O.includes(u))r.value=oe(i,a,c);else{const e=q(_(Object.defineProperties({},a))?"array":"object");r.value=oe(e,a,c)}else c.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(r,"type")&&!["undefined"].includes(o)&&(r.value=new h[r.type](a));return Object.defineProperty(e,t,r),s.sealed&&Object.seal(e[t]),s.frozen&&Object.freeze(e[t]),e}function oe(e,t,s){for(const[n,r]of Object.entries(t))ce(e,n,r,s);return e}const ie={getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map],ancestors:[],depth:0,maxDepth:10};function ue(e,t={}){const s=Object.assign({},ie,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:n,values:r}=s;if(s.depth>s.maxDepth)return;s.depth++;const a=new D(s.getters,s.typeValidators).cess(e);n.includes(a)||n.unshift(a);const c=z(e,"entries",Object.assign(s,{recurse:!1}));for(const[e,t]of c)n.includes(t)||O.includes(g(t))&&ue(t,s);return Object.freeze(e)}const pe={getters:[w.Object,w.Map],typeValidators:[C.Object,C.Map],ancestors:[],depth:0,maxDepth:10};function le(e,t={}){const s=Object.assign({},pe,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:n,values:r}=s;if(s.depth>s.maxDepth)return;s.depth++;const a=new D(s.getters,s.typeValidators).cess(e);n.includes(a)||n.unshift(a);const c=z(e,"entries",Object.assign(s,{recurse:!1}));for(const[e,t]of c)n.includes(t)||O.includes(g(t))&&le(t,s);return Object.seal(e)}var fe=(e,t)=>z(e,"keys",t),ge=(e,t)=>z(e,"values",t),he=(e,t)=>z(e,"entries",t);function de(e,t={}){if("receiver"===Object.assign({},t).returnValue)return e;return oe(q(g(e)),B(e,t))}const be={space:0,replacer:null};function je(e,t){const s=Object.assign({},be,t);return JSON.stringify(de(e,s),s.replacer,s.space)}class Oe extends EventTarget{#e;#t;static compand=U;static decompand=ee;static expand=Q;static impand=X;static keys=fe;static values=ge;static entries=he;static entities=z;static get=F;static set=R;static delete=G;static assign=ne;static assignConcat=re;static defineProperties=oe;static defineProperty=ce;static freeze=ue;static seal=le;static getOwnPropertyDescriptors=B;static getOwnPropertyDescriptor=I;static isArrayLike=_;static isMapLike=$;static typeOf=g;static toString=je;get toString(){return Object.defineProperty(this,$staticMethodName,{value:$staticMethod.bind(null,this.#e,this.#t)})}static valueOf=de;constructor(e,t={}){super(),this.#e=e,this.#t=t;for(const[t,s]of Object.entries({compand:Oe.compand,decompand:Oe.decompand,expand:Oe.expand,impand:Oe.impand,entities:Oe.entities,keys:Oe.keys,values:Oe.values,entries:Oe.entries,get:Oe.get,set:Oe.set,delete:Oe.delete,assign:Oe.assign,assignConcat:Oe.assignConcat,defineProperties:Oe.defineProperties,defineProperty:Oe.defineProperty,freeze:Oe.freeze,seal:Oe.seal,getOwnPropertyDescriptors:Oe.getOwnPropertyDescriptors,getOwnPropertyDescriptor:Oe.getOwnPropertyDescriptor,isArrayLike:Oe.isArrayLike,isMapLike:Oe.isMapLike,typeOf:Oe.typeOf}))Object.defineProperty(this,t,{value:s.bind(null,e)})}}export{Oe as Recourse,ne as assign,re as assignConcat,U as compand,ee as decompand,oe as defineProperties,ce as defineProperty,G as delete,z as entities,he as entries,Q as expand,ue as freeze,F as get,I as getOwnPropertyDescriptor,B as getOwnPropertyDescriptors,X as impand,_ as isArrayLike,fe as keys,le as seal,R as set,f as splitPath,T as tensors,je as toString,g as typeOf,q as typedObjectLiteral,de as valueOf,ge as values,k as variables};
//# sourceMappingURL=recourse.min.js.map
