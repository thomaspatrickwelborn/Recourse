const e={string:String,number:Number,boolean:Boolean,undefined:void 0,null:null},t=Object.keys(e),o=Object.values(e),n={object:Object,array:Array},r=Object.keys(n),c=Object.values(n),s=Object.assign({},e,n),i=Object.keys(s),u=Object.values(s),f=[e.String,e.Number,e.Boolean,n.Object,n.Array];var a=Object.freeze({__proto__:null,ObjectKeys:r,ObjectValues:c,Objects:n,PrimitiveKeys:t,PrimitiveValues:o,Primitives:e,TypeKeys:i,TypeMethods:f,TypeValues:u,Types:s}),b={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/},l=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function j(e){return e.split(new RegExp(b.quotationEscape))}function p(e){const t=j(e);return t.pop(),t}function y(e){return j(e).pop()}function O(e){return j(e).shift()}function v(e){return Number(O(e))?"array":"object"}function g(e){return{subpaths:j(e),keypaths:p(e),key:y(e),root:O(e),typeofRoot:v(e)}}function d(e){let t;const o=l(e);if("string"===o){const o=e.toLowerCase();"object"===o?t={}:"array"===o&&(t=[])}else"object"===o?t={}:"array"===o&&(t=[]);return t}function h(e,t){const o=e.split(new RegExp(b.quotationEscape)),n=o.pop();let r=t;for(const e of o)r=r[e];return r[n]}function m(e,t){const{keypaths:o,key:n,typeofRoot:r}=g(e),c=d(r);let s=c;for(const e of o)Number(e)?s[e]=[]:s[e]={},s=s[e];return s[n]=t,c}function k(e,t){const o=l(t),n=l(e);if(!["string","function"].includes(o)||!["array","object"].includes(n))return e;let r=d(e);for(const[n,c]of Object.entries(e))"string"===o?r[n]=m(t,c):"function"===o&&(r[n]=t(c)),r[n][t]&&"object"==typeof r[n][t]&&(r[n][t]=k(r[n][t],t));return r}function P(e,t){const o=l(t),n=l(e);if(!["string","function"].includes(o)||!["array","object"].includes(n))return e;let r=d(e);for(const[n,c]of Object.entries(e))"string"===o?r[n]=h(t,c):"function"===o&&(r[n]=t(c)),r[n]&&"object"==typeof r[n]&&(r[n]=P(r[n],t));return r}var w=e=>{let t;const o=l(e);if("array"===o)t=!0;else if("object"===o&&Number.isInteger(e.length)&&e.length>=0){e:for(const o of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==o&&(t=!isNaN(o),!t))break e}else t=!1;return t};const N={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default]};function x(e,t){const o=[],n=Object.assign({},N,t);if(n.depth++,n.depth>n.maxDepth)return o;for(const t of n.accessors){const r=t.bind(e)(e);if(r)for(const[e,t]of Object.entries(r))if(n.values?n.values&&o.push([e,t]):o.push(e),"object"==typeof t&&null!==t&&t!==r){const r=x(t,n);if(n.values){if(n.values)for(const[t,n]of r){const r=[e,t].join(".");o.push([r,n])}}else for(const t of r){const n=[e,t].join(".");o.push(n)}}}return o}function D(e,...t){if(!e)return e;for(const o of t)if(o)for(const[t,n]of Object.entries(o)){const o=l(e[t]),r=l(n);e[t]="object"===o&&"object"===r?D(e[t],n):n}return e}function E(e,...t){if(!e)return e;for(const o of t)if(o)for(const[t,n]of Object.entries(o)){const o=l(e[t]),r=l(n);e[t]="object"===o&&"object"===r?E(e[t],n):"array"===o&&"array"===r?e[t].concat(n):n}return e}function R(e,t){const o=Object.getOwnPropertyDescriptor(e,t);return["array","object"].includes(l(o.value))&&(o.value=T(o.value)),o}function T(e){const t={};for(const o of Object.keys(Object.getOwnPropertyDescriptors(e)))t[o]=R(e,o);return t}function _(e,t,o){const n=l(o.value);if(["array","object"].includes(n)){const e=w(Object.defineProperties(d(n),o.value))?[]:{};o.value=q(e,o.value)}return Object.defineProperty(e,t,o),e}function q(e,t){for(const[o,n]of Object.entries(t))_(e,o,n);return e}function K(e){for(const[t,o]of Object.entries(e))o&&"object"==typeof o&&K(o);return Object.freeze(e)}export{k as expandTree,P as impandTree,w as isArrayLike,x as propertyDirectory,D as recursiveAssign,E as recursiveAssignConcat,q as recursiveDefineProperties,_ as recursiveDefineProperty,K as recursiveFreeze,R as recursiveGetOwnPropertyDescriptor,T as recursiveGetOwnPropertyDescriptors,b as regularExpressions,l as typeOf,d as typedObjectLiteral,a as variables};
//# sourceMappingURL=recourse.min.js.map
