const e={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},t=Object.keys(e),n=Object.values(e),o={object:Object,array:Array},r=Object.keys(o),c=Object.values(o),s=Object.assign({},e,o),i=Object.keys(s),u=Object.values(s),f=[e.String,e.Number,e.Boolean,o.Object,o.Array];var a=Object.freeze({__proto__:null,ObjectKeys:r,ObjectValues:c,Objects:o,PrimitiveKeys:t,PrimitiveValues:n,Primitives:e,TypeKeys:i,TypeMethods:f,TypeValues:u,Types:s}),l={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/},b=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function p(e){return e.split(new RegExp(l.quotationEscape))}function j(e){const t=p(e);return t.pop(),t}function y(e){return p(e).pop()}function O(e){return p(e).shift()}function v(e){return Number(O(e))?"array":"object"}function g(e){return{subpaths:p(e),keypaths:j(e),key:y(e),root:O(e),typeofRoot:v(e)}}function d(e){let t;const n=b(e);if("string"===n){const n=e.toLowerCase();"object"===n?t={}:"array"===n&&(t=[])}else"object"===n?t={}:"array"===n&&(t=[]);return t}function h(e,t){const n=e.split(new RegExp(l.quotationEscape)),o=n.pop();let r=t;for(const e of n)r=r[e];return r[o]}function m(e,t){const{keypaths:n,key:o,typeofRoot:r}=g(e),c=d(r);let s=c;for(const e of n)Number(e)?s[e]=[]:s[e]={},s=s[e];return s[o]=t,c}const k=["string","function"];function P(e,t){const n=b(t),o=b(e);if(!k.includes(n)||!r.includes(o))return e;let c=d(e);for(const[o,s]of Object.entries(e)){const e=r.includes(b(s))?P(s,t):s;n===k[0]?c[o]=m(t,e):n===k[1]&&(c[o]=t(e))}return c}function w(e,t){const n=b(t),o=b(e);if(!["string","function"].includes(n)||!["array","object"].includes(o))return e;let r=d(e);for(const[o,c]of Object.entries(e))"string"===n?r[o]=h(t,c):"function"===n&&(r[o]=t(c)),r[o]&&"object"==typeof r[o]&&(r[o]=w(r[o],t));return r}var N=e=>{let t;const n=b(e);if("array"===n)t=!0;else if("object"===n&&Number.isInteger(e.length)&&e.length>=0){e:for(const n of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==n&&(t=!isNaN(n),!t))break e}else t=!1;return t};const D={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default]};function x(e,t){const n=[],o=Object.assign({},D,t);if(o.depth++,o.depth>o.maxDepth)return n;for(const t of o.accessors){const r=t.bind(e)(e);if(r)for(const[e,t]of Object.entries(r))if(o.values?o.values&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&t!==r){const r=x(t,o);if(o.values){if(o.values)for(const[t,o]of r){const r=[e,t].join(".");n.push([r,o])}}else for(const t of r){const o=[e,t].join(".");n.push(o)}}}return n}function E(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,o]of Object.entries(n)){const n=b(e[t]),r=b(o);e[t]="object"===n&&"object"===r?E(e[t],o):o}return e}function C(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,o]of Object.entries(n)){const n=b(e[t]),r=b(o);e[t]="object"===n&&"object"===r?C(e[t],o):"array"===n&&"array"===r?e[t].concat(o):o}return e}var R={type:!1};function T(e,t,n){const o=Object.assign({},R,n),r=Object.getOwnPropertyDescriptor(e,t);return o.type&&(r.type=b(r.value)),["array","object"].includes(b(r.value))&&(r.value=_(r.value)),r}function _(e,t){const n=Object.assign({},R,t),o={};for(const t of Object.keys(Object.getOwnPropertyDescriptors(e)))o[t]=T(e,t,n);return o}var q={typeCoercion:!1};function B(t,n,o,r){const c=Object.assign({},q,r),s=b(o.value);if(["array","object"].includes(s)){const e=N(Object.defineProperties(d(s),o.value))?[]:{};o.value=K(e,o.value)}else c.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(o,"type")&&!["undefined","null"].includes(s)&&(o.value=e[o.type](value));return Object.defineProperty(t,n,o),t}function K(e,t,n){Object.assign({},q,n);for(const[n,o]of Object.entries(t))B(e,n,o);return e}function S(e){for(const[t,n]of Object.entries(e))n&&"object"==typeof n&&S(n);return Object.freeze(e)}export{P as expandTree,w as impandTree,N as isArrayLike,x as propertyDirectory,E as recursiveAssign,C as recursiveAssignConcat,K as recursiveDefineProperties,B as recursiveDefineProperty,S as recursiveFreeze,T as recursiveGetOwnPropertyDescriptor,_ as recursiveGetOwnPropertyDescriptors,l as regularExpressions,b as typeOf,d as typedObjectLiteral,a as variables};
//# sourceMappingURL=recourse.min.js.map
