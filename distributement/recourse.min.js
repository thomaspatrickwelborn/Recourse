const e={string:String,number:Number,boolean:Boolean,undefined:void 0,null:null},t=Object.keys(e),o=Object.values(e),n={object:Object,array:Array},r=Object.keys(n),c=Object.values(n),s=Object.assign({},e,n),i=Object.keys(s),u=Object.values(s),f=[e.String,e.Number,e.Boolean,n.Object,n.Array];var a=Object.freeze({__proto__:null,ObjectKeys:r,ObjectValues:c,Objects:n,PrimitiveKeys:t,PrimitiveValues:o,Primitives:e,TypeKeys:i,TypeMethods:f,TypeValues:u,Types:s}),b={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/},l=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function j(e){return e.split(new RegExp(b.quotationEscape))}function p(e){const t=j(e);return t.pop(),t}function y(e){return j(e).pop()}function O(e){return j(e).shift()}function v(e){return Number(O(e))?"array":"object"}function d(e){return{subpaths:j(e),keypaths:p(e),key:y(e),root:O(e),typeofRoot:v(e)}}function g(e){let t;const o=l(e);if("string"===o){const o=e.toLowerCase();"object"===o?t={}:"array"===o&&(t=[])}else"object"===o?t={}:"array"===o&&(t=[]);return t}function h(e,t){const o=e.split(new RegExp(b.quotationEscape)),n=o.pop();let r=t;for(const e of o)r=r[e];return r[n]}function m(e,t){const{keypaths:o,key:n,typeofRoot:r}=d(e),c=g(r);let s=c;for(const e of o)Number(e)?s[e]=[]:s[e]={},s=s[e];return s[n]=t,c}const k=["string","function"];function P(e,t){const o=l(t),n=l(e);if(!k.includes(o)||!r.includes(n))return e;let c=g(e);for(const[n,s]of Object.entries(e)){const e=r.includes(l(s))?P(s,t):s;o===k[0]?c[n]=m(t,e):o===k[1]&&(c[n]=t(e))}return c}function w(e,t){const o=l(t),n=l(e);if(!["string","function"].includes(o)||!["array","object"].includes(n))return e;let r=g(e);for(const[n,c]of Object.entries(e))"string"===o?r[n]=h(t,c):"function"===o&&(r[n]=t(c)),r[n]&&"object"==typeof r[n]&&(r[n]=w(r[n],t));return r}var N=e=>{let t;const o=l(e);if("array"===o)t=!0;else if("object"===o&&Number.isInteger(e.length)&&e.length>=0){e:for(const o of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==o&&(t=!isNaN(o),!t))break e}else t=!1;return t};const x={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default]};function D(e,t){const o=[],n=Object.assign({},x,t);if(n.depth++,n.depth>n.maxDepth)return o;for(const t of n.accessors){const r=t.bind(e)(e);if(r)for(const[e,t]of Object.entries(r))if(n.values?n.values&&o.push([e,t]):o.push(e),"object"==typeof t&&null!==t&&t!==r){const r=D(t,n);if(n.values){if(n.values)for(const[t,n]of r){const r=[e,t].join(".");o.push([r,n])}}else for(const t of r){const n=[e,t].join(".");o.push(n)}}}return o}function E(e,...t){if(!e)return e;for(const o of t)if(o)for(const[t,n]of Object.entries(o)){const o=l(e[t]),r=l(n);e[t]="object"===o&&"object"===r?E(e[t],n):n}return e}function R(e,...t){if(!e)return e;for(const o of t)if(o)for(const[t,n]of Object.entries(o)){const o=l(e[t]),r=l(n);e[t]="object"===o&&"object"===r?R(e[t],n):"array"===o&&"array"===r?e[t].concat(n):n}return e}function T(e,t){const o=Object.getOwnPropertyDescriptor(e,t);return["array","object"].includes(l(o.value))&&(o.value=_(o.value)),o}function _(e){const t={};for(const o of Object.keys(Object.getOwnPropertyDescriptors(e)))t[o]=T(e,o);return t}function q(e,t,o){const n=l(o.value);if(["array","object"].includes(n)){const e=N(Object.defineProperties(g(n),o.value))?[]:{};o.value=K(e,o.value)}return Object.defineProperty(e,t,o),e}function K(e,t){for(const[o,n]of Object.entries(t))q(e,o,n);return e}function S(e){for(const[t,o]of Object.entries(e))o&&"object"==typeof o&&S(o);return Object.freeze(e)}export{P as expandTree,w as impandTree,N as isArrayLike,D as propertyDirectory,E as recursiveAssign,R as recursiveAssignConcat,K as recursiveDefineProperties,q as recursiveDefineProperty,S as recursiveFreeze,T as recursiveGetOwnPropertyDescriptor,_ as recursiveGetOwnPropertyDescriptors,b as regularExpressions,l as typeOf,g as typedObjectLiteral,a as variables};
//# sourceMappingURL=recourse.min.js.map
