const e={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},t=Object.keys(e),n=Object.values(e),o={object:Object,array:Array},r=Object.keys(o),s=Object.values(o),c=Object.assign({},e,o),i=Object.keys(c),a=Object.values(c),u=[e.String,e.Number,e.Boolean,o.Object,o.Array];var f=Object.freeze({__proto__:null,ObjectKeys:r,ObjectValues:s,Objects:o,PrimitiveKeys:t,PrimitiveValues:n,Primitives:e,TypeKeys:i,TypeMethods:u,TypeValues:a,Types:c}),l=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function p(e){let t;const n=l(e);if("string"===n){const n=e.toLowerCase();"object"===n?t={}:"array"===n&&(t=[])}else"object"===n?t={}:"array"===n&&(t=[]);return t}var b={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};function j(e,t){const n=e.split(new RegExp(b.quotationEscape)),o=n.pop();let r=t;for(const e of n)r=r[e];return r[o]}function O(e,t){const n=e.split(new RegExp(b.quotationEscape)),o=n.pop(),r=o&&!isNaN(o)?[]:{};let s=r,c=0;for(;c<n.length-2;){const e=keypaths[c];isNaN(e),s[e]={},s=s[e],c++}return s[o]=t,r}const y=["string","function"];function d(e,t){const n=l(t),o=l(e);if(!y.includes(n)||!r.includes(o))return e;let s=p(e);for(const[o,c]of Object.entries(e)){const e=r.includes(l(c))?d(c,t):c;n===y[0]?s[o]=O(t,e):n===y[1]&&(s[o]=t(e))}return s}function v(e,t){const n=l(t),o=l(e);if(!["string","function"].includes(n)||!["array","object"].includes(o))return e;let r=p(e);for(const[o,s]of Object.entries(e))"string"===n?r[o]=j(t,s):"function"===n&&(r[o]=t(s)),r[o]&&"object"==typeof r[o]&&(r[o]=v(r[o],t));return r}var g=e=>{let t;const n=l(e);if("array"===n)t=!0;else if("object"===n&&Number.isInteger(e.length)&&e.length>=0){e:for(const n of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==n&&(t=!isNaN(n),!t))break e}else t=!1;return t};const h={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default]};function m(e,t){const n=[],o=Object.assign({},h,t);if(o.depth++,o.depth>o.maxDepth)return n;for(const t of o.accessors){const r=t.bind(e)(e);if(r)for(const[e,t]of Object.entries(r))if(o.values?o.values&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&t!==r){const r=m(t,o);if(o.values){if(o.values)for(const[t,o]of r){const r=[e,t].join(".");n.push([r,o])}}else for(const t of r){const o=[e,t].join(".");n.push(o)}}}return n}function N(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,o]of Object.entries(n)){const n=l(e[t]),r=l(o);e[t]="object"===n&&"object"===r?N(e[t],o):o}return e}function P(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,o]of Object.entries(n)){const n=l(e[t]),r=l(o);e[t]="object"===n&&"object"===r?P(e[t],o):"array"===n&&"array"===r?e[t].concat(o):o}return e}var w={depth:0,path:null,ancestors:[]},D={delimiter:".",maxDepth:10,path:!1,retrocursion:!1,type:!1};function x(e,t,n){const o=Object.assign({},w,D,n);o.ancestors.includes(e)||o.ancestors.unshift(e);const r=Object.getOwnPropertyDescriptor(e,t);if(o.retrocursion||!o.ancestors.includes(r.value))return o.path&&(o.path=o.path?[o.path,t].join(o.delimiter):t,r.path=o.path),o.type&&(r.type=l(r.value)),["array","object"].includes(l(r.value))&&(r.value=k(r.value,o)),r}function k(e,t){const n={},o=Object.assign({},w,D,t);if(o.depth>o.maxDepth)return n;o.depth++;for(const[t,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=x(e,t,o);void 0!==r&&(n[t]=r)}return n}var E={typeCoercion:!1};function C(t,n,o,r){const s=Object.assign({},o),c=Object.assign({},E,r),i=l(s.value);if(["array","object"].includes(i)){const e=g(Object.defineProperties(p(i),s.value))?[]:{};s.value=T(e,s.value,c)}else c.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(s,"type")&&!["undefined","null"].includes(i)&&(s.value=e[s.type](s.value));return Object.defineProperty(t,n,s),t}function T(e,t,n){const o=Object.assign({},E,n);for(const[n,r]of Object.entries(t))C(e,n,r,o);return e}function _(e){for(const[t,n]of Object.entries(e))Object.is(n,e)||n&&"object"==typeof n&&_(n);return Object.freeze(e)}export{d as expandTree,v as impandTree,g as isArrayLike,m as propertyDirectory,N as recursiveAssign,P as recursiveAssignConcat,T as recursiveDefineProperties,C as recursiveDefineProperty,_ as recursiveFreeze,x as recursiveGetOwnPropertyDescriptor,k as recursiveGetOwnPropertyDescriptors,b as regularExpressions,l as typeOf,p as typedObjectLiteral,f as variables};
//# sourceMappingURL=recourse.min.js.map
