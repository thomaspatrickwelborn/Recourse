var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};function t(){const[t,n]=[...arguments];if(void 0===n)return arguments[0];const s=n.split(new RegExp(e.quotationEscape));let r=t;for(const e of s)try{r=r[e]}catch(e){r=void 0}return r}var n=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function s(e){let t;const s=n(e);if("string"===s){const n=e.toLowerCase();"object"===n?t={}:"array"===n&&(t=[])}else"object"===s?t={}:"array"===s&&(t=[]);return t}function r(){const t=arguments[0],s="string"===n(arguments[1])?{[arguments[1]]:arguments[2]}:arguments[1];for(const[n,r]of Object.entries(s)){const s=n.split(new RegExp(e.quotationEscape)),o=s.pop();let c=t;for(const e of s)c[e]=c[e]||(isNaN(e)?{}:[]),c=c[e];c[o]=r}return t}function o(t,n){const s=n.split(new RegExp(e.quotationEscape)),r=s.pop();let o=t;for(const e of s)o=o[e];delete o[r]}const c={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},i=Object.keys(c),a=Object.values(c),u={object:Object,array:Array},l=Object.keys(u),f=Object.values(u),p=Object.assign({},c,u),b=Object.keys(p),d=Object.values(p),j=[c.String,c.Number,c.Boolean,u.Object,u.Array];var O=Object.freeze({__proto__:null,ObjectKeys:l,ObjectValues:f,Objects:u,PrimitiveKeys:i,PrimitiveValues:a,Primitives:c,TypeKeys:b,TypeMethods:j,TypeValues:d,Types:p});const y={enumerable:!0,nonenumerable:!0};function g(e,t){const n=[],s=Object.assign({},y,t),{enumerable:r,nonenumerable:o}=s;if(!r&&!o)return[];const c=Object.getOwnPropertyDescriptors(e);for(const[e,t]of Object.entries(c))(r&&t.enumerable||o&&!t.enumerable)&&n.push([e,t.value]);return n}const h={depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function m(e,t,s={}){const r=[],o=Object.assign({},h,s,{ancestors:[].concat(s.ancestors)}),{ancestors:c,maxDepth:i,nonenumerable:a,recurse:u}=o;if(o.depth>=i)return r;o.depth++,c.includes(e)||c.push(e);for(const[s,i]of g(e,{enumerable:!0,nonenumerable:a})){const e=n(i);u&&["array","object"].includes(e)&&!c.includes(i)?"entries"===t?r.push([s,m(i,t,o)]):"values"===t?r.push(m(i,t,o)):"keys"===t&&r.push(s,m(i,t,o)):"entries"===t?r.push([s,i]):"values"===t?r.push(i):"keys"===t&&r.push(s)}return r}function v(e,t){return m(e,"entries",t)}const P={ancestors:[],nonenumerable:!1},D=["string","function"];function w(e,t,o={}){const c=Object.assign({},P,o,{ancestors:[].concat(o.ancestors)}),{ancestors:i}=c,a=n(t),u=n(e);if(!D.includes(a)||!l.includes(u))return e;i.includes(e)||i.unshift(e);let f=s(e);for(const[s,o]of v(e,Object.assign({},c,{recurse:!1}))){const c=l.includes(n(o))?w(o,t):o;a!==D[0]||null===o||Object.is(o,e)||i.includes(o)?a===D[1]&&(f[s]=t(c)):f[s]=r({},t,c)}return f}const k={};function x(e,r,o){const c=Object.assign({},k,o),i=n(r);let a=s(e);for(const[n,s]of v(e,Object.assign({},c,{recurse:!1})))"string"===i?a[n]=t(s,r):"function"===i&&(a[n]=r(s)),a[n]&&"object"==typeof a[n]&&(a[n]=x(a[n],r));return a}var z={default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)},E={accessors:[z.default],ancestors:[],depth:0,maxDepth:10,nonenumerable:!1,values:!1};function C(e,t){const n=[],s=Object.assign({},E,t,{ancestors:[].concat(t.ancestors)}),{accessors:r,ancestors:o,nonenumerable:c,values:i}=s;if(s.depth++,s.depth>s.maxDepth)return n;e:for(const t of r){const r=t(e);if(!r)continue e;o.includes(r)||o.unshift(r);const a=v(r,{nonenumerable:c,recurse:!1});for(const[e,t]of a)if(i?i&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,r)&&!o.includes(t)){const r=C(t,s);if(i){if(i)for(const[t,s]of r){const r=[e,t].join(".");n.push([r,s])}}else for(const t of r){const s=[e,t].join(".");n.push(s)}}}return n}function N(e,t){const s="object"===n(e)?Object.entries(e):e;if(!s)return;const o=isNaN(s[0][0])?{}:[];for(const[e,t]of s)r(o,e,t);return o}function A(e,t,...s){if(!e)return e;const r=n(e);for(const o of s)if(o)for(const[s,c]of Object.entries(o)){const o=e[s],i=n(o);n(c);"array"===r&&"assignConcat"===t?e.push(c):["array","object"].includes(i)?A(o,t,c):Object.assign(e,{[s]:c})}return e}function L(e,...t){return A(e,"assign",...t)}function T(e,...t){return A(e,"assignConcat",...t)}const q={strict:!0};var S=(e,t)=>{const s=Object.assign({},q,t);let r;const o=n(e);if("array"===o)r=!0;else if("object"===o&&e.length>=0&&Number.isInteger(e.length))if(!1===s.strict)r=!0;else{e:for(const t of m(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r},_={typeCoercion:!1};function B(e,t,r,o){const i=Object.assign({},r);let a=i.value;const u=Object.assign({},_,o),l=n(i.value),f=e[t],p=n(f),b=["array","object"];if(b.includes(l))if(b.includes(p))i.value=K(f,a,u);else{const e=s(S(Object.defineProperties({},a))?"array":"object");i.value=K(e,a,u)}else u.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(i,"type")&&!["undefined","null"].includes(l)&&(i.value=c[i.type](a));return Object.defineProperty(e,t,i),r.sealed&&Object.seal(e[t]),r.frozen&&Object.freeze(e[t]),e}function K(e,t,n){for(const[s,r]of Object.entries(t))B(e,s,r,n);return e}const R={ancestors:[]};function V(e,t){const{ancestors:s}=Object.assign({},R,t,{ancestors:Object.assign([],t.ancestors)});options.ancestors.includes(e)||options.ancestors.unshift(e);for(const[t,s]of Object.entries(e)){const e=n(s);options.ancestors.includes(s)||["array","object"].includes(e)&&V(s,options)}return Object.freeze(e)}const I={ancestors:[]};function F(e,t){const{ancestors:s}=Object.assign({},I,t,{ancestors:Object.assign([],t.ancestors)});options.ancestors.includes(e)||options.ancestors.unshift(e);for(const[t,s]of Object.entries(e)){const e=n(s);options.ancestors.includes(s)||["array","object"].includes(e)&&F(s,options)}return Object.seal(e)}function M(e,t){return m(e,"keys",t)}function $(e,t){return m(e,"values",t)}var G={accessors:[z.default],ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function H(e,t,s={}){const r=Object.assign({},G,s,{ancestors:Object.assign([],s.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++;const o=Object.getOwnPropertyDescriptor(e,t);return!r.nonenumerable&&!o.enumerable||(r.ancestors.includes(e)||r.ancestors.unshift(e),r.ancestors.includes(o.value))?void 0:(r.path&&(r.path="string"===n(r.path)?[r.path,t].join(r.delimiter):t,o.path=r.path),r.type&&(o.type=n(o.value)),r.frozen&&(o.frozen=Object.isFrozen(o.value)),r.sealed&&(o.sealed=Object.isSealed(o.value)),["array","object"].includes(n(o.value))&&(o.value=J(o.value,r)),o)}function J(e,t){const n={};for(const[s,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=H(e,s,t);r&&(n[s]=r)}return n}class Q extends EventTarget{static compand=C;static decompand=N;static expand=w;static impand=x;static keys=M;static values=$;static entries=v;static entities=m;static numerableEntries=g;static get=t;static set=r;static delete=o;static assign=L;static assignConcat=T;static defineProperties=K;static defineProperty=B;static freeze=V;static seal=F;static getOwnPropertyDescriptors=J;static getOwnPropertyDescriptor=H;static isArrayLike=S;static typeOf=n;constructor(e){super();for(const[t,n]of Object.entries({compand:Q.compand,decompand:Q.decompand,expand:Q.expand,impand:Q.impand,keys:Q.keys,values:Q.values,entries:Q.entries,entities:Q.entities,numerableEntries:Q.numerableEntries,get:Q.get,set:Q.set,delete:Q.delete,assign:Q.assign,assignConcat:Q.assignConcat,defineProperties:Q.defineProperties,defineProperty:Q.defineProperty,freeze:Q.freeze,seal:Q.seal,getOwnPropertyDescriptors:Q.getOwnPropertyDescriptors,getOwnPropertyDescriptor:Q.getOwnPropertyDescriptor,isArrayLike:Q.isArrayLike,typeOf:Q.typeOf}))Object.defineProperty(this,t,{value:n.bind(this,e)})}}export{Q as Recourse,L as assign,T as assignConcat,C as compand,N as decompand,K as defineProperties,B as defineProperty,o as deleteProperty,m as entities,v as entries,w as expand,V as freeze,H as getOwnPropertyDescriptor,J as getOwnPropertyDescriptors,t as getProperty,x as impand,S as isArrayLike,M as keys,g as numerableEntries,e as regularExpressions,F as seal,r as setProperty,n as typeOf,s as typedObjectLiteral,$ as values,O as variables};
//# sourceMappingURL=recourse.min.js.map
