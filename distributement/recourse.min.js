var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/,quotationStartStop:/^"(.*)"$/},t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const{quotationEscape:s,quotationStartStop:n}=e;function r(s){const n=t(s);if("string"===n){const t=s.split(new RegExp(e.quotationEscape));let n=0;for(;n<t.length;)t[n]=t[n].replace(new RegExp(e.quotationStartStop),"$1"),n++;return t}if("number"===n)return[s]}const c={returnValue:"target"};const i={Object:function(...e){const s=e[0];if(["object","array"].includes(t(s))){if("string"===t(e[1])){return s[e[1]]}return s}},Map:function(...e){if("map"===t(e[0])){if("string"===t(e[1])){let[t,s,n]=e;const r=Object.assign({},c,n);let{returnValue:i}=r;return"target"===i?t.get(s):"receiver"===i?t[s]:"entries"===i?[s,t.get(s)]:void 0}{let[t,s]=e;const n=Object.assign({},c,s);let{returnValue:r}=n;return"target"===r?Object.fromEntries(t):"receiver"===r?t:"entries"===r?Array.from(t.entries()):void 0}}}},o={Object:function(...e){if(["object","array"].includes(t(e[0]))){if("string"===t(e[1])){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,s]of Object.entries(source))t[e]=s;return t}}},Map:function(...e){if("map"===t(e[0])){if("string"===t(e[1])){let[t,s,n,r]=e;const i=Object.assign({},c,r);let{returnValue:o}=i;return t.set(s,n,i),t.get(s,i)}{let[t,s,n]=e;const r=Object.assign({},c,n);let{returnValue:i}=r;t.clear();for(const[e,s]of Object.entries(source))t.set(e,s,r);return t}}}},a={Object:function(...e){const[s,n]=e;if(["object","array"].includes(t(s))){if("string"===t(n))return delete s[n];for(const e of Object.keys(s))delete s[e]}else;},Map:function(...e){const s=e.length;if("map"===t(e[0])){if(2===s){let[t,s]=e;return t.delete(s)}if(1===s){let[t]=e;return t.clear()}}}};class u extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}var f=Object.freeze({__proto__:null,Deleters:a,Getters:i,Setters:o,Tensors:u});const l={getters:[i.Object,i.Map]};function p(){const[e,t,s]=[...arguments];if(void 0===t)return arguments[0];const n=Object.assign({},l,s),c=new u(n.getters),i=r(t);let o=e;e:for(const e of i)try{if(o=c.cess(o,e,n),void 0===o)break e}catch(e){break e}return o}function b(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();s="object"===t?{}:"array"===t?[]:{}}else s="object"===n?{}:"array"===n?[]:{};return s}const g={getters:[i.Object,i.Map],setters:[o.Object,o.Map]};function d(){const e=[...arguments];if("string"===t(e[1])){const[t,s,n,c]=e,i=Object.assign({},g,c),o=new u(i.getters),a=new u(i.setters),{enumerable:f,nonenumerable:l}=i,p=(o.cess(t,i),r(s)),b=p.pop();let d=t;e:for(const e of p)if(d=o.cess(d,e,i)||a.cess(d,e,isNaN(e)?{}:[],i),void 0===d)break e;return a.cess(d,b,n,i),t}{const[t,s]=e;return t}}const j={deleters:[a.Object,a.Map],returnValue:"target"};function O(e,t,s){const n=Object.assign({},j,s),c=new u(n.deleters),i=r(t),o=i.pop(),a=p(e,i.join("."),n)||e;c.cess(a,o,n)}const h={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},y=Object.keys(h),m=Object.values(h),v={object:Object,array:Array,map:Map},k=Object.keys(v),w=Object.values(v),D=Object.assign({},h,v),P=Object.keys(D),x=Object.values(D),M=[h.String,h.Number,h.Boolean,v.Object,v.Array];var z=Object.freeze({__proto__:null,ObjectKeys:k,ObjectValues:w,Objects:v,PrimitiveKeys:y,PrimitiveValues:m,Primitives:h,TypeKeys:P,TypeMethods:M,TypeValues:x,Types:D});const S={getters:[i.Object,i.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0,returnValue:"target"};function V(e,s,n={}){const r=[],c=Object.assign({},S,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:i,maxDepth:o,enumerable:a,nonenumerable:f,recurse:l}=c;if(c.depth>=o)return;i.includes(e)||i.push(e);const p=new u(c.getters).cess(e,c);c.depth++;for(const[e,n]of Object.entries(Object.getOwnPropertyDescriptors(p)))if(a&&n.enumerable||f&&!n.enumerable){const o=n.value,a=t(o);l&&k.includes(a)&&!i.includes(o)?"entries"===s?r.push([e,V(o,s,c)]):"values"===s?r.push(V(o,s,c)):"keys"===s&&r.push(e,V(o,s,c)):"entries"===s?r.push([e,o]):"values"===s?r.push(o):"keys"===s&&r.push(e)}return r}const E=["string","function"];function L(e,s,n={}){const r=Object.assign({},n),c=t(s),i=t(e);if(!E.includes(c)||!k.includes(i))return e;let o=b(e);for(const[n,i]of V(e,"entries",Object.assign({},r,{recurse:!1}))){const e=k.includes(t(i))?L(i,s):i;c===E[0]?o[n]=d({},s,e,r):c===E[1]&&(o[n]=s(e))}return o}const N={ancestors:[],getters:[i.Object,i.Map],depth:0,maxDepth:10};function A(e,s,n={}){const r=Object.assign({},N,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,values:i}=r;if(r.depth>r.maxDepth)return;r.depth++;const o=new u(r.getters).cess(e,r);c.includes(o)||c.unshift(o);const a=t(s);let f=b(e);for(const[t,n]of V(e,"entries",Object.assign({},r,{recurse:!1})))"string"===a?f[t]=p(n,s):"function"===a&&(f[t]=s(n)),f[t]&&"object"==typeof f[t]&&(f[t]=A(f[t],s));return f}const C={depth:0,getters:[i.Object,i.Map],maxDepth:10,values:!1};function _(e,t){const s=[],n=Object.assign({},C,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:c}=n;if(n.depth++,n.depth>n.maxDepth)return s;const i=new u(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const o=V(i,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of o)if(c?c&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!r.includes(t)){const r=_(t,n);if(c){if(c)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const T={setters:[o.Object,o.Map]};function q(e,s){const n=Object.assign({},T,s),r="object"===t(e)?V(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)d(c,e,t,n);return c}const B={getters:[i.Object,i.Map],setters:[o.Object,o.Map]};function I(e,s,...n){if(!e)return e;const r=Object.assign({},B),c=(new u(r.getters),new u(r.setters)),i=t(e);e:for(const o of n){if(!k.includes(t(o)))continue e;const n=V(o,"entries",{recurse:!1});for(const[o,a]of n){const n=e[o],u=t(n);t(a);"array"===i&&"assignConcat"===s?e.push(a):k.includes(u)?I(n,s,a):c.cess(e,o,a,r)}}return e}var K=(e,...t)=>I(e,"assign",...t),$=(e,...t)=>I(e,"assignConcat",...t);const R={strict:!0};function F(e,s){const n=Object.assign({},R,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of V(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const G={typeCoercion:!1};function J(e,s,n,r){const c=Object.assign({},n);let i=c.value;const o=Object.assign({},G,r),a=t(c.value),u=e[s],f=t(u);if(k.includes(a))if(k.includes(f))c.value=H(u,i,o);else{const e=b(F(Object.defineProperties({},i))?"array":"object");c.value=H(e,i,o)}else o.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined"].includes(a)&&(c.value=h[c.type](i));return Object.defineProperty(e,s,c),n.sealed&&Object.seal(e[s]),n.frozen&&Object.freeze(e[s]),e}function H(e,t,s){for(const[n,r]of Object.entries(t))J(e,n,r,s);return e}const Q={ancestors:[],depth:0,maxDepth:10};function U(e,s={}){const n=Object.assign({},Q,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new u(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const o=V(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of o)r.includes(s)||k.includes(t(s))&&U(s,n);return Object.freeze(e)}const W={ancestors:[],depth:0,maxDepth:10};function X(e,s={}){const n=Object.assign({},W,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new u(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const o=V(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of o)r.includes(s)||k.includes(t(s))&&X(s,n);return Object.seal(e)}const Y={strict:!0};function Z(e,s){const n=Object.assign({},Y,s);let r;const c=t(e);if("map"===c)r=!0;else if("object"===c&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of V(e,"entries",{nonenumerable:!0,recurse:!1})){if(!F(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}const ee={strict:!0,isArrayLike:!1};function te(e,s){const n=Object.assign({},ee,s);if("array"!==t(e)){if(!n.isArrayLike||!F(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var se=(e,t)=>V(e,"keys",t),ne=(e,t)=>V(e,"values",t),re=(e,t)=>V(e,"entries",t);const ce={getters:[i.Object,i.Map],delimiter:".",depth:0,frozen:!1,nonenumerable:!0,path:!1,sealed:!1,type:!1};function ie(e,s,n={}){const r=Object.assign({},ce,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++;const c=new u(r.getters).cess(e,s,r);if(c){const n=Object.getOwnPropertyDescriptor(e,s);if(!r.nonenumerable&&!n.enumerable)return;if(r.ancestors.includes(e)||r.ancestors.unshift(e),r.ancestors.includes(c))return;return r.path&&(r.path="string"===t(r.path)?[r.path,s].join(r.delimiter):s,n.path=r.path),r.type&&(n.type=t(c)),r.frozen&&(n.frozen=Object.isFrozen(c)),r.sealed&&(n.sealed=Object.isSealed(c)),k.includes(t(c))&&(n.value=oe(c,r)),n}}function oe(e,t){const s={};for(const[n,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=ie(e,n,t);r&&(s[n]=r)}return s}const ae={ancestors:[],depth:0,maxDepth:10,getters:[i.Object,i.Map],returnValue:"target"};function ue(e,s={}){const n=Object.assign({},ae,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,maxDepth:c}=n;if(n.depth>=c)return;n.depth++;const i=new u(n.getters).cess(e,n);if(void 0===i)return;r.includes(e)||r.unshift(e);const o=b(t(i)),a=V(e,"entries",Object.assign({},n,{recurse:!1}));e:for(const[e,s]of a){let c;if(k.includes(t(s))){if(r.includes(s))continue e;c=ue(s,n)}else c=s;try{o[e]=c}catch(e){console.error(e)}}return o}const fe={space:0,replacer:null,returnValue:"target"};function le(e,t){const s=Object.assign({},fe,t);return JSON.stringify(ue(e,s),s.replacer,s.space)}class pe extends EventTarget{static compand=_;static decompand=q;static expand=L;static impand=A;static keys=se;static values=ne;static entries=re;static entities=V;static get=p;static set=d;static delete=O;static assign=K;static assignConcat=$;static defineProperties=H;static defineProperty=J;static freeze=U;static seal=X;static getOwnPropertyDescriptors=oe;static getOwnPropertyDescriptor=ie;static isArrayLike=F;static isMapLike=Z;static isEntries=te;static typeOf=t;static toString=le;static valueOf=ue;constructor(e){super();for(const[t,s]of Object.entries({compand:pe.compand,decompand:pe.decompand,expand:pe.expand,impand:pe.impand,entities:pe.entities,keys:pe.keys,values:pe.values,entries:pe.entries,get:pe.get,set:pe.set,delete:pe.delete,assign:pe.assign,assignConcat:pe.assignConcat,defineProperties:pe.defineProperties,defineProperty:pe.defineProperty,freeze:pe.freeze,seal:pe.seal,getOwnPropertyDescriptors:pe.getOwnPropertyDescriptors,getOwnPropertyDescriptor:pe.getOwnPropertyDescriptor,isArrayLike:pe.isArrayLike,isEntries:pe.isEntries,isMapLike:pe.isMapLike,typeOf:pe.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{pe as Recourse,K as assign,$ as assignConcat,_ as compand,q as decompand,H as defineProperties,J as defineProperty,O as delete,V as entities,re as entries,L as expand,U as freeze,p as get,ie as getOwnPropertyDescriptor,oe as getOwnPropertyDescriptors,A as impand,F as isArrayLike,te as isEntries,se as keys,e as regularExpressions,X as seal,d as set,r as splitPath,f as tensors,le as toString,t as typeOf,b as typedObjectLiteral,ue as valueOf,ne as values,z as variables};
//# sourceMappingURL=recourse.min.js.map
