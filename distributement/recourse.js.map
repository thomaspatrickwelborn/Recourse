{"version":3,"file":"recourse.js","sources":["../development/variables/index.js","../development/type-of/index.js","../development/typed-object-literal/index.js","../development/regular-expressions/index.js","../development/tree/index.js","../development/expand-tree/index.js","../development/impand-tree/index.js","../development/is-array-like/index.js","../development/accessors/index.js","../development/property-directory/index.js","../development/recursive-assign/index.js","../development/recursive-assign-concat/index.js","../development/recursive-get-own-property-descriptors/settings.js","../development/recursive-get-own-property-descriptors/options.js","../development/recursive-get-own-property-descriptor/index.js","../development/recursive-get-own-property-descriptors/index.js","../development/recursive-define-properties/options.js","../development/recursive-define-property/index.js","../development/recursive-define-properties/index.js","../development/recursive-freeze/index.js"],"sourcesContent":["const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","export default ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase()","import typeOf from '../type-of/index.js'\nexport default function typedObjectLiteral($value) {\n  let _typedObjectLiteral\n  const typeOfValue = typeOf($value)\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase()\n    if(value === 'object') { _typedObjectLiteral = {} }\n    else if(value === 'array') { _typedObjectLiteral = [] }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {} }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = [] }\n  }\n  return _typedObjectLiteral\n}","export default {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n}","import typedObjectLiteral from '../typed-object-literal/index.js'\nimport regularExpressions from '../regular-expressions/index.js'\nfunction get($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  let subtarget = $source\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath] }\n  return subtarget[key]\n}\nfunction set($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  const target = (key && !isNaN(key)) ? [] : {}\n  let subtarget = target\n  let subpathIndex = 0\n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex]\n    if(isNaN($subpath)) { subtarget[$subpath] = {} }\n    else { subtarget[$subpath] = {} }\n    subtarget = subtarget[$subpath]\n    subpathIndex++\n  }\n  subtarget[key] = $source\n  return target\n}\nexport { get, set }","import { ObjectKeys } from '../variables/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nconst ValidPropertyTypes = ['string', 'function']\nexport default function expandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    const sourceValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expandTree($sourceValue, $property) : $sourceValue\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$sourceKey] = Tree.set($property, sourceValue)\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$sourceKey] = $property(sourceValue)\n    }\n  }\n  return target\n}","import * as Variables from '../variables/index.js'\n// import * as PropertyPath from '../property-path/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nexport default function impandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = Tree.get($property, $sourceValue) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property)\n    }\n  }\n  return target\n}","import typeOf from '../type-of/index.js'\nexport default ($source) => {\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey)\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","const defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n}\nconst getAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target.get($property) }\n}\nexport default {\n  default: defaultAccessor,\n  get: getAccessor,\n}","import Accessors from '../accessors/index.js'\nconst Options = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n}\nexport default function propertyDirectory($object, $options) {\n  const _propertyDirectory = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors)\n  })\n  options.depth++\n  if(options.depth > options.maxDepth) { return _propertyDirectory }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object)\n    const object = accessor($object)\n    if(!object) { continue iterateAccessors }\n    if(!options.ancestors.includes(object)) { options.ancestors.unshift(object) }\n    iterateObjectProperties: \n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _propertyDirectory.push($key) }\n      else if(options.values) { _propertyDirectory.push([$key, $value]) }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, object) && \n        !options.ancestors.includes($value)\n      ) {\n        const subtargets = propertyDirectory($value, options)\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.')\n            _propertyDirectory.push(path)\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.')\n            _propertyDirectory.push([path, $subtarget])\n          }\n        }\n      }\n    }\n  }\n  return _propertyDirectory\n}","import typeOf from '../type-of/index.js'\nexport default function recursiveAssign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = recursiveAssign($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nexport default function recursiveAssignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = recursiveAssignConcat($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","export default {\n  depth: 0,\n  path: null,\n  ancestors: [],\n}","export default {\n  delimiter: '.',\n  maxDepth: 10,\n  path: false,\n  retrocursion: false,\n  type: false,\n}\n","import typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport recursiveGetOwnPropertyDescriptors from '../recursive-get-own-property-descriptors/index.js'\nimport Settings from '../recursive-get-own-property-descriptors/settings.js'\nimport Options from '../recursive-get-own-property-descriptors/options.js'\nexport default function recursiveGetOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Settings, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey)\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties) }\n  if(!options.retrocursion && options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey\n    propertyDescriptor.path = options.path\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value) }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = recursiveGetOwnPropertyDescriptors(propertyDescriptor.value, options)\n  }\n  return propertyDescriptor\n}","import recursiveGetOwnPropertyDescriptor from '../recursive-get-own-property-descriptor/index.js'\nimport Settings from './settings.js'\nimport Options from './options.js'\nexport default function recursiveGetOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {}\n  const options = Object.assign({}, Settings, Options, $options)\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++ }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = recursiveGetOwnPropertyDescriptor($properties, $propertyKey, options)\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor }\n  }\n  return propertyDescriptors\n}","export default { typeCoercion: false }","import isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport recursiveDefineProperties from '../recursive-define-properties/index.js'\nimport * as Variables from '../variables/index.js'\nimport Options from '../recursive-define-properties/options.js'\nexport default function recursiveDefineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor)\n  const options = Object.assign({}, Options, $options)\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value)\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {}\n    propertyDescriptor.value = recursiveDefineProperties(propertyValue, propertyDescriptor.value, options)\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Variables.Primitives[propertyDescriptor.type](propertyDescriptor.value)\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor)\n  return $target\n}","import recursiveDefineProperty from '../recursive-define-property/index.js'\nimport Options from './options.js'\nexport default function recursiveDefineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options)\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    recursiveDefineProperty($target, $propertyKey, $propertyDescriptor, options)\n  }\n  return $target\n}","function recursiveFreeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      recursiveFreeze($propertyValue)\n    }\n  }\n  return Object.freeze($target)\n}\nexport default recursiveFreeze"],"names":["Tree.set","Tree.get","Options","Variables.Primitives"],"mappings":"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"}