{"version":3,"file":"recourse.min.js","sources":["../../../development/type-of/index.js","../../../development/assign-sources/index.js","../../../development/assign/index.js","../../../development/assign-concat/index.js","../../../development/numerable-entries/index.js","../../../development/entities/index.js","../../../development/entries/index.js","../../../development/compand-tree/index.js","../../../development/accessors/index.js","../../../development/regular-expressions/index.js","../../../development/decompand-tree/index.js","../../../development/is-array-like/index.js","../../../development/typed-object-literal/index.js","../../../development/variables/index.js","../../../development/define-properties/options.js","../../../development/define-property/index.js","../../../development/define-properties/index.js","../../../development/set-tree-node/index.js","../../../development/expand-tree/index.js","../../../development/freeze/index.js","../../../development/get-tree-node/index.js","../../../development/impand-tree/index.js","../../../development/get-own-property-descriptors/options.js","../../../development/get-own-property-descriptor/index.js","../../../development/get-own-property-descriptors/index.js","../../../development/seal/index.js","../../../development/keys/index.js","../../../development/values/index.js","../../../development/index.js"],"sourcesContent":["export default ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase()","import typeOf from '../type-of/index.js'\nexport default function assignSources($target, $type, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assignConcat($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else if(\n        $type === 'assignConcat' &&\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import assignSources from '../assign-sources/index.js'\nexport default function assign($target, ...$sources) {\n  return assignSources($target, 'assign', ...$sources)\n}","import assignSources from '../assign-sources/index.js'\nexport default function assignConcat($target, ...$sources) {\n  return assignSources($target, 'assignConcat', ...$sources)\n}","const Options = { enumerable: true, nonenumerable: true }\nexport default function numerableEntries($target, $options) {\n  const _numerableEntries = []\n  const options = Object.assign({}, Options, $options)\n  const { enumerable, nonenumerable } = options\n  if(!enumerable && !nonenumerable) return []\n  const propertyDescriptors = Object.getOwnPropertyDescriptors($target)\n  for(const [$property, $propertyDescriptor] of Object.entries(propertyDescriptors)) {\n    if(\n      enumerable && $propertyDescriptor.enumerable ||\n      nonenumerable && !$propertyDescriptor.enumerable\n    ) { _numerableEntries.push([$property, $propertyDescriptor.value]) }\n  }\n  return _numerableEntries\n}","import numerableEntries from '../numerable-entries/index.js'\nimport typeOf from '../type-of/index.js'\nconst Options = {\n  depth: 0,\n  maxDepth: 10,\n  enumerable: true,\n  nonenumerable: false,\n}\nexport default function entities($target, $type, $options) {\n  const _entities = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors)\n  })\n  const { ancestors, maxDepth, nonenumerable } = options\n  if(options.depth >= maxDepth) { return _entities }\n  options.depth++\n  if(!ancestors.includes($target)) { ancestors.push($target) }\n  iterateObjectEntries: \n  for(const [$key, $value] of numerableEntries($target, {\n    enumerable: true, nonenumerable\n  })) {\n    const typeOfValue = typeOf($value)\n    if(\n      ['array', 'object'].includes(typeOfValue) && \n      !ancestors.includes($value)\n    ) {\n      if($type === 'entries') { _entities.push([$key, entities($value, $type, options)]) }\n      else if($type === 'values') { _entities.push(entities($value, $type, options)) }\n      else if($type === 'keys') { _entities.push($key, entities($value, $type, options)) }\n    }\n    else {\n      if($type === 'entries') { _entities.push([$key, $value]) }\n      else if($type === 'values') { _entities.push($value) }\n      else if($type === 'keys') { _entities.push($key) }\n    }\n  }\n  return _entities\n}","import entities from '../entities/index.js'\nexport default function entries($target, $options) {\n  return entities($target, 'entries', $options)\n}","import Accessors from '../accessors/index.js'\nimport entries from '../entries/index.js'\nconst Options = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n  values: false,\n  nonenumerable: false,\n}\nexport default function CompandTree($target, $options) {\n  const compandTree = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors)\n  })\n  const { accessors, ancestors, nonenumerable, values } = options\n  options.depth++\n  if(options.depth > maxDepth) { return compandTree }\n  iterateAccessors: \n  for(const $accessor of accessors) {\n    const target = $accessor($target)\n    if(!target) { continue iterateAccessors }\n    if(!ancestors.includes(target)) { ancestors.unshift(target) }\n    const objectProperties = entries(target, { nonenumerable: nonenumerable })  \n    iterateObjectProperties: \n    for(const [$key, $value] of objectProperties) {\n      if(!values) { compandTree.push($key) }\n      else if(values) { compandTree.push([$key, $value]) }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, target) && \n        !ancestors.includes($value)\n      ) {\n        const subtargets = CompandTree($value, options)\n        if(!values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.')\n            compandTree.push(path)\n          }\n        }\n        else if(values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.')\n            compandTree.push([path, $subtarget])\n          }\n        }\n      }\n    }\n  }\n  return compandTree\n}","const defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n}\nconst getAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target.get($property) }\n}\nexport default {\n  default: defaultAccessor,\n  get: getAccessor,\n}","export default {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n}","import regularExpressions from '../regular-expressions/index.js'\nconst Options = {\n  values: false\n}\nexport default function decompandTree($target, $options) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  const target = (key && !isNaN(key)) ? [] : {}\n  let subtarget = target\n  let subpathIndex = 0\n  iterateSubpaths: \n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex]\n    if(isNaN($subpath)) { subtarget[$subpath] = {} }\n    else { subtarget[$subpath] = {} }\n    subtarget = subtarget[$subpath]\n    subpathIndex++\n  }\n  subtarget[key] = $target\n  return target\n}","import typeOf from '../type-of/index.js'\nexport default ($source) => {\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey)\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","import typeOf from '../type-of/index.js'\nexport default function typedObjectLiteral($value) {\n  let _typedObjectLiteral\n  const typeOfValue = typeOf($value)\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase()\n    if(value === 'object') { _typedObjectLiteral = {} }\n    else if(value === 'array') { _typedObjectLiteral = [] }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {} }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = [] }\n  }\n  return _typedObjectLiteral\n}","const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","export default {\n  typeCoercion: false,\n}","import isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport defineProperties from '../define-properties/index.js'\nimport * as Variables from '../variables/index.js'\nimport Options from '../define-properties/options.js'\nexport default function defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor)\n  const options = Object.assign({}, Options, $options)\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value)\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {}\n    propertyDescriptor.value = defineProperties(propertyValue, propertyDescriptor.value, options)\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Variables.Primitives[propertyDescriptor.type](propertyDescriptor.value)\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor)\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]) }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]) }\n  return $target\n}","import defineProperty from '../define-property/index.js'\nimport Options from './options.js'\nexport default function defineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options)\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, options)\n  }\n  return $target\n}","export default function setTreeNode($target, $path, $value) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  const target = (key && !isNaN(key)) ? [] : {}\n  let subtarget = target\n  let subpathIndex = 0\n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex]\n    if(isNaN($subpath)) { subtarget[$subpath] = {} }\n    else { subtarget[$subpath] = {} }\n    subtarget = subtarget[$subpath]\n    subpathIndex++\n  }\n  subtarget[key] = $value\n  return target\n}","import { ObjectKeys } from '../variables/index.js'\nimport setTreeNode from '../set-tree-node/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nconst Options = { nonenumerable: false }\nconst ValidPropertyTypes = ['string', 'function']\nexport default function expandTree($target, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfTarget = typeOf($target)\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfTarget)\n  ) { return $target }\n  let target = typedObjectLiteral($target)\n  iterateTargetEntries: \n  for(const [$targetKey, $targetValue] of Object.entries($target)) {\n    const targetValue = (\n      ObjectKeys.includes(typeOf($targetValue))\n    ) ? expandTree($targetValue, $property) : $targetValue\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$targetKey] = setTreeNode($property, targetValue)\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$targetKey] = $property(targetValue)\n    }\n  }\n  return target\n}","function freeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      freeze($propertyValue)\n    }\n  }\n  return Object.freeze($target)\n}\nexport default freeze","import regularExpressions from '../regular-expressions/index.js'\nexport default function getTreeNode($target, $path) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  let subtarget = $target\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath] }\n  return subtarget[key]\n}","import * as Variables from '../variables/index.js'\nimport getTreeNode from '../get-tree-node/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nexport default function impandTree($target, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfTarget = typeOf($target)\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfTarget)\n  ) { return $target }\n  let target = typedObjectLiteral($target)\n  iterateTargetEntries: \n  for(const [$targetKey, $targetValue] of Object.entries($target)) {\n    if(typeOfProperty === 'string') { target[$targetKey] = Tree.getTreeNode($property, $targetValue) }\n    else if(typeOfProperty === 'function') { target[$targetKey] = $property($targetValue) }\n    if(target[$targetKey] && typeof target[$targetKey] === 'object') {\n      target[$targetKey] = impandTree(target[$targetKey], $property)\n    }\n  }\n  return target\n}","export default {\n  ancestors: [],\n  delimiter: '.',\n  depth: 0,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n}","import typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js'\nimport Options from '../get-own-property-descriptors/options.js'\nexport default function getOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey)\n  if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties) }\n  if(options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey\n    propertyDescriptor.path = options.path\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value) }\n  if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyDescriptor.value) }\n  if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyDescriptor.value) }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = getOwnPropertyDescriptors(propertyDescriptor.value, options)\n  }\n  return propertyDescriptor\n}","import getOwnPropertyDescriptor from '../get-own-property-descriptor/index.js'\nimport Options from './options.js'\nexport default function getOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {}\n  const options = Object.assign({}, Options, $options)\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++ }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($properties, $propertyKey, options)\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor }\n  }\n  return propertyDescriptors\n}","function seal($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      seal($propertyValue)\n    }\n  }\n  return Object.seal($target)\n}\nexport default seal","import entities from '../entities/index.js'\nexport default function keys($target, $options) {\n  return entities($target, 'keys', $options)\n}","import entities from '../entities/index.js'\nexport default function values($target, $options) {\n  return entities($target, 'values', $options)\n}","import assign from './assign/index.js'\nimport assignConcat from './assign-concat/index.js'\nimport compandTree from './compand-tree/index.js'\nimport decompandTree from './decompand-tree/index.js'\nimport defineProperties from './define-properties/index.js'\nimport defineProperty from './define-property/index.js'\nimport expandTree from './expand-tree/index.js'\nimport freeze from './freeze/index.js'\nimport impandTree from './impand-tree/index.js'\nimport isArrayLike from './is-array-like/index.js'\nimport getOwnPropertyDescriptors from './get-own-property-descriptors/index.js'\nimport getOwnPropertyDescriptor from './get-own-property-descriptor/index.js'\nimport regularExpressions from './regular-expressions/index.js'\nimport seal from './seal/index.js'\nimport typedObjectLiteral from './typed-object-literal/index.js'\nimport typeOf from './type-of/index.js'\nimport * as variables from './variables/index.js'\n\nimport keys from './keys/index.js'\nimport values from './values/index.js'\nimport entities from './entities/index.js'\nimport entries from './entries/index.js'\nimport numerableEntries from './numerable-entries/index.js'\n\nimport getTreeNode from './get-tree-node/index.js'\nimport setTreeNode from './set-tree-node/index.js'\nimport deleteTreeNode from './get-tree-node/index.js'\n\nexport default class Recourse extends EventTarget {\n  static compand = compandTree\n  static decompand = decompandTree\n  static expand = expandTree\n  static impand = impandTree\n\n  static keys = keys\n  static values = values\n  static entries = entries\n  static numerableEntries = numerableEntries\n\n  static get = getTreeNode\n  static set = setTreeNode\n  static delete = deleteTreeNode\n\n  static assign = assign\n  static assignConcat = assignConcat\n\n  static defineProperties = defineProperties\n  static defineProperty = defineProperty\n\n  static freeze = freeze\n  static seal = seal\n\n  static getOwnPropertyDescriptors = getOwnPropertyDescriptors\n  static getOwnPropertyDescriptor = getOwnPropertyDescriptor\n\n  static isArrayLike = isArrayLike\n  static typeOf = typeOf\n\n  static typedObjectLiteral = typedObjectLiteral\n  static regularExpressions = regularExpressions\n  static variables = variables\n\n  constructor($target) {\n    super()\n    const typeOfTarget = typeOf($target)\n    const target = typedObjectLiteral(typeOfTarget)\n    iterateStaticMutatorMethods: \n    for(const $staticMethod of [\n      Recourse.compand, Recourse.decompand, Recourse.expand, Recourse.impand,\n      Recourse.keys, Recourse.values, Recourse.entries, Recourse.numerableEntries,\n      Recourse.get, Recourse.set, Recourse.delete,\n      Recourse.assign, Recourse.assignConcat, \n      Recourse.defineProperties, Recourse.defineProperty,\n      Recourse.freeze, Recourse.seal,\n      Recourse.getOwnPropertyDescriptors, Recourse.getOwnPropertyDescriptor,\n      Recourse.isArrayLike, Recourse.typeOf,\n    ]) {\n      Object.defineProperty(this, $staticMethod.name, {\n        value: $staticMethod.bind(this, target)\n      })\n    }\n  }\n}"],"names":["typeOf","$data","Object","prototype","toString","call","slice","toLowerCase","assignSources","$target","$type","$sources","$source","$sourcePropertyKey","$sourcePropertyValue","entries","typeOfTargetPropertyValue","typeOfSourcePropertyValue","assignConcat","concat","assign","Options","enumerable","nonenumerable","numerableEntries","$options","_numerableEntries","options","propertyDescriptors","getOwnPropertyDescriptors","$property","$propertyDescriptor","push","value","depth","maxDepth","entities","_entities","ancestors","includes","$key","$value","typeOfValue","accessors","default","undefined","get","values","CompandTree","compandTree","iterateAccessors","$accessor","target","unshift","objectProperties","is","subtargets","$subtargetKey","$subtarget","path","join","regularExpressions$1","quotationEscape","decompandTree","subpaths","$path","split","RegExp","regularExpressions","key","pop","isNaN","subtarget","subpathIndex","length","$subpath","keypaths","isArrayLike","typeOfSource","Number","isInteger","iterateSourceKeys","$sourceKey","keys","typedObjectLiteral","_typedObjectLiteral","Primitives","string","String","number","boolean","Boolean","bigint","BigInt","null","PrimitiveKeys","PrimitiveValues","Objects","object","array","Array","ObjectKeys","ObjectValues","Types","TypeKeys","TypeValues","TypeMethods","Options$2","typeCoercion","defineProperty","$propertyKey","propertyDescriptor","typeOfPropertyValue","propertyValue","defineProperties","getOwnPropertyDescriptor","Variables.Primitives","type","sealed","seal","frozen","freeze","$propertyDescriptors","setTreeNode","ValidPropertyTypes","expandTree","typeOfProperty","typeOfTarget","$targetKey","$targetValue","targetValue","$propertyValue","getTreeNode","impandTree","Tree","delimiter","$properties","isFrozen","isSealed","Recourse","EventTarget","static","deleteTreeNode","variables","constructor","super","$staticMethod","compand","decompand","expand","impand","set","delete","this","name","bind"],"mappings":"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"}