{"version":3,"file":"recourse.min.js","sources":["../../../development/split-path/index.js","../../../development/type-of/index.js","../../../development/variables/index.js","../../../development/tensors/index.js","../../../development/tensors/object/index.js","../../../development/tensors/map/index.js","../../../development/get-property/index.js","../../../development/get-own-property-descriptor/index.js","../../../development/get-own-property-descriptors/index.js","../../../development/entities/index.js","../../../development/is-array-like/index.js","../../../development/is-map-like/index.js","../../../development/typed-object-literal/index.js","../../../development/set-property/index.js","../../../development/delete-property/index.js","../../../development/expand/index.js","../../../development/impand/index.js","../../../development/compand/index.js","../../../development/decompand/index.js","../../../development/assign-sources/index.js","../../../development/assign/index.js","../../../development/assign-concat/index.js","../../../development/define-property/index.js","../../../development/define-properties/index.js","../../../development/freeze/index.js","../../../development/seal/index.js","../../../development/keys/index.js","../../../development/values/index.js","../../../development/entries/index.js","../../../development/value-of/index.js","../../../development/to-string/index.js","../../../development/index.js"],"sourcesContent":["export default function splitPath($path) {\n  const subpathDelimiters = /([a-zA-Z_][a-zA-Z0-9_]*)|(\\d+)|\\[\"([^\"]*)\"\\]|\"([^\"]*)\"|\\./g\n  const subpaths = []\n  let match\n  while((match = subpathDelimiters.exec($path)) !== null) {\n    if(match[1]) { subpaths.push(match[1]) }\n    else if(match[2]) { subpaths.push(parseInt(match[2], 10)) }\n    else if(match[3]) { subpaths.push(match[3]) }\n    else if(match[4]) { subpaths.push(match[4]) }\n  }\n  return subpaths\n}","export default ($operand) => Object\n  .prototype\n  .toString\n  .call($operand).slice(8, -1).toLowerCase()","const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n  'eventTarget': EventTarget,\n  'map': Map,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","import typeOf from '../type-of/index.js'\nimport * as ObjectTensors from './object/index.js'\nimport * as MapTensors from './map/index.js'\nconst Getters = {\n  Object: ObjectTensors.Getter, \n  Map: MapTensors.Getter, \n}\nconst Setters = {\n  Object: ObjectTensors.Setter, \n  Map: MapTensors.Setter, \n}\nconst Deleters = {\n  Object: ObjectTensors.Deleter, \n  Map: MapTensors.Deleter, \n}\nclass Tensors extends EventTarget {\n  constructor($tensors) {\n    super()\n    Object.defineProperties(this, {\n      'cess': { value: function next() {\n        iterateTensors:\n        for(const $tensor of $tensors) {\n          try { return $tensor(...arguments) }\n          catch($err) {}\n        }\n      } },\n    })\n  }\n}\nexport { Tensors, Getters, Setters, Deleters }","import typeOf from '../../type-of/index.js'\nimport { PrimitiveKeys } from '../../variables/index.js'\n// Object Getter\nfunction Getter(...$arguments) {\n  if(![\n    'object', 'array', 'eventtarget'\n  ].includes(typeOf($arguments[0]))) { throw new Error() }\n  else if($arguments.length === 1) {\n    const [$target] = $arguments\n    return $target\n  }\n  else {\n    const [$target, $property] = $arguments\n    return $target[$property]\n  }\n}\n// Object Setter\nfunction Setter(...$arguments) {\n  if(![\n    'object', 'array', 'eventtarget'\n  ].includes(typeOf($arguments[0]))) { throw new Error() }\n  else if(['string', 'number'].includes(typeOf($arguments[1]))) {\n    const [$target, $property, $value] = $arguments\n    $target[$property] = $value\n    return $target[$property]\n  }\n  else {\n    const [$target, $source] = $arguments\n    iterateTargetEntries: \n    for(const $targetKey of Object.keys($target)) {\n      delete $target[$targetKey]\n    }\n    iterateSourceEntries: \n    for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n      $target[$sourceKey] = $sourceValue\n    }\n    return $target\n  }\n}\n// Object Deleter\nfunction Deleter(...$arguments) {\n  const [$target, $property] = $arguments\n  if(![\n    'object', 'array', 'eventtarget'\n  ].includes(typeOf($target))) { throw new Error() }\n  else if(['string', 'number'].includes(typeOf($property))) {\n    return delete $target[$property]\n  }\n  else {\n    iterateTargetKeys: \n    for(const $targetKey of Object.keys($target)) {\n      delete $target[$targetKey]\n    }\n    return undefined\n  }\n}\nexport { Getter, Setter, Deleter }","import typeOf from '../../type-of/index.js'\nimport { PrimitiveKeys } from '../../variables/index.js'\n// Map Getter\nfunction Getter(...$arguments) {\n  if(typeOf($arguments[0]) !== 'map') { throw new Error() }\n  else if($arguments.length === 1) {\n    let [$receiver] = $arguments\n    // return Object.fromEntries($receiver)\n    return $receiver\n  }\n  else {\n    let [$receiver, $property] = $arguments\n    return $receiver.get($property)\n  }\n}\n// Map Setter\nfunction Setter(...$arguments) {\n  if(typeOf($arguments[0]) !== 'map') { throw new Error() }\n  else if($arguments.length === 2) {\n    let [$receiver, $source] = $arguments\n    $receiver.clear()\n    iterateSourceEntries: \n    for(const [$sourceKey, $sourceValue] of Object.entries(source)) {\n      $receiver.set($sourceKey, $sourceValue)\n    }\n    return $receiver\n  }\n  else {\n    let [$receiver, $property, $value] = $arguments\n    $receiver.set($property, $value)\n    return $receiver.get($property)\n  }\n}\n// Map Deleter\nfunction Deleter(...$arguments) {\n  if(typeOf($arguments[0]) !== 'map') { throw new Error() }\n  else if($arguments`.length` === 2) {\n    let [$receiver, $property] = $arguments\n    return $receiver.delete($property)\n  }\n  else {\n    let [$receiver] = $arguments\n    return $receiver.clear()\n  } \n}\nexport { Getter, Setter, Deleter }\n","import splitPath from '../split-path/index.js'\nimport { Tensors, Getters } from '../tensors/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map],\n}\nexport default function getProperty() {\n  const [$target, $path, $options] = [...arguments]\n  if($path === undefined) return arguments[0]\n  const options = Object.assign ({}, Options, $options)\n  const getters = new Tensors(options.getters)\n  const subpaths = splitPath($path)\n  let subtarget = $target\n  iterateSubpaths: \n  for(const $subpath of subpaths) {\n    try {\n      subtarget = getters.cess(subtarget, $subpath)\n      if(subtarget === undefined) { break iterateSubpaths } \n    }\n    catch($err) { break iterateSubpaths }\n  }\n  return subtarget\n}","import typeOf from '../type-of/index.js'\nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js'\nimport { Tensors, Getters } from '../tensors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map],\n  delimiter: '.',\n  depth: 0,\n  enumerable: true,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: false,\n  path: false,\n  recurse: true,\n  returnValue: 'receiver',\n  sealed: false,\n  type: false,\n}\nexport default function getOwnPropertyDescriptor($source, $propertyKey, $options = {}) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors),\n  })\n  if(options.depth >= options.maxDepth) { return }\n  else { options.depth++ }\n  if(!options.ancestors.includes($source)) { options.ancestors.unshift($source) }\n  const getters = new Tensors(options.getters)\n  const propertyValue = getters.cess($source, $propertyKey)\n  if(propertyValue !== undefined) {\n    if(ObjectKeys.includes(typeOf(propertyValue))) {\n      if(options.ancestors.includes(propertyValue)) { return }\n      else { options.ancestors.unshift(propertyValue) }\n    }\n    const typeOfSource = typeOf($source)\n    const propertyDescriptor = (typeOfSource !== 'map')\n      ? Object.getOwnPropertyDescriptor($source, $propertyKey)\n      : { configurable: false, enumerable: true, value: propertyValue[1], writable: true }\n    if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n    if(options.path) {\n      options.path = (\n        typeOf(options.path) === 'string'\n      ) ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey\n      propertyDescriptor.path = options.path\n    }\n    if(options.type) { propertyDescriptor.type = typeOf(propertyValue) }\n    if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyValue) }\n    if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyValue) }\n    if(options.recurse && ObjectKeys.includes(typeOf(propertyValue))) {\n      propertyDescriptor.value = getOwnPropertyDescriptors(propertyValue, options)\n    }\n    else {\n      propertyDescriptor.value = propertyValue\n    }\n    return propertyDescriptor\n  }\n}","import typeOf from '../type-of/index.js'\nimport getOwnPropertyDescriptor from '../get-own-property-descriptor/index.js'\nexport default function getOwnPropertyDescriptors($source, $options = {}) {\n  const options = Object.assign({}, $options)\n  const propertyDescriptors = {}\n  const typeOfSource = typeOf($source)\n  const propertyDescriptorKeys = (['array', 'object'].includes(typeOfSource))\n    ? Object.keys(Object.getOwnPropertyDescriptors($source))\n    : (typeOfSource == 'map')\n    ? Array.from($source.keys())\n    : []\n  iteratePropertyDescriptorKeys: \n  for(const $propertyKey of propertyDescriptorKeys) {\n    const propertyDescriptor = getOwnPropertyDescriptor($source, $propertyKey, options)\n    if(propertyDescriptor) {\n      propertyDescriptors[$propertyKey] = propertyDescriptor\n    }\n  }\n  return propertyDescriptors\n}","import { Tensors, Getters } from '../tensors/index.js'\nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js'\nimport typeOf from '../type-of/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nimport getOwnPropertyDescriptor from '../get-own-property-descriptor/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map],\n  ancestors: [],\n  depth: 0, maxDepth: 10,\n  enumerable: true, nonenumerable: false,\n  recurse: true,\n}\nexport default function entities($source, $type, $options = {}) {\n  const typeOfSource = typeOf($source)\n  const sourceEntities = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const { ancestors, maxDepth, enumerable, nonenumerable, recurse } = options\n  if(options.depth >= maxDepth) { return }\n  if(!ancestors.includes($source)) { ancestors.unshift($source) }\n  options.depth++\n  const getters = new Tensors(options.getters)\n  const source = getters.cess($source)\n  if(!source) { return sourceEntities }\n  const propertyDescriptorKeys = (typeOf(source) === 'map')\n    ? source.keys()\n    : Object.keys(source)\n  iterateSourcePropertyDescriptors: \n  for(const $propertyKey of propertyDescriptorKeys) {\n    const value = getters.cess($source, $propertyKey)\n    const propertyDescriptor = (typeOf($source) !== 'map')\n      ? Object.getOwnPropertyDescriptor($source, $propertyKey)\n      : { configurable: false, enumerable: true, value, writable: true }\n    if(\n      (enumerable && propertyDescriptor.enumerable) ||\n      (nonenumerable && !propertyDescriptor.enumerable)\n    ) {\n      const $value = propertyDescriptor.value\n      const typeOfValue = typeOf($value)\n      if(\n        recurse && \n        ObjectKeys.includes(typeOfValue) && \n        !ancestors.includes($value)\n      ) {\n        ancestors.unshift($value)\n        const subentities = entities($value, $type, options)\n        if(subentities.length) {\n          if($type === 'entries') { sourceEntities.push([$propertyKey, subentities]) }\n          else if($type === 'values') { sourceEntities.push(subentities) }\n          else if($type === 'keys') { sourceEntities.push($propertyKey, subentities) }\n        }\n        else {\n          if($type === 'entries') { sourceEntities.push([$propertyKey, $value]) }\n          else if($type === 'values') { sourceEntities.push($value) }\n          else if($type === 'keys') { sourceEntities.push($propertyKey) }\n        }\n      }\n      else {\n        if($type === 'entries') { sourceEntities.push([$propertyKey, $value]) }\n        else if($type === 'values') { sourceEntities.push($value) }\n        else if($type === 'keys') { sourceEntities.push($propertyKey) }\n      }\n    }\n  }\n  return sourceEntities\n}","import entities from '../entities/index.js'\nimport typeOf from '../type-of/index.js'\nconst Options = { strict: true }\nexport default function isArrayLike($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    $source.length >= 0 && \n    Number.isInteger($source.length)\n  ) {\n    if(options.strict === false) {\n      isArrayLike = true\n    }\n    else {\n      iterateSourceKeys: \n      for(const $sourceKey of entities($source, 'keys', {\n        nonenumerable: true, recurse: false\n      }).reverse()) {\n        const lastIndex = Number($sourceKey)\n        if(lastIndex === $source.length - 1) {\n          isArrayLike = true\n          break iterateSourceKeys\n        }\n      }\n      if(isArrayLike === undefined) { isArrayLike = false }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","import entities from '../entities/index.js'\nimport isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nconst Options = { strict: true }\nexport default function isMapLike($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  let isMapLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'map') { isMapLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    $source.size >= 0 && \n    Number.isInteger($source.size)\n  ) {\n    if(options.strict === false) {\n      isMapLike = true\n    }\n    else {\n      iterateSourceEntries: \n      for(const $sourceEntity of entities($source, 'entries', {\n        nonenumerable: true, recurse: false\n      })) {\n        if(\n          isArrayLike($sourceEntity, options) ||\n          $sourceEntity.length === 2\n        ) { isMapLike = true }\n        else {\n          isMapLike = false\n          break iterateSourceEntries\n        }\n      }\n      if(isMapLike === undefined) { isMapLike = false }\n    }\n  }\n  else { isMapLike = false }\n  return isMapLike\n}","import typeOf from '../type-of/index.js'\nimport isArrayLike from '../is-array-like/index.js'\nimport isMapLike from '../is-map-like/index.js'\nexport default function typedObjectLiteral($source) {\n  let _typedObjectLiteral\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'string') {\n    const source = $source.toLowerCase()\n    if(source === 'object') { return Object() }\n    else if(source === 'array') { return Array() }\n    else if(source === 'map') { return new Map() }\n    else { _typedObjectLiteral = {} }\n  }\n  else  {\n    if(typeOfSource === 'object') { return Object() }\n    else if(isArrayLike($source, { strict: true })) { return Array() }\n    else if(isMapLike($source, { strict: true })) { return new Map() }\n    else { _typedObjectLiteral = {} }\n  }\n}","import typedObjectLiteral from '../typed-object-literal/index.js'\nimport typeOf from '../type-of/index.js'\nimport splitPath from '../split-path/index.js'\nimport { Tensors, Getters, Setters } from '../tensors/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map], \n  setters: [Setters.Object, Setters.Map],\n}\nexport default function setProperty() {\n  const $arguments = [...arguments]\n  if(typeOf($arguments[1]) === 'string') {\n    const [$target, $path, $value, $options] = $arguments\n    const options = Object.assign({}, Options, $options)\n    const getters = new Tensors(options.getters)\n    const setters = new Tensors(options.setters)\n    const { enumerable, nonenumerable } = options\n    const target = getters.cess($target)\n    const subpaths = splitPath($path)\n    const key = subpaths.pop()\n    let subtarget = $target\n    iterateSubpaths: \n    for(const $subpath of subpaths) {\n      subtarget = getters.cess(subtarget, $subpath, options) || setters.cess(\n        subtarget, $subpath, isNaN($subpath) ? {} : []\n      )\n      if(subtarget === undefined) { break iterateSubpaths } \n    }\n    setters.cess(subtarget, key, $value, options)\n    return $target\n  }\n  else {\n    const [$target, $value] = $arguments\n    return $target\n  }\n}","import splitPath from '../split-path/index.js'\nimport { Tensors, Deleters } from '../tensors/index.js'\nconst Options = { deleters: [Deleters.Object, Deleters.Map], /*returnValue: 'target'*/ }\nimport getProperty from '../get-property/index.js'\nexport default function deleteProperty($target, $path, $options) {\n  const options = Object.assign ({}, Options, $options)\n  const deleters = new Tensors(options.deleters)\n  const subpaths = splitPath($path)\n  const key = subpaths.pop()\n  const subtarget = getProperty($target, subpaths.join('.'), options) || $target\n  deleters.cess(subtarget, key)\n}","import { ObjectKeys } from '../variables/index.js'\nimport setProperty from '../set-property/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport entities from '../entities/index.js'\nconst ValidPathTypes = ['string', 'function']\nexport default function expand($source, $path, $options = {}) {\n  const options = Object.assign({}, $options)\n  const typeOfPath = typeOf($path)\n  const typeOfSource = typeOf($source)\n  if(\n    !ValidPathTypes.includes(typeOfPath) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  for(const [$sourceKey, $sourceValue] of entities(\n    $source, 'entries', Object.assign({}, options, { recurse: false })\n  )) {\n    const targetValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expand($sourceValue, $path, options) : $sourceValue\n    if(typeOfPath === ValidPathTypes[0]) {\n      target[$sourceKey] = setProperty({}, $path, targetValue, options)\n    }\n    else if(typeOfPath === ValidPathTypes[1]) {\n      target[$sourceKey] = $path(targetValue)\n    }\n  }\n  return target\n}","import { Tensors, Getters } from '../tensors/index.js'\nimport getProperty from '../get-property/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport entities from '../entities/index.js'\nconst Options = {\n  ancestors: [], \n  getters: [Getters.Object, Getters.Map],\n  depth: 0, maxDepth: 10,\n}\nexport default function impand($source, $property, $options = {}) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const { ancestors, values } = options\n  if(options.depth > options.maxDepth) { return } else { options.depth++ }\n  const source = new Tensors(options.getters).cess($source)\n  if(!ancestors.includes(source)) { ancestors.unshift(source) }\n  const typeOfProperty = typeOf($property)\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of entities(\n    $source, 'entries', Object.assign({}, options, { recurse: false })\n  )) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = getProperty($sourceValue, $property) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impand(target[$sourceKey], $property)\n    }\n  }\n  return target\n}","import { Tensors, Getters } from '../tensors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nimport entities from '../entities/index.js'\nconst Options = {\n  depth: 0, \n  getters: [Getters.Object, Getters.Map],\n  maxDepth: 10,\n  values: false,\n  returnValue: 'receiver',\n}\nexport default function compand($source, $options = {}) {\n  const target = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const { ancestors, values } = options\n  options.depth++\n  if(options.depth > options.maxDepth) { return target }\n  const source = new Tensors(options.getters).cess($source)\n  if(!ancestors.includes($source)) { ancestors.unshift($source) }\n  const objectProperties = entities($source, 'entries', Object.assign({}, options, {\n    recurse: false\n  }))\n  iterateObjectProperties: \n  for(const [$key, $value] of objectProperties) {\n    if(!values) { target.push($key) }\n    else if(values) { target.push([$key, $value]) }\n    if(\n      typeof $value === 'object' &&\n      $value !== null &&\n      !Object.is($value, source) && \n      !ancestors.includes($value)\n    ) {\n      const subsources = compand($value, options)\n      if(!values) {\n        for(const $subsource of subsources) {\n          const path = [$key, $subsource].join('.')\n          target.push(path)\n        }\n      }\n      else if(values) {\n        for(const [$subsourceKey, $subsource] of subsources) {\n          const path = [$key, $subsourceKey].join('.')\n          target.push([path, $subsource])\n        }\n      }\n    }\n  }\n  return target\n}","import { Tensors, Setters } from '../tensors/index.js'\nimport typeOf from '../type-of/index.js'\nimport setProperty from '../set-property/index.js'\nimport entities from '../entities/index.js'\nconst Options = {\n  setters: [Setters.Object, Setters.Map],\n}\nexport default function decompand($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  const typeofSource= typeOf($source)\n  const sourceEntries = (\n    typeofSource === 'object'\n  ) ? entities($source, 'entries', options) : $source\n  if(!sourceEntries) { return }\n  const target = (isNaN(sourceEntries[0][0])) ? {} : []\n  iterateSourceEntries: \n  for(const [$propertyPath, $propertyValue] of sourceEntries) {\n    setProperty(target, $propertyPath, $propertyValue, options)\n  }\n  return target\n}","import typeOf from '../type-of/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nimport { Tensors, Getters, Setters } from '../tensors/index.js'\nimport * as Variables from '../variables/index.js'\nimport entities from '../entities/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map],\n  setters: [Setters.Object, Setters.Map],\n}\nexport default function assignSources($target, $type, ...$sources) {\n  if(!$target) { return $target}\n  const options = Object.assign({}, Options)\n  const getters = new Tensors(options.getters)\n  const setters = new Tensors(options.setters)\n  const typeOfTarget = typeOf($target)\n  iterateSources: \n  for(const $source of $sources) {\n    if(!Variables.ObjectKeys.includes(typeOf($source))) continue iterateSources\n    const sourceEntries = entities($source, 'entries', {\n      recurse: false, // returnValue: 'entries'\n    })\n    iterateSourceEntries: \n    for(const [$sourcePropertyKey, $sourcePropertyValue] of sourceEntries) {\n      const targetPropertyValue = getters.cess($target, $sourcePropertyKey)\n      const typeOfTargetPropertyValue = typeOf(targetPropertyValue)\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if(typeOfTarget === 'array' && $type === 'assignConcat') {\n        setters.cess($target, $target.length, $sourcePropertyValue)\n      }\n      else if(\n        Variables.ObjectKeys.includes(typeOfSourcePropertyValue) &&\n        Variables.ObjectKeys.includes(typeOfTargetPropertyValue)\n      ) {\n        assignSources(targetPropertyValue, $type, $sourcePropertyValue)\n      }\n      else {\n        setters.cess($target, $sourcePropertyKey, $sourcePropertyValue)\n      }\n    }\n  }\n}","import assignSources from '../assign-sources/index.js'\nexport default ($target, ...$sources) => assignSources($target, 'assign', ...$sources)","import assignSources from '../assign-sources/index.js'\nexport default ($target, ...$sources) => assignSources($target, 'assignConcat', ...$sources)","import isArrayLike from '../is-array-like/index.js'\nimport isMapLike from '../is-map-like/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport defineProperties from '../define-properties/index.js'\nimport * as Variables from '../variables/index.js'\nconst Options = { typeCoercion: false }\nexport default function defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor)\n  let propertyDescriptorValue = propertyDescriptor.value\n  const options = Object.assign({}, Options, $options)\n  const typeOfPropertyDescriptorValue = typeOf(propertyDescriptor.value)\n  const targetPropertyValue = $target[$propertyKey]\n  const typeOfTargetPropertyValue = typeOf(targetPropertyValue)\n  if(Variables.ObjectKeys.includes(typeOfPropertyDescriptorValue)) {\n    if(Variables.ObjectKeys.includes(typeOfTargetPropertyValue)) {\n      propertyDescriptor.value = defineProperties(targetPropertyValue, propertyDescriptorValue, options)\n    }\n    else {\n      const propertyValueTarget = typedObjectLiteral(isArrayLike(\n        Object.defineProperties({}, propertyDescriptorValue)\n      ) ? 'array' : 'object')\n      propertyDescriptor.value = defineProperties(propertyValueTarget, propertyDescriptorValue, options)\n    }\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined'/*, 'null'*/].includes(typeOfPropertyDescriptorValue)\n  ) {\n    propertyDescriptor.value = new Variables.Primitives[propertyDescriptor.type](propertyDescriptorValue)\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor)\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]) }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]) }\n  return $target\n}","import defineProperty from '../define-property/index.js'\nexport default function defineProperties($target, $propertyDescriptors, $options) {\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, $options)\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nimport entities from '../entities/index.js'\nimport { Tensors, Getters } from '../tensors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map],\n  ancestors: [], \n  depth: 0, maxDepth: 10,\n}\nexport default function freeze($target, $options = {}) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const { ancestors, values } = options\n  if(options.depth > options.maxDepth) { return } else { options.depth++ }\n  const target = new Tensors(options.getters).cess($target)\n  if(!ancestors.includes(target)) { ancestors.unshift(target) }\n  const targetEntities = entities($target, 'entries', Object.assign(options, {\n    recurse: false\n  }))\n  iterateTargetEntities: \n  for(const [$propertyKey, $propertyValue] of targetEntities) {\n    if(ancestors.includes($propertyValue)) { continue iterateTargetEntities }\n    else if(ObjectKeys.includes(typeOf($propertyValue))) {\n      freeze($propertyValue, options)\n    }\n  }\n  return Object.freeze($target)\n}","import typeOf from '../type-of/index.js'\nimport entities from '../entities/index.js'\nimport { Tensors, Getters } from '../tensors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = {\n  getters: [Getters.Object, Getters.Map],\n  ancestors: [], \n  depth: 0, maxDepth: 10,\n}\nexport default function seal($target, $options = {}) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const { ancestors, values } = options\n  if(options.depth > options.maxDepth) { return } else { options.depth++ }\n  const target = new Tensors(options.getters).cess($target)\n  if(!ancestors.includes(target)) { ancestors.unshift(target) }\n  const targetEntities = entities($target, 'entries', Object.assign(options, {\n    recurse: false\n  }))\n  iterateTargetEntities: \n  for(const [$propertyKey, $propertyValue] of targetEntities) {\n    if(ancestors.includes($propertyValue)) { continue iterateTargetEntities }\n    else if(ObjectKeys.includes(typeOf($propertyValue))) {\n      seal($propertyValue, options)\n    }\n  }\n  return Object.seal($target)\n}","import entities from '../entities/index.js'\nexport default ($target, $options) => entities($target, 'keys', $options)","import entities from '../entities/index.js'\nexport default ($target, $options) => entities($target, 'values', $options)","import entities from '../entities/index.js'\nexport default ($target, $options) => entities($target, 'entries', $options)","import defineProperties from '../define-properties/index.js' \nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js' \nimport entities from '../entities/index.js' \nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport { Tensors, Getters } from '../tensors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = {\n  ancestors: [], \n  depth: 0, maxDepth: 10,\n  getters: [Getters.Object, Getters.Map], \n  returnValue: 'receiver',\n  strict: false,\n}\nexport default function valueOf($source, $options = {}) {\n  const options = Object.assign({}, $options)\n  if(options.returnValue === 'receiver') { return $source }\n  else {\n    const target = typedObjectLiteral(typeOf($source))\n    return defineProperties(target, getOwnPropertyDescriptors($source, $options))\n  }\n} ","import valueOf from '../value-of/index.js'\nimport { Getters } from '../tensors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = { space: 0, replacer: null, returnValue: 'target', nonenumerable: true }\nexport default function toString($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  return JSON.stringify(\n    valueOf($source, options), options.replacer, options.space\n  )\n}","import getProperty from './get-property/index.js'\nimport setProperty from './set-property/index.js'\nimport deleteProperty from './delete-property/index.js'\nimport * as tensors from './tensors/index.js'\nimport expand from './expand/index.js'\nimport impand from './impand/index.js'\nimport compand from './compand/index.js'\nimport decompand from './decompand/index.js'\nimport assign from './assign/index.js'\nimport assignConcat from './assign-concat/index.js'\nimport defineProperties from './define-properties/index.js'\nimport defineProperty from './define-property/index.js'\nimport freeze from './freeze/index.js'\nimport seal from './seal/index.js'\nimport typedObjectLiteral from './typed-object-literal/index.js'\nimport typeOf from './type-of/index.js'\nimport isArrayLike from './is-array-like/index.js'\nimport isMapLike from './is-map-like/index.js'\nimport * as variables from './variables/index.js'\nimport keys from './keys/index.js'\nimport values from './values/index.js'\nimport entries from './entries/index.js'\nimport entities from './entities/index.js'\nimport getOwnPropertyDescriptors from './get-own-property-descriptors/index.js'\nimport getOwnPropertyDescriptor from './get-own-property-descriptor/index.js'\nimport splitPath from './split-path/index.js'\nimport toString from './to-string/index.js'\nimport valueOf from './value-of/index.js'\n\nclass Recourse extends EventTarget {\n  static compand = compand\n  static decompand = decompand\n  static expand = expand\n  static impand = impand\n  static keys = keys\n  static values = values\n  static entries = entries\n  static entities = entities\n  static get = getProperty\n  static set = setProperty\n  static delete = deleteProperty\n  static assign = assign\n  static assignConcat = assignConcat\n  static defineProperties = defineProperties\n  static defineProperty = defineProperty\n  static freeze = freeze\n  static seal = seal\n  static getOwnPropertyDescriptors = getOwnPropertyDescriptors\n  static getOwnPropertyDescriptor = getOwnPropertyDescriptor\n  static isArrayLike = isArrayLike\n  static isMapLike = isMapLike\n  static typeOf = typeOf\n  static toString = toString\n  static valueOf = valueOf\n\n  constructor($target) {\n    super()\n    iterateStaticMutatorMethods: \n    for(const [$staticMethodName, $staticMethod] of Object.entries({\n      compand: Recourse.compand, decompand: Recourse.decompand, \n      expand: Recourse.expand, impand: Recourse.impand,\n      entities: Recourse.entities,\n      keys: Recourse.keys, values: Recourse.values, entries: Recourse.entries, \n      get: Recourse.get, set: Recourse.set, delete: Recourse.delete,\n      assign: Recourse.assign, assignConcat: Recourse.assignConcat, \n      defineProperties: Recourse.defineProperties, defineProperty: Recourse.defineProperty,\n      freeze: Recourse.freeze, seal: Recourse.seal,\n      getOwnPropertyDescriptors: Recourse.getOwnPropertyDescriptors, getOwnPropertyDescriptor: Recourse.getOwnPropertyDescriptor,\n      isArrayLike: Recourse.isArrayLike, isMapLike: Recourse.isMapLike,\n      typeOf: Recourse.typeOf,\n    })) {\n      Object.defineProperty(this, $staticMethodName, {\n        value: $staticMethod.bind(this, $target)\n      })\n    }\n  }\n}\nexport {\n  Recourse, tensors, \n  getProperty as get, setProperty as set, deleteProperty as delete,\n  expand, impand, compand, decompand,\n  assign, assignConcat,\n  defineProperties, defineProperty,\n  freeze, seal,\n  keys, values, entries,\n  entities, \n  getOwnPropertyDescriptors, getOwnPropertyDescriptor,\n  isArrayLike, typeOf,\n  splitPath, \n  typedObjectLiteral, variables,\n  valueOf, toString,\n}"],"names":["splitPath","$path","subpathDelimiters","subpaths","match","exec","push","parseInt","typeOf","$operand","Object","prototype","toString","call","slice","toLowerCase","Primitives","string","String","number","Number","boolean","Boolean","bigint","BigInt","undefined","null","PrimitiveKeys","keys","PrimitiveValues","values","Objects","object","array","Array","eventTarget","EventTarget","map","Map","ObjectKeys","ObjectValues","Types","assign","TypeKeys","TypeValues","TypeMethods","Getters","$arguments","includes","length","$target","$property","Error","$receiver","get","Setters","$value","$source","$targetKey","$sourceKey","$sourceValue","entries","clear","source","set","Deleters","delete","Tensors","constructor","$tensors","super","defineProperties","this","cess","value","$tensor","arguments","$err","Options","getters","getProperty","$options","options","subtarget","iterateSubpaths","$subpath","delimiter","depth","enumerable","frozen","maxDepth","nonenumerable","path","recurse","returnValue","sealed","type","getOwnPropertyDescriptor","$propertyKey","ancestors","unshift","propertyValue","propertyDescriptor","configurable","writable","join","isFrozen","isSealed","getOwnPropertyDescriptors","propertyDescriptors","typeOfSource","propertyDescriptorKeys","from","entities","$type","sourceEntities","typeOfValue","subentities","strict","isArrayLike","isInteger","iterateSourceKeys","reverse","isMapLike","size","iterateSourceEntries","$sourceEntity","typedObjectLiteral","_typedObjectLiteral","setters","setProperty","key","pop","isNaN","deleters","deleteProperty","ValidPathTypes","expand","typeOfPath","target","targetValue","impand","typeOfProperty","compand","objectProperties","$key","is","subsources","$subsourceKey","$subsource","decompand","sourceEntries","$propertyPath","$propertyValue","assignSources","$sources","typeOfTarget","iterateSources","Variables.ObjectKeys","$sourcePropertyKey","$sourcePropertyValue","targetPropertyValue","typeOfTargetPropertyValue","typeOfSourcePropertyValue","assignConcat","typeCoercion","defineProperty","$propertyDescriptor","propertyDescriptorValue","typeOfPropertyDescriptorValue","propertyValueTarget","Variables.Primitives","seal","freeze","$propertyDescriptors","targetEntities","valueOf","space","replacer","JSON","stringify","Recourse","static","$staticMethodName","$staticMethod","bind"],"mappings":"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"}