{"version":3,"file":"recourse.min.js","sources":["../../../development/type-of/index.js","../../../development/assign/index.js","../../../development/assign-concat/index.js","../../../development/compand-tree/index.js","../../../development/accessors/index.js","../../../development/typed-object-literal/index.js","../../../development/regular-expressions/index.js","../../../development/tree/index.js","../../../development/decompand-tree/index.js","../../../development/is-array-like/index.js","../../../development/variables/index.js","../../../development/define-properties/options.js","../../../development/define-property/index.js","../../../development/define-properties/index.js","../../../development/expand-tree/index.js","../../../development/freeze/index.js","../../../development/impand-tree/index.js","../../../development/get-own-property-descriptors/options.js","../../../development/get-own-property-descriptor/index.js","../../../development/get-own-property-descriptors/index.js"],"sourcesContent":["export default ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase()","import typeOf from '../type-of/index.js'\nexport default function assign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assign($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nexport default function assignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assignConcat($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import Accessors from '../accessors/index.js'\nconst Options = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n  values: false,\n}\nexport default function compandTree($object, $options) {\n  const _compandTree = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors)\n  })\n  options.depth++\n  if(options.depth > options.maxDepth) { return _compandTree }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object)\n    const object = accessor($object)\n    if(!object) { continue iterateAccessors }\n    if(!options.ancestors.includes(object)) { options.ancestors.unshift(object) }\n    iterateObjectProperties: \n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _compandTree.push($key) }\n      else if(options.values) { _compandTree.push([$key, $value]) }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, object) && \n        !options.ancestors.includes($value)\n      ) {\n        const subtargets = compandTree($value, options)\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.')\n            _compandTree.push(path)\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.')\n            _compandTree.push([path, $subtarget])\n          }\n        }\n      }\n    }\n  }\n  return _compandTree\n}","const defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n}\nconst getAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target.get($property) }\n}\nexport default {\n  default: defaultAccessor,\n  get: getAccessor,\n}","import typeOf from '../type-of/index.js'\nexport default function typedObjectLiteral($value) {\n  let _typedObjectLiteral\n  const typeOfValue = typeOf($value)\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase()\n    if(value === 'object') { _typedObjectLiteral = {} }\n    else if(value === 'array') { _typedObjectLiteral = [] }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {} }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = [] }\n  }\n  return _typedObjectLiteral\n}","export default {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n}","import typedObjectLiteral from '../typed-object-literal/index.js'\nimport regularExpressions from '../regular-expressions/index.js'\nexport default class Tree extends EventTarget {\n  static expand($target, $property) {\n    const typeOfProperty = typeOf($property)\n    const typeOfTarget = typeOf($target)\n    if(\n      !ValidPropertyTypes.includes(typeOfProperty) ||\n      !ObjectKeys.includes(typeOfTarget)\n    ) { return $target }\n    let target = typedObjectLiteral($target)\n    iterateTargetEntries: \n    for(const [$targetKey, $targetValue] of Object.entries($target)) {\n      const targetValue = (\n        ObjectKeys.includes(typeOf($targetValue))\n      ) ? expandTree($targetValue, $property) : $targetValue\n      if(typeOfProperty === ValidPropertyTypes[0]) {\n        target[$targetKey] = Tree.set($property, targetValue)\n      }\n      else if(typeOfProperty === ValidPropertyTypes[1]) {\n        target[$targetKey] = $property(targetValue)\n      }\n    }\n    return target\n  }\n  static impand($target, $property) {\n    const typeOfProperty = typeOf($property)\n    const typeOfTarget = typeOf($target)\n    if(\n      !['string', 'function'].includes(typeOfProperty) ||\n      !['array', 'object'].includes(typeOfTarget)\n    ) { return $target }\n    let target = typedObjectLiteral($target)\n    iterateTargetEntries: \n    for(const [$targetKey, $targetValue] of Object.entries($target)) {\n      if(typeOfProperty === 'string') { target[$targetKey] = Tree.get($property, $targetValue) }\n      else if(typeOfProperty === 'function') { target[$targetKey] = $property($targetValue) }\n      if(target[$targetKey] && typeof target[$targetKey] === 'object') {\n        target[$targetKey] = impandTree(target[$targetKey], $property)\n      }\n    }\n    return target\n  }\n  static compand($target, $options) {\n    const _compandTree = []\n    const options = Object.assign({}, Options, $options, {\n      ancestors: [].concat($options.ancestors)\n    })\n    options.depth++\n    if(options.depth > options.maxDepth) { return _compandTree }\n    iterateAccessors: \n    for(const $accessor of options.accessors) {\n      const accessor = $accessor.bind($target)\n      const target = accessor($target)\n      if(!target) { continue iterateAccessors }\n      if(!options.ancestors.includes(target)) { options.ancestors.unshift(target) }\n      iterateObjectProperties: \n      for(const [$key, $value] of Object.entries(target)) {\n        if(!options.values) { _compandTree.push($key) }\n        else if(options.values) { _compandTree.push([$key, $value]) }\n        if(\n          typeof $value === 'target' &&\n          $value !== null &&\n          !Object.is($value, target) && \n          !options.ancestors.includes($value)\n        ) {\n          const subtargets = compandTree($value, options)\n          if(!options.values) {\n            for(const $subtarget of subtargets) {\n              const path = [$key, $subtarget].join('.')\n              _compandTree.push(path)\n            }\n          }\n          else if(options.values) {\n            for(const [$subtargetKey, $subtarget] of subtargets) {\n              const path = [$key, $subtargetKey].join('.')\n              _compandTree.push([path, $subtarget])\n            }\n          }\n        }\n      }\n    }\n    return _compandTree\n  }\n  static decompand($target, $options) {\n    let _decompandTree\n    options.values\n    const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n    const key = subpaths.pop()\n    const target = (key && !isNaN(key)) ? [] : {}\n    let subtarget = target\n    let subpathIndex = 0\n    iterateSubpaths: \n    while(subpathIndex < subpaths.length - 2) {\n      const $subpath = keypaths[subpathIndex]\n      if(isNaN($subpath)) { subtarget[$subpath] = {} }\n      else { subtarget[$subpath] = {} }\n      subtarget = subtarget[$subpath]\n      subpathIndex++\n    }\n    subtarget[key] = $target\n    // return target\n    return _decompandTree\n  }\n  static get($target, $path) {\n    let value\n    return value\n  }\n  static set($target, $path, $value) {\n    return $target\n  }\n  static delete($target, $path) {\n    return\n  }\n  static implement($target) {\n    for(const $staticMethod of [\n      Tree.get, Tree.set, Tree.delete,\n      Tree.impand, Tree.expand, \n      Tree.compand, Tree.decompand,\n      Tree.getOwnPropertyDescriptors, Tree.getOwnPropertyDescriptor,\n      Tree.defineProperties, Tree.defineProperty,\n    ]) {\n      Object.defineProperty($target, $staticMethod.name, {\n        value: $staticMethod.bind(null, $target)\n      })\n    }\n    return $target\n  }\n  constructor() {\n    super()\n    return Tree.implement(this)\n  }\n\n}","import * as Tree from '../tree/index.js'\nimport regularExpressions from '../regular-expressions/index.js'\nconst Options = {\n  values: false\n}\nexport default function decompandTree($compandTree, $options) {\n  let _decompandTree\n  options.values\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  const target = (key && !isNaN(key)) ? [] : {}\n  let subtarget = target\n  let subpathIndex = 0\n  iterateSubpaths: \n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex]\n    if(isNaN($subpath)) { subtarget[$subpath] = {} }\n    else { subtarget[$subpath] = {} }\n    subtarget = subtarget[$subpath]\n    subpathIndex++\n  }\n  subtarget[key] = $source\n  // return target\n  return _decompandTree\n}","import typeOf from '../type-of/index.js'\nexport default ($source) => {\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey)\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","export default {\n  typeCoercion: false,\n}","import isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport defineProperties from '../define-properties/index.js'\nimport * as Variables from '../variables/index.js'\nimport Options from '../define-properties/options.js'\nexport default function defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor)\n  const options = Object.assign({}, Options, $options)\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value)\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {}\n    propertyDescriptor.value = defineProperties(propertyValue, propertyDescriptor.value, options)\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Variables.Primitives[propertyDescriptor.type](propertyDescriptor.value)\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor)\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]) }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]) }\n  return $target\n}","import defineProperty from '../define-property/index.js'\nimport Options from './options.js'\nexport default function defineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options)\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, options)\n  }\n  return $target\n}","import { ObjectKeys } from '../variables/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nconst ValidPropertyTypes = ['string', 'function']\nexport default function expandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    const sourceValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expandTree($sourceValue, $property) : $sourceValue\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$sourceKey] = Tree.set($property, sourceValue)\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$sourceKey] = $property(sourceValue)\n    }\n  }\n  return target\n}","function freeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      freeze($propertyValue)\n    }\n  }\n  return Object.freeze($target)\n}\nexport default freeze","import * as Variables from '../variables/index.js'\n// import * as PropertyPath from '../property-path/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nexport default function impandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = Tree.get($property, $sourceValue) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property)\n    }\n  }\n  return target\n}","export default {\n  ancestors: [],\n  delimiter: '.',\n  depth: 0,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n}","import typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js'\nimport Options from '../get-own-property-descriptors/options.js'\nexport default function getOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey)\n  if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties) }\n  if(options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey\n    propertyDescriptor.path = options.path\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value) }\n  if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyDescriptor.value) }\n  if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyDescriptor.value) }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = getOwnPropertyDescriptors(propertyDescriptor.value, options)\n  }\n  return propertyDescriptor\n}","import getOwnPropertyDescriptor from '../get-own-property-descriptor/index.js'\nimport Options from './options.js'\nexport default function getOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {}\n  const options = Object.assign({}, Options, $options)\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++ }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($properties, $propertyKey, options)\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor }\n  }\n  return propertyDescriptors\n}"],"names":["typeOf$1","$data","Object","prototype","toString","call","slice","toLowerCase","assign","$target","$sources","$source","$sourcePropertyKey","$sourcePropertyValue","entries","typeOfTargetPropertyValue","typeOf","typeOfSourcePropertyValue","assignConcat","concat","Options","depth","maxDepth","accessors","default","$property","undefined","get","ancestors","values","compandTree","$object","$options","_compandTree","options","$accessor","object","bind","accessor","includes","unshift","$key","$value","push","is","subtargets","$subtargetKey","$subtarget","path","join","typedObjectLiteral","_typedObjectLiteral","typeOfValue","value","regularExpressions","quotationEscape","Tree","EventTarget","expand","typeOfProperty","typeOfTarget","ValidPropertyTypes","ObjectKeys","target","$targetKey","$targetValue","targetValue","expandTree","set","impand","impandTree","compand","decompand","subpaths","$path","split","RegExp","key","pop","subtarget","isNaN","subpathIndex","length","$subpath","keypaths","implement","$staticMethod","delete","getOwnPropertyDescriptors","getOwnPropertyDescriptor","defineProperties","defineProperty","name","constructor","super","this","decompandTree","$compandTree","isArrayLike","typeOfSource","Number","isInteger","iterateSourceKeys","$sourceKey","keys","Primitives","string","String","number","boolean","Boolean","bigint","BigInt","null","PrimitiveKeys","PrimitiveValues","Objects","array","Array","ObjectValues","Types","TypeKeys","TypeValues","TypeMethods","Options$2","typeCoercion","$propertyKey","$propertyDescriptor","propertyDescriptor","typeOfPropertyValue","propertyValue","Variables.Primitives","type","sealed","seal","frozen","freeze","$propertyDescriptors","$sourceValue","sourceValue","Tree.set","$propertyValue","Tree.get","Options$1","delimiter","nonenumerable","$properties","enumerable","isFrozen","isSealed","propertyDescriptors"],"mappings":"AAAA,IAAeA,EAACC,GAAUC,OACvBC,UACAC,SACAC,KAAKJ,GAAOK,MAAM,GAAI,GAAGC,cCFb,SAASC,EAAOC,KAAYC,GACzC,IAAID,EAAW,OAAOA,EAEtB,IAAI,MAAME,KAAWD,EACnB,GAAIC,EAEJ,IAAI,MACFC,EAAoBC,KACjBX,OAAOY,QAAQH,GAAU,CAC5B,MAAMI,EAA4BC,EAAOP,EAAQG,IAC3CK,EAA4BD,EAAOH,GAKvCJ,EAAQG,GAHsB,WAA9BG,GAC8B,WAA9BE,EAE8BT,EAAOC,EAAQG,GAAqBC,GAGpCA,CAEtC,CAEE,OAAOJ,CACT,CCvBe,SAASS,EAAaT,KAAYC,GAC/C,IAAID,EAAW,OAAOA,EAEtB,IAAI,MAAME,KAAWD,EACnB,GAAIC,EAEJ,IAAI,MACFC,EAAoBC,KACjBX,OAAOY,QAAQH,GAAU,CAC5B,MAAMI,EAA4BC,EAAOP,EAAQG,IAC3CK,EAA4BD,EAAOH,GAKvCJ,EAAQG,GAHsB,WAA9BG,GAC8B,WAA9BE,EAE8BC,EAAaT,EAAQG,GAAqBC,GAG1C,UAA9BE,GAC8B,UAA9BE,EAE8BR,EAAQG,GAAoBO,OAAON,GAGnCA,CAEtC,CAEE,OAAOJ,CACT,CC7BA,MAAMW,EAAU,CACdC,MAAO,EACPC,SAAU,GACVC,UAAW,CCIE,CACbC,QATsB,CAACf,EAASgB,SACfC,IAAdD,EAAkChB,EACvBA,EAAQgB,GAQtBE,IANkB,CAAClB,EAASgB,SACXC,IAAdD,EAAkChB,EACvBA,EAAQkB,IAAIF,IDFJD,SACtBI,UAAW,GACXC,QAAQ,GAEK,SAASC,EAAYC,EAASC,GAC3C,MAAMC,EAAe,GACfC,EAAUhC,OAAOM,OAAO,CAAA,EAAIY,EAASY,EAAU,CACnDJ,UAAW,GAAGT,OAAOa,EAASJ,aAGhC,GADAM,EAAQb,QACLa,EAAQb,MAAQa,EAAQZ,SAAY,OAAOW,EAE9C,IAAI,MAAME,KAAaD,EAAQX,UAAW,CACxC,MACMa,EADWD,EAAUE,KAAKN,EACjBO,CAASP,GACxB,GAAIK,EAAJ,CACIF,EAAQN,UAAUW,SAASH,IAAWF,EAAQN,UAAUY,QAAQJ,GAEpE,IAAI,MAAOK,EAAMC,KAAWxC,OAAOY,QAAQsB,GAGzC,GAFIF,EAAQL,OACJK,EAAQL,QAAUI,EAAaU,KAAK,CAACF,EAAMC,IAD7BT,EAAaU,KAAKF,GAGpB,iBAAXC,GACI,OAAXA,IACCxC,OAAO0C,GAAGF,EAAQN,KAClBF,EAAQN,UAAUW,SAASG,GAC5B,CACA,MAAMG,EAAaf,EAAYY,EAAQR,GACvC,GAAIA,EAAQL,QAMP,GAAGK,EAAQL,OACd,IAAI,MAAOiB,EAAeC,KAAeF,EAAY,CACnD,MAAMG,EAAO,CAACP,EAAMK,GAAeG,KAAK,KACxChB,EAAaU,KAAK,CAACK,EAAMD,GACrC,OATU,IAAI,MAAMA,KAAcF,EAAY,CAClC,MAAMG,EAAO,CAACP,EAAMM,GAAYE,KAAK,KACrChB,EAAaU,KAAKK,EAC9B,CAQA,CAzB2C,CA2B3C,CACE,OAAOf,CACT,CE/Ce,SAASiB,EAAmBR,GACzC,IAAIS,EACJ,MAAMC,EAAcpC,EAAO0B,GAC3B,GAAmB,WAAhBU,EAA0B,CAC3B,MAAMC,EAAQX,EAAOnC,cACR,WAAV8C,EAAsBF,EAAsB,CAAE,EAC/B,UAAVE,IAAqBF,EAAsB,GACvD,KAEuB,WAAhBC,EAA4BD,EAAsB,CAAE,EAC/B,UAAhBC,IAA2BD,EAAsB,IAE3D,OAAOA,CACT,CCdA,IAAeG,EAAA,CACbC,gBAAiB,iCCCJ,MAAMC,UAAaC,YAChC,aAAOC,CAAOjD,EAASgB,GACrB,MAAMkC,EAAiB3C,OAAOS,GACxBmC,EAAe5C,OAAOP,GAC5B,IACGoD,mBAAmBtB,SAASoB,KAC5BG,WAAWvB,SAASqB,GACnB,OAAOnD,EACX,IAAIsD,EAASb,EAAmBzC,GAEhC,IAAI,MAAOuD,EAAYC,KAAiB/D,OAAOY,QAAQL,GAAU,CAC/D,MAAMyD,EACJJ,WAAWvB,SAASvB,OAAOiD,IACzBE,WAAWF,EAAcxC,GAAawC,EACvCN,IAAmBE,mBAAmB,GACvCE,EAAOC,GAAcR,EAAKY,IAAI3C,EAAWyC,GAEnCP,IAAmBE,mBAAmB,KAC5CE,EAAOC,GAAcvC,EAAUyC,GAEvC,CACI,OAAOH,CACX,CACE,aAAOM,CAAO5D,EAASgB,GACrB,MAAMkC,EAAiB3C,OAAOS,GACxBmC,EAAe5C,OAAOP,GAC5B,IACG,CAAC,SAAU,YAAY8B,SAASoB,KAChC,CAAC,QAAS,UAAUpB,SAASqB,GAC5B,OAAOnD,EACX,IAAIsD,EAASb,EAAmBzC,GAEhC,IAAI,MAAOuD,EAAYC,KAAiB/D,OAAOY,QAAQL,GAC/B,WAAnBkD,EAA+BI,EAAOC,GAAcR,EAAK7B,IAAIF,EAAWwC,GAChD,aAAnBN,IAAiCI,EAAOC,GAAcvC,EAAUwC,IACrEF,EAAOC,IAA6C,iBAAvBD,EAAOC,KACrCD,EAAOC,GAAcM,WAAWP,EAAOC,GAAavC,IAGxD,OAAOsC,CACX,CACE,cAAOQ,CAAQ9D,EAASuB,GACtB,MAAMC,EAAe,GACfC,EAAUhC,OAAOM,OAAO,CAAA,EAAIY,QAASY,EAAU,CACnDJ,UAAW,GAAGT,OAAOa,EAASJ,aAGhC,GADAM,EAAQb,QACLa,EAAQb,MAAQa,EAAQZ,SAAY,OAAOW,EAE9C,IAAI,MAAME,KAAaD,EAAQX,UAAW,CACxC,MACMwC,EADW5B,EAAUE,KAAK5B,EACjB6B,CAAS7B,GACxB,GAAIsD,EAAJ,CACI7B,EAAQN,UAAUW,SAASwB,IAAW7B,EAAQN,UAAUY,QAAQuB,GAEpE,IAAI,MAAOtB,EAAMC,KAAWxC,OAAOY,QAAQiD,GAGzC,GAFI7B,EAAQL,OACJK,EAAQL,QAAUI,EAAaU,KAAK,CAACF,EAAMC,IAD7BT,EAAaU,KAAKF,GAGpB,iBAAXC,GACI,OAAXA,IACCxC,OAAO0C,GAAGF,EAAQqB,KAClB7B,EAAQN,UAAUW,SAASG,GAC5B,CACA,MAAMG,EAAaf,YAAYY,EAAQR,GACvC,GAAIA,EAAQL,QAMP,GAAGK,EAAQL,OACd,IAAI,MAAOiB,EAAeC,KAAeF,EAAY,CACnD,MAAMG,EAAO,CAACP,EAAMK,GAAeG,KAAK,KACxChB,EAAaU,KAAK,CAACK,EAAMD,GACvC,OATY,IAAI,MAAMA,KAAcF,EAAY,CAClC,MAAMG,EAAO,CAACP,EAAMM,GAAYE,KAAK,KACrChB,EAAaU,KAAKK,EAChC,CAQA,CAzB6C,CA2B7C,CACI,OAAOf,CACX,CACE,gBAAOuC,CAAU/D,EAASuB,GAExBE,QAAQL,OACR,MAAM4C,EAAWC,MAAMC,MAAM,IAAIC,OAAOtB,EAAmBC,kBACrDsB,EAAMJ,EAASK,MAErB,IAAIC,EADYF,IAAQG,MAAMH,GAAQ,GAAK,CAAA,EAEvCI,EAAe,EAEnB,KAAMA,EAAeR,EAASS,OAAS,GAAG,CACxC,MAAMC,EAAWC,SAASH,GACvBD,MAAMG,GAAaJ,EAAUI,GAAY,CAAE,EAE9CJ,EAAYA,EAAUI,GACtBF,GACN,CACIF,EAAUF,GAAOpE,CAGrB,CACE,UAAOkB,CAAIlB,EAASiE,GAGtB,CACE,UAAON,CAAI3D,EAASiE,EAAOhC,GACzB,OAAOjC,CACX,CACE,aAAO,CAAOA,EAASiE,GAEzB,CACE,gBAAOW,CAAU5E,GACf,IAAI,MAAM6E,IAAiB,CACzB9B,EAAK7B,IAAK6B,EAAKY,IAAKZ,EAAK+B,OACzB/B,EAAKa,OAAQb,EAAKE,OAClBF,EAAKe,QAASf,EAAKgB,UACnBhB,EAAKgC,0BAA2BhC,EAAKiC,yBACrCjC,EAAKkC,iBAAkBlC,EAAKmC,gBAE5BzF,OAAOyF,eAAelF,EAAS6E,EAAcM,KAAM,CACjDvC,MAAOiC,EAAcjD,KAAK,KAAM5B,KAGpC,OAAOA,CACX,CACE,WAAAoF,GAEE,OADAC,QACOtC,EAAK6B,UAAUU,KAC1B,EC9He,SAASC,EAAcC,EAAcjE,GAElDE,QAAQL,OACR,MAAM4C,EAAWC,MAAMC,MAAM,IAAIC,OAAOtB,EAAmBC,kBACrDsB,EAAMJ,EAASK,MAErB,IAAIC,EADYF,IAAQG,MAAMH,GAAQ,GAAK,CAAA,EAEvCI,EAAe,EAEnB,KAAMA,EAAeR,EAASS,OAAS,GAAG,CACxC,MAAMC,EAAWC,SAASH,GACvBD,MAAMG,GAAaJ,EAAUI,GAAY,CAAE,EAE9CJ,EAAYA,EAAUI,GACtBF,GACJ,CACEF,EAAUF,GAAOlE,OAGnB,CCvBA,IAAeuF,EAACvF,IACd,IAAIuF,EACJ,MAAMC,EAAenF,EAAOL,GAC5B,GAAoB,UAAjBwF,EAA4BD,GAAc,OACxC,GACc,WAAjBC,GACAC,OAAOC,UAAU1F,EAAQuE,SAAWvE,EAAQuE,QAAU,GAEtDoB,EACA,IAAI,MAAMC,KAAcrG,OAAOsG,KAC7BtG,OAAOsF,0BAA0B7E,IAEjC,GAAkB,WAAf4F,IACHL,GAAelB,MAAMuB,IACjBL,GAAe,MAAMI,OAGtBJ,GAAc,EACrB,OAAOA,GCnBT,MAAMO,EAAa,CACjBC,OAAUC,OACVC,OAAUR,OACVS,QAAWC,QACXC,OAAUC,OACVtF,eAAaA,EACbuF,KAAQ,MAEJC,EAAgBhH,OAAOsG,KAAKC,GAC5BU,EAAkBjH,OAAO2B,OAAO4E,GAChCW,EAAU,CACdhF,OAAUlC,OACVmH,MAASC,OAELxD,EAAa5D,OAAOsG,KAAKY,GACzBG,EAAerH,OAAO2B,OAAOuF,GAC7BI,EAAQtH,OAAOM,OAAO,CAAE,EAAEiG,EAAYW,GACtCK,EAAWvH,OAAOsG,KAAKgB,GACvBE,EAAaxH,OAAO2B,OAAO2F,GAC3BG,EAAc,CACnBlB,EAAWE,OAAQF,EAAWL,OAAQK,EAAWK,QACjDM,EAAQlH,OAAQkH,EAAQE,gLCrBVM,EAAA,CACbC,cAAc,GCKD,SAASlC,EAAelF,EAASqH,EAAcC,EAAqB/F,GACjF,MAAMgG,EAAqB9H,OAAOM,OAAO,CAAE,EAAEuH,GACvC7F,EAAUhC,OAAOM,OAAO,CAAE,EAAEY,EAASY,GACrCiG,EAAsBjH,EAAOgH,EAAmB3E,OACtD,GAAG,CAAC,QAAS,UAAUd,SAAS0F,GAAsB,CACpD,MAAMC,EAAgBhC,EAAYhG,OAAOwF,iBACvCxC,EAAmB+E,GAAsBD,EAAmB3E,QACzD,GAAK,CAAA,EACV2E,EAAmB3E,MAAQqC,EAAiBwC,EAAeF,EAAmB3E,MAAOnB,EACzF,MAEIA,EAAQ2F,mBACwDnG,IAAhExB,OAAOuF,yBAAyBuC,EAAoB,UACnD,CAAC,YAAa,QAAQzF,SAAS0F,KAEhCD,EAAmB3E,MAAQ8E,EAAqBH,EAAmBI,MAAMJ,EAAmB3E,QAK9F,OAHAnD,OAAOyF,eAAelF,EAASqH,EAAcE,GAC1CD,EAAoBM,QAAUnI,OAAOoI,KAAK7H,EAAQqH,IAClDC,EAAoBQ,QAAUrI,OAAOsI,OAAO/H,EAAQqH,IAChDrH,CACT,CCzBe,SAASiF,EAAiBjF,EAASgI,EAAsBzG,GACtE,MAAME,EAAUhC,OAAOM,OAAO,CAAE,EAAEY,EAASY,GAC3C,IAAI,MACF8F,EAAcC,KACX7H,OAAOY,QAAQ2H,GAClB9C,EAAelF,EAASqH,EAAcC,EAAqB7F,GAE7D,OAAOzB,CACT,CCNA,MAAMoD,EAAqB,CAAC,SAAU,YACvB,SAASM,EAAWxD,EAASc,GAC1C,MAAMkC,EAAiB3C,EAAOS,GACxB0E,EAAenF,EAAOL,GAC5B,IACGkD,EAAmBtB,SAASoB,KAC5BG,EAAWvB,SAAS4D,GACnB,OAAOxF,EACX,IAAIoD,EAASb,EAAmBvC,GAEhC,IAAI,MAAO4F,EAAYmC,KAAiBxI,OAAOY,QAAQH,GAAU,CAC/D,MAAMgI,EACJ7E,EAAWvB,SAASvB,EAAO0H,IACzBvE,EAAWuE,EAAcjH,GAAaiH,EACvC/E,IAAmBE,EAAmB,GACvCE,EAAOwC,SAAcqC,GAASnH,EAAWkH,GAEnChF,IAAmBE,EAAmB,KAC5CE,EAAOwC,GAAc9E,EAAUkH,GAErC,CACE,OAAO5E,CACT,CC1BA,SAASyE,EAAO/H,GACd,IAAI,MAAOqH,EAAce,KAAmB3I,OAAOY,QAAQL,GACtDP,OAAO0C,GAAGiG,EAAgBpI,IAC1BoI,GAA4C,iBAAnBA,GAC1BL,EAAOK,GAGX,OAAO3I,OAAOsI,OAAO/H,EACvB,CCHe,SAAS6D,EAAW3D,EAASc,GAC1C,MAAMkC,EAAiB3C,EAAOS,GACxB0E,EAAenF,EAAOL,GAC5B,IACG,CAAC,SAAU,YAAY4B,SAASoB,KAChC,CAAC,QAAS,UAAUpB,SAAS4D,GAC5B,OAAOxF,EACX,IAAIoD,EAASb,EAAmBvC,GAEhC,IAAI,MAAO4F,EAAYmC,KAAiBxI,OAAOY,QAAQH,GAC/B,WAAnBgD,EAA+BI,EAAOwC,SAAcuC,GAASrH,EAAWiH,GAChD,aAAnB/E,IAAiCI,EAAOwC,GAAc9E,EAAUiH,IACrE3E,EAAOwC,IAA6C,iBAAvBxC,EAAOwC,KACrCxC,EAAOwC,GAAcjC,EAAWP,EAAOwC,GAAa9E,IAGxD,OAAOsC,CACT,CCtBA,IAAegF,EAAA,CACbnH,UAAW,GACXoH,UAAW,IACX3H,MAAO,EACPkH,QAAQ,EACRjH,SAAU,GACV2H,eAAe,EACfjG,MAAM,EACNqF,QAAQ,EACRD,MAAM,GCLO,SAAS3C,EAAyByD,EAAapB,EAAc9F,GAC1E,MAAME,EAAUhC,OAAOM,OAAO,CAAA,EAAIY,EAASY,EAAU,CACnDJ,UAAW1B,OAAOM,OAAO,GAAIwB,EAASJ,aAElCoG,EAAqB9H,OAAOuF,yBAAyByD,EAAapB,GACxE,IAAI5F,EAAQ+G,eAAkBjB,EAAmBmB,cAC7CjH,EAAQN,UAAUW,SAAS2G,IAAgBhH,EAAQN,UAAUY,QAAQ0G,IACtEhH,EAAQN,UAAUW,SAASyF,EAAmB3E,QAWjD,OAVGnB,EAAQc,OACTd,EAAQc,KAAiC,WAAzBhC,EAAOkB,EAAQc,MAAsB,CAACd,EAAQc,KAAM8E,GAAc7E,KAAKf,EAAQ8G,WAAalB,EAC5GE,EAAmBhF,KAAOd,EAAQc,MAEjCd,EAAQkG,OAAQJ,EAAmBI,KAAOpH,EAAOgH,EAAmB3E,QACpEnB,EAAQqG,SAAUP,EAAmBO,OAASrI,OAAOkJ,SAASpB,EAAmB3E,QACjFnB,EAAQmG,SAAUL,EAAmBK,OAASnI,OAAOmJ,SAASrB,EAAmB3E,QACjF,CAAC,QAAS,UAAUd,SAASvB,EAAOgH,EAAmB3E,UACxD2E,EAAmB3E,MAAQmC,EAA0BwC,EAAmB3E,MAAOnB,IAE1E8F,CACT,CCrBe,SAASxC,EAA0B0D,EAAalH,GAC7D,MAAMsH,EAAsB,CAAA,EACtBpH,EAAUhC,OAAOM,OAAO,CAAE,EAAEY,EAASY,GAC3C,GAAGE,EAAQb,OAASa,EAAQZ,SAAY,OAAOgI,EACxCpH,EAAQb,QACf,IAAI,MAAOyG,EAAcC,KAAwB7H,OAAOY,QAAQZ,OAAOsF,0BAA0B0D,IAAe,CAC9G,MAAMlB,EAAqBvC,EAAyByD,EAAapB,EAAc5F,QACrDR,IAAvBsG,IAAoCsB,EAAoBxB,GAAgBE,EAC/E,CACE,OAAOsB,CACT"}