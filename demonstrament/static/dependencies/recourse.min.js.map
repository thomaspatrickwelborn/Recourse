{"version":3,"file":"recourse.min.js","sources":["../../../development/regular-expressions/index.js","../../../development/type-of/index.js","../../../development/cessors/index.js","../../../development/get-property/index.js","../../../development/variables/index.js","../../../development/entities/index.js","../../../development/typed-object-literal/index.js","../../../development/set-property/index.js","../../../development/delete-property/index.js","../../../development/entries/index.js","../../../development/expand/index.js","../../../development/impand/index.js","../../../development/compand/index.js","../../../development/decompand/index.js","../../../development/assign-sources/index.js","../../../development/assign/index.js","../../../development/assign-concat/index.js","../../../development/is-array-like/index.js","../../../development/define-property/index.js","../../../development/define-properties/index.js","../../../development/freeze/index.js","../../../development/seal/index.js","../../../development/is-entries/index.js","../../../development/keys/index.js","../../../development/values/index.js","../../../development/get-own-property-descriptor/index.js","../../../development/get-own-property-descriptors/index.js","../../../development/to-string/index.js","../../../development/value-of/index.js","../../../development/index.js"],"sourcesContent":["export default {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n}","export default ($operand) => Object\n  .prototype\n  .toString\n  .call($operand).slice(8, -1).toLowerCase()","import typeOf from '../type-of/index.js'\nclass Cessors extends EventTarget {\n  constructor($cessors) {\n    super()\n    const cessors = Object.assign([], $cessors)\n    Object.defineProperties(this, {\n      'cess': { value: function cess() {\n        let cessValue\n        iterateAccessors: \n        for(const $cessor of cessors) {\n          cessValue = $cessor(...arguments)\n          if(cessValue !== undefined) { break iterateAccessors }\n        }\n        return cessValue\n      } },\n    })\n  }\n}\nconst Accessors = { default: function($target, $property) {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n} }\nconst Processors = { default: function() {\n  if(typeOf(arguments[1]) === 'string') {\n    const [$target, $property, $value, $options] = [...arguments]\n    $target[$property] = $value\n    return $target[$property]\n  }\n  else {\n    let [$target, $value, $options] = [...arguments]\n    return $value\n  }\n} }\nconst Deaccessors = { default: function($target, $property) {\n  if($property === undefined) { delete $target[$property] }\n  return\n} }\nexport {\n  Cessors,\n  Accessors,\n  Processors,\n  Deaccessors,\n}","import regularExpressions from '../regular-expressions/index.js'\nimport { Cessors, Accessors } from '../cessors/index.js'\nconst Options = { accessors: [Accessors.default] }\nexport default function getProperty() {\n  const [$target, $path, $options] = [...arguments]\n  const options = Object.assign ({}, Options, $options)\n  if($path === undefined) return arguments[0]\n  const accessors = new Cessors(options.accessors)\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  let subtarget = $target\n  iterateSubpaths: \n  for(const $subpath of subpaths) {\n    try {\n      subtarget = accessors.cess(subtarget, $subpath)\n      if(subtarget === undefined) { break iterateSubpaths } \n    }\n    catch($err) { break iterateSubpaths }\n  }\n  return subtarget\n}","const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","import { Cessors, Accessors } from '../cessors/index.js'\nimport typeOf from '../type-of/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = {\n  accessors: [Accessors.default],\n  ancestors: [],\n  depth: 0, maxDepth: 10,\n  enumerable: true, nonenumerable: false,\n  recurse: true,\n}\nexport default function entities($source, $type, $options) {\n  const sourceEntities = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors || [])\n  })\n  const source = new Cessors([Accessors.default]).cess($source)\n  const { ancestors, maxDepth, enumerable, nonenumerable, recurse } = options\n  if(options.depth >= maxDepth) { return sourceEntities }\n  options.depth++\n  if(!ancestors.includes($source)) { ancestors.push($source) }\n  for(const [$key, $propertyDescriptor] of Object.entries(\n    Object.getOwnPropertyDescriptors($source)\n  )) {\n    if(\n      enumerable && $propertyDescriptor.enumerable ||\n      nonenumerable && !$propertyDescriptor.enumerable\n    ) {\n      const $value = $propertyDescriptor.value\n      const typeOfValue = typeOf($value)\n      if(\n        recurse && \n        ObjectKeys.includes(typeOfValue) && \n        !ancestors.includes($value)\n      ) {\n        if($type === 'entries') { sourceEntities.push([$key, entities($value, $type, options)]) }\n        else if($type === 'values') { sourceEntities.push(entities($value, $type, options)) }\n        else if($type === 'keys') { sourceEntities.push($key, entities($value, $type, options)) }\n      }\n      else {\n        if($type === 'entries') { sourceEntities.push([$key, $value]) }\n        else if($type === 'values') { sourceEntities.push($value) }\n        else if($type === 'keys') { sourceEntities.push($key) }\n      }\n    }\n  }\n  return sourceEntities\n}","import typeOf from '../type-of/index.js'\nexport default function typedObjectLiteral($value) {\n  let _typedObjectLiteral\n  const typeOfValue = typeOf($value)\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase()\n    if(value === 'object') { _typedObjectLiteral = {} }\n    else if(value === 'array') { _typedObjectLiteral = [] }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {} }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = [] }\n  }\n  return _typedObjectLiteral\n}","import entities from '../entities/index.js'\nimport regularExpressions from '../regular-expressions/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport typeOf from '../type-of/index.js'\nimport { Cessors, Accessors, Processors } from '../cessors/index.js'\nconst Options = {\n  enumerable: true, nonenumerable: false,\n  accessors: [Accessors.default], \n  processors: [Processors.default],\n}\nexport default function setProperty() {\n  const $arguments = [...arguments]\n  if(typeOf($arguments[1]) === 'string') {\n    const [$target, $path, $value, $options] = $arguments\n    const options = Object.assign({}, Options, $options)\n    const accessors = new Cessors(options.accessors)\n    const processors = new Cessors(options.processors)\n    const { enumerable, nonenumerable } = options\n    const target = accessors.cess($target)\n    const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n    const key = subpaths.pop()\n    let subtarget = target\n    iterateSubpaths: \n    for(const $subpath of subpaths) {\n      subtarget = accessors.cess(subtarget, $subpath, options) || processors.cess(\n        subtarget, $subpath, isNaN($subpath) ? {} : [], options\n      )\n    }\n    processors.cess(subtarget, key, $value)\n    return $target\n  }\n  else {\n    const [$target, $value] = $arguments\n    return $target\n  }\n}","import regularExpressions from '../regular-expressions/index.js'\nexport default function deleteProperty($target, $path) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  let subtarget = $target\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath] }\n  delete subtarget[key]\n  return\n}","import entities from '../entities/index.js'\nexport default ($target, $options) => entities($target, 'entries', $options)","import { ObjectKeys } from '../variables/index.js'\nimport setProperty from '../set-property/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport entries from '../entries/index.js'\nconst Options = { ancestors: [], nonenumerable: false }\nconst ValidPathTypes = ['string', 'function']\nexport default function expand($source, $path, $options = {}) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors || []),\n    // accessors: [Acessors.default],\n  })\n  // throw options\n  const { ancestors } = options\n  const typeOfPath = typeOf($path)\n  const typeOfSource = typeOf($source)\n  if(\n    !ValidPathTypes.includes(typeOfPath) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  if(!ancestors.includes($source)) { ancestors.unshift($source) }\n  let target = typedObjectLiteral($source)\n  for(const [$sourceKey, $sourceValue] of entries(\n    $source, Object.assign({}, options, { recurse: false })\n  )) {\n    const targetValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expand($sourceValue, $path) : $sourceValue\n    if(\n      typeOfPath === ValidPathTypes[0] &&\n      $sourceValue !== null &&\n      !Object.is($sourceValue, $source) && \n      !ancestors.includes($sourceValue)\n    ) {\n      // throw [target, $sourceKey, $path, targetValue, options]\n      target[$sourceKey] = setProperty({}, $path, targetValue, options)\n    }\n    else if(typeOfPath === ValidPathTypes[1]) {\n      target[$sourceKey] = $path(targetValue)\n    }\n  }\n  return target\n}","import getProperty from '../get-property/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport entries from '../entries/index.js'\nconst Options = {}\nexport default function impand($source, $property, $options) {\n  const options = Object.assign({}, Options, $options)\n  const typeOfProperty = typeOf($property)\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of entries(\n    $source, Object.assign({}, options, { recurse: false })\n  )) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = getProperty($sourceValue, $property) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impand(target[$sourceKey], $property)\n    }\n  }\n  return target\n}","import { Cessors, Accessors } from '../cessors/index.js'\nimport entities from '../entities/index.js'\nconst Options = {\n  accessors: [Accessors.default],\n  ancestors: [],\n  depth: 0, maxDepth: 10,\n  enumerable: true, nonenumerable: false, \n  values: false,\n}\nexport default function compand($source, $options) {\n  const target = []\n  const options = Object.assign({}, Options, $options, {\n    ancestors: [].concat($options.ancestors || [])\n  })\n  const { ancestors, nonenumerable, values } = options\n  options.depth++\n  if(options.depth > options.maxDepth) { return target }\n  const source = new Cessors(options.accessors).cess($source)\n  if(!ancestors.includes(source)) { ancestors.unshift(source) }\n  const objectProperties = entities(source, 'entries', { nonenumerable, recurse: false })  \n  iterateObjectProperties: \n  for(const [$key, $value] of objectProperties) {\n    if(!values) { target.push($key) }\n    else if(values) { target.push([$key, $value]) }\n    if(\n      typeof $value === 'object' &&\n      $value !== null &&\n      !Object.is($value, source) && \n      !ancestors.includes($value)\n    ) {\n      const subsources = compand($value, options)\n      if(!values) {\n        for(const $subsource of subsources) {\n          const path = [$key, $subsource].join('.')\n          target.push(path)\n        }\n      }\n      else if(values) {\n        for(const [$subsourceKey, $subsource] of subsources) {\n          const path = [$key, $subsourceKey].join('.')\n          target.push([path, $subsource])\n        }\n      }\n    }\n  }\n  return target\n}","import { Cessors, Processors } from '../cessors/index.js'\nimport typeOf from '../type-of/index.js'\nimport setProperty from '../set-property/index.js'\nimport entries from '../entries/index.js'\nconst Options = {\n  processors: [Processors.default],\n  values: false,\n}\nexport default function decompand($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  const sourceEntries = (typeOf($source) === 'object') ? Object.entries($source) : $source\n  if(!sourceEntries) { return }\n  const target = (isNaN(sourceEntries[0][0])) ? {} : []\n  iterateSourceEntries: \n  for(const [$propertyPath, $propertyValue] of sourceEntries) {\n    setProperty(target, $propertyPath, $propertyValue, options)\n  }\n  return target\n}","import typeOf from '../type-of/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nexport default function assignSources($target, $type, ...$sources) {\n  if(!$target) { return $target}\n  const typeOfTarget = typeOf($target)\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const targetPropertyValue = $target[$sourcePropertyKey]\n      const typeOfTargetPropertyValue = typeOf(targetPropertyValue)\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if(typeOfTarget === 'array' && $type === 'assignConcat') {\n        $target.push($sourcePropertyValue)\n      }\n      else {\n        if(ObjectKeys.includes(typeOfTargetPropertyValue)) {\n          assignSources(targetPropertyValue, $type, $sourcePropertyValue)\n        }\n        else {\n          Object.assign($target, { [$sourcePropertyKey]: $sourcePropertyValue })\n        }\n      }\n    }\n  }\n  return $target\n}","import assignSources from '../assign-sources/index.js'\nexport default ($target, ...$sources) => assignSources($target, 'assign', ...$sources)","import assignSources from '../assign-sources/index.js'\nexport default ($target, ...$sources) => assignSources($target, 'assignConcat', ...$sources)","import entities from '../entities/index.js'\nimport typeOf from '../type-of/index.js'\nconst Options = { strict: true }\nexport default function isArrayLike($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    $source.length >= 0 && \n    Number.isInteger($source.length)\n  ) {\n    if(options.strict === false) {\n      isArrayLike = true\n    }\n    else {\n      iterateSourceKeys: \n      for(const $sourceKey of entities($source, 'keys', {\n        nonenumerable: true, recurse: false\n      }).reverse()) {\n        const lastIndex = Number($sourceKey)\n        if(lastIndex === $source.length - 1) {\n          isArrayLike = true\n          break iterateSourceKeys\n        }\n      }\n      if(isArrayLike === undefined) { isArrayLike = false }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","import isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport defineProperties from '../define-properties/index.js'\nimport * as Variables from '../variables/index.js'\nconst Options = { typeCoercion: false }\nexport default function defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor)\n  let propertyDescriptorValue = propertyDescriptor.value\n  const options = Object.assign({}, Options, $options)\n  const typeOfPropertyDescriptorValue = typeOf(propertyDescriptor.value)\n  const targetPropertyValue = $target[$propertyKey]\n  const typeOfTargetPropertyValue = typeOf(targetPropertyValue)\n  if(Variables.ObjectKeys.includes(typeOfPropertyDescriptorValue)) {\n    if(Variables.ObjectKeys.includes(typeOfTargetPropertyValue)) {\n      propertyDescriptor.value = defineProperties(targetPropertyValue, propertyDescriptorValue, options)\n    }\n    else {\n      const propertyValueTarget = typedObjectLiteral(isArrayLike(\n        Object.defineProperties({}, propertyDescriptorValue)\n      ) ? 'array' : 'object')\n      propertyDescriptor.value = defineProperties(propertyValueTarget, propertyDescriptorValue, options)\n    }\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyDescriptorValue)\n  ) {\n    propertyDescriptor.value = Variables.Primitives[propertyDescriptor.type](propertyDescriptorValue)\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor)\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]) }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]) }\n  return $target\n}","import defineProperty from '../define-property/index.js'\nexport default function defineProperties($target, $propertyDescriptors, $options) {\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, $options)\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = { ancestors: [] }\nfunction freeze($target, $options) {\n  const { ancestors } = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  if(!options.ancestors.includes($target)) { options.ancestors.unshift($target) }\n  iterateTargetProperties: \n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    const typeOfPropertyValue = typeOf($propertyValue)\n    if(options.ancestors.includes($propertyValue)) { continue iterateTargetProperties }\n    if(ObjectKeys.includes(typeOfPropertyValue)) {\n      freeze($propertyValue, options)\n    }\n  }\n  return Object.freeze($target)\n}\nexport default freeze","import typeOf from '../type-of/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = { ancestors: [] }\nfunction seal($target, $options) {\n  const { ancestors } = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  })\n  if(!options.ancestors.includes($target)) { options.ancestors.unshift($target) }\n  iterateTargetProperties: \n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    const typeOfPropertyValue = typeOf($propertyValue)\n    if(options.ancestors.includes($propertyValue)) { continue iterateTargetProperties }\n    if(ObjectKeys.includes(typeOfPropertyValue)) {\n      seal($propertyValue, options)\n    }\n  }\n  return Object.seal($target)\n}\nexport default seal","import isArrayLike from '../is-array-like/index.js'\nimport typeOf from '../type-of/index.js'\nconst Options = { strict: true, isArrayLike: false }\nexport default function isEntries($source, $options) {\n  const options = Object.assign({}, Options, $options)\n  if(typeOf($source) !== 'array') {\n    if(options.isArrayLike && isArrayLike($source, {\n      strict: options.strict\n    })) { $source = Array.from($source) }\n    else { return false }\n  }\n  if(!options.strict && !$source.length) { return true }\n  else {\n    let isEntries\n    iterateSourceEntities: \n    for(const $soureEntity of $source) {\n      isEntries = (\n        typeOf($soureEntity) === 'array' &&\n        $soureEntity.length === 2 &&\n        ['string', 'number', 'symbol'].includes(typeOf($soureEntity[0]))\n      )\n      if(isEntries === false) { break iterateSourceEntities }\n    }\n    return isEntries\n  }\n}","import entities from '../entities/index.js'\nexport default ($target, $options) => entities($target, 'keys', $options)","import entities from '../entities/index.js'\nexport default ($target, $options) => entities($target, 'values', $options)","import typeOf from '../type-of/index.js'\nimport getOwnPropertyDescriptors from '../get-own-property-descriptors/index.js'\nimport { Cessors, Accessors } from '../cessors/index.js'\nimport { ObjectKeys } from '../variables/index.js'\nconst Options = {\n  accessors: [Accessors.default],\n  ancestors: [],\n  delimiter: '.',\n  depth: 0,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n}\nexport default function getOwnPropertyDescriptor($properties, $propertyKey, $options = {}) {\n  const options = Object.assign({}, Options, $options, {\n    ancestors: Object.assign([], $options.ancestors),\n  })\n  if(options.depth >= options.maxDepth) { return }\n  else { options.depth++ }\n  const propertyValue = new Cessors(options.accessors).cess($properties, $propertyKey)\n  if(propertyValue) {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey)\n    if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n    if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties) }\n    if(options.ancestors.includes(/*propertyValue*/propertyValue)) { return }\n    if(options.path) {\n      options.path = (\n        typeOf(options.path) === 'string'\n      ) ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey\n      propertyDescriptor.path = options.path\n    }\n    if(options.type) { propertyDescriptor.type = typeOf(propertyValue) }\n    if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyValue) }\n    if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyValue) }\n    if(ObjectKeys.includes(typeOf(propertyValue))) {\n      propertyDescriptor.value = getOwnPropertyDescriptors(propertyValue, options)\n    }\n    return propertyDescriptor\n  }\n}","import getOwnPropertyDescriptor from '../get-own-property-descriptor/index.js'\nexport default function getOwnPropertyDescriptors($target, $options) {\n  const propertyDescriptors = {}\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($target))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($target, $propertyKey, $options)\n    if(propertyDescriptor) { propertyDescriptors[$propertyKey] = propertyDescriptor }\n  }\n  return propertyDescriptors\n}","export default function toString($target, $options) {}","export default function valueOf($target, $options) {}","import getProperty from './get-property/index.js'\nimport setProperty from './set-property/index.js'\nimport deleteProperty from './delete-property/index.js'\nimport expand from './expand/index.js'\nimport impand from './impand/index.js'\nimport compand from './compand/index.js'\nimport decompand from './decompand/index.js'\nimport assign from './assign/index.js'\nimport assignConcat from './assign-concat/index.js'\nimport defineProperties from './define-properties/index.js'\nimport defineProperty from './define-property/index.js'\nimport freeze from './freeze/index.js'\nimport seal from './seal/index.js'\nimport regularExpressions from './regular-expressions/index.js'\nimport typedObjectLiteral from './typed-object-literal/index.js'\nimport typeOf from './type-of/index.js'\nimport isArrayLike from './is-array-like/index.js'\nimport isEntries from './is-entries/index.js'\nimport * as variables from './variables/index.js'\nimport keys from './keys/index.js'\nimport values from './values/index.js'\nimport entries from './entries/index.js'\nimport entities from './entities/index.js'\nimport getOwnPropertyDescriptors from './get-own-property-descriptors/index.js'\nimport getOwnPropertyDescriptor from './get-own-property-descriptor/index.js'\nimport toString from './to-string/index.js'\nimport valueOf from './value-of/index.js'\n\nclass Recourse extends EventTarget {\n  static compand = compand\n  static decompand = decompand\n  static expand = expand\n  static impand = impand\n  static keys = keys\n  static values = values\n  static entries = entries\n  static entities = entities\n  static get = getProperty\n  static set = setProperty\n  static delete = deleteProperty\n  static assign = assign\n  static assignConcat = assignConcat\n  static defineProperties = defineProperties\n  static defineProperty = defineProperty\n  static freeze = freeze\n  static seal = seal\n  static getOwnPropertyDescriptors = getOwnPropertyDescriptors\n  static getOwnPropertyDescriptor = getOwnPropertyDescriptor\n  static isArrayLike = isArrayLike\n  static isEntries = isEntries\n  static typeOf = typeOf\n  static toString = toString\n  static valueOf = valueOf\n\n  constructor($target) {\n    super()\n    iterateStaticMutatorMethods: \n    for(const [$staticMethodName, $staticMethod] of Object.entries({\n      compand: Recourse.compand, decompand: Recourse.decompand, \n      expand: Recourse.expand, impand: Recourse.impand,\n      entities: Recourse.entities,\n      keys: Recourse.keys, values: Recourse.values, entries: Recourse.entries, \n      get: Recourse.get, set: Recourse.set, delete: Recourse.delete,\n      assign: Recourse.assign, assignConcat: Recourse.assignConcat, \n      defineProperties: Recourse.defineProperties, defineProperty: Recourse.defineProperty,\n      freeze: Recourse.freeze, seal: Recourse.seal,\n      getOwnPropertyDescriptors: Recourse.getOwnPropertyDescriptors, getOwnPropertyDescriptor: Recourse.getOwnPropertyDescriptor,\n      isArrayLike: Recourse.isArrayLike, isEntries: Recourse.isEntries, typeOf: Recourse.typeOf,\n    })) {\n      Object.defineProperty(this, $staticMethodName, {\n        value: $staticMethod.bind(this, $target)\n      })\n    }\n  }\n}\nexport {\n  Recourse, \n  getProperty as get, setProperty as set, deleteProperty as delete,\n  expand, impand, compand, decompand,\n  assign, assignConcat,\n  defineProperties, defineProperty,\n  freeze, seal,\n  keys, values, entries,\n  entities, \n  getOwnPropertyDescriptors, getOwnPropertyDescriptor,\n  isArrayLike, isEntries, typeOf,\n  typedObjectLiteral, regularExpressions, variables,\n}"],"names":["regularExpressions","quotationEscape","typeOf","$operand","Object","prototype","toString","call","slice","toLowerCase","Cessors","EventTarget","constructor","$cessors","super","cessors","assign","defineProperties","this","cess","value","cessValue","iterateAccessors","$cessor","arguments","undefined","Accessors","default","$target","$property","Processors","$value","$options","Options","accessors","getProperty","$path","options","subpaths","split","RegExp","subtarget","iterateSubpaths","$subpath","$err","Primitives","string","String","number","Number","boolean","Boolean","bigint","BigInt","null","PrimitiveKeys","keys","PrimitiveValues","values","Objects","object","array","Array","ObjectKeys","ObjectValues","Types","TypeKeys","TypeValues","TypeMethods","ancestors","depth","maxDepth","enumerable","nonenumerable","recurse","entities","$source","$type","sourceEntities","concat","includes","push","$key","$propertyDescriptor","entries","getOwnPropertyDescriptors","typeOfValue","typedObjectLiteral","_typedObjectLiteral","processors","setProperty","$arguments","target","key","pop","isNaN","deleteProperty","ValidPathTypes","expand","typeOfPath","typeOfSource","unshift","$sourceKey","$sourceValue","targetValue","is","impand","typeOfProperty","compand","source","objectProperties","subsources","$subsourceKey","$subsource","path","join","decompand","sourceEntries","$propertyPath","$propertyValue","assignSources","$sources","typeOfTarget","$sourcePropertyKey","$sourcePropertyValue","targetPropertyValue","typeOfTargetPropertyValue","assignConcat","strict","isArrayLike","length","isInteger","iterateSourceKeys","reverse","typeCoercion","defineProperty","$propertyKey","propertyDescriptor","propertyDescriptorValue","typeOfPropertyDescriptorValue","Variables.ObjectKeys","propertyValueTarget","getOwnPropertyDescriptor","Variables.Primitives","type","sealed","seal","frozen","freeze","$propertyDescriptors","typeOfPropertyValue","isEntries","from","iterateSourceEntities","$soureEntity","delimiter","$properties","propertyValue","isFrozen","isSealed","propertyDescriptors","valueOf","Recourse","static","$staticMethodName","$staticMethod","get","set","delete","bind"],"mappings":"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"}