{"version":3,"file":"recourse.min.js","sources":["../../../development/accessors/index.js","../../../development/expand-events/index.js","../../../development/variables/index.js","../../../development/regular-expressions/index.js","../../../development/type-of/index.js","../../../development/path/index.js","../../../development/typed-object-literal/index.js","../../../development/tree/index.js","../../../development/expand-tree/index.js","../../../development/is-array-like/index.js","../../../development/impand-tree/index.js","../../../development/property-directory/index.js","../../../development/recursive-assign/index.js","../../../development/recursive-assign-concat/index.js","../../../development/recursive-get-own-property-descriptor/index.js","../../../development/recursive-get-own-property-descriptors/index.js","../../../development/recursive-define-property/index.js","../../../development/recursive-define-properties/index.js","../../../development/recursive-freeze/index.js"],"sourcesContent":["const defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n}\nconst getAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target.get($property) }\n}\nexport default {\n  default: defaultAccessor,\n  get: getAccessor,\n}","function expandEvents($propEvents, $scopeKey = ':scope') {\n  if(\n    Array.isArray($propEvents) ||\n    $propEvents === undefined\n  ) { return $propEvents }\n  const propEvents = []\n  iteratePropEvents:\n  for(const [\n    $propEventSettings, $propEventListener\n  ] of Object.entries($propEvents)) {\n    const propEventSettings = $propEventSettings.trim().split(' ')\n    let path, type, listener, options\n    if(propEventSettings.length === 1) {\n      path = $scopeKey\n      type = propEventSettings[0]\n    }\n    else if(propEventSettings.length > 1) {\n      path = propEventSettings[0]\n      type = propEventSettings[1]\n    }\n    if(Array.isArray($propEventListener)) {\n      listener = $propEventListener[0]\n      options = $propEventListener[1]\n    }\n    else {\n      listener = $propEventListener\n    }\n    const propEvent = {\n      type,\n      path,\n      listener,\n      enable: false,\n    }\n    propEvents.push(propEvent)\n  }\n  return propEvents\n}\n\nexport default expandEvents","const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'undefined': undefined,\n  'null': null,\n}\nconst PrimitiveKeys = Object.keys(Primitives)\nconst PrimitiveValues = Object.values(Primitives)\nconst Objects = {\n  'object': Object,\n  'array': Array,\n}\nconst ObjectKeys = Object.keys(Objects)\nconst ObjectValues = Object.values(Objects)\nconst Types = Object.assign({}, Primitives, Objects)\nconst TypeKeys = Object.keys(Types)\nconst TypeValues = Object.values(Types)\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n]\nexport {\n  Primitives, PrimitiveKeys, PrimitiveValues, \n  Objects, ObjectKeys, ObjectValues,\n  Types, TypeKeys, TypeValues, TypeMethods\n}\n","export default {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n}","export default ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase()","import regularExpressions from '../regular-expressions/index.js'\nimport typeOf from '../type-of/index.js'\nfunction subpaths($path) {\n  return $path.split(\n    new RegExp(regularExpressions.quotationEscape)\n  )\n}\nfunction keypaths($path) {\n  const _subpaths = subpaths($path)\n  _subpaths.pop()\n  return _subpaths\n}\nfunction key($path) { return subpaths($path).pop() }\nfunction root($path) { return subpaths($path).shift() }\nfunction typeofRoot($path) { return (\n  Number(root($path))\n) ? 'array' : 'object' }\nfunction parse($path) {\n  return {\n    subpaths: subpaths($path),\n    keypaths: keypaths($path),\n    key: key($path),\n    root: root($path),\n    typeofRoot: typeofRoot($path),\n  }\n}\nexport {\n  subpaths,\n  keypaths,\n  key,\n  root,\n  typeofRoot,\n  parse,\n}","import typeOf from '../type-of/index.js'\nexport default function typedObjectLiteral($value) {\n  let _typedObjectLiteral\n  const typeOfValue = typeOf($value)\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase()\n    if(value === 'object') { _typedObjectLiteral = {} }\n    else if(value === 'array') { _typedObjectLiteral = [] }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {} }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = [] }\n  }\n  return _typedObjectLiteral\n}","import * as path from '../path/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport regularExpressions from '../regular-expressions/index.js'\nfunction get($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape))\n  const key = subpaths.pop()\n  let subtarget = $source\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath] }\n  return subtarget[key]\n}\nfunction set($path, $source) {\n  const {\n    keypaths, key, typeofRoot\n  } = path.parse($path)\n  const target = typedObjectLiteral(typeofRoot)\n  let subtarget = target\n  for(const $subpath of keypaths) {\n    if(Number($subpath)) { subtarget[$subpath] = [] }\n    else { subtarget[$subpath] = {} }\n    subtarget = subtarget[$subpath]\n  }\n  subtarget[key] = $source\n  return target\n}\nexport { get, set }","import * as Variables from '../variables/index.js'\nimport * as Path from '../path/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nexport default function expandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = Tree.set($property, $sourceValue) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey][$property] && typeof target[$sourceKey][$property] === 'object') {\n      target[$sourceKey][$property] = expandTree(target[$sourceKey][$property], $property)\n    }\n  }\n  return target\n}","import typeOf from '../type-of/index.js'\nexport default ($source) => {\n  let isArrayLike\n  const typeOfSource = typeOf($source)\n  if(typeOfSource === 'array') { isArrayLike = true }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey)\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false }\n  return isArrayLike\n}","import * as Variables from '../variables/index.js'\nimport * as Path from '../path/index.js'\nimport * as Tree from '../tree/index.js'\nimport typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nexport default function impandTree($source, $property) {\n  const typeOfProperty = typeOf($property)\n  const typeOfSource = typeOf($source)\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source)\n  iterateSourceEntries: \n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = Tree.get($property, $sourceValue) }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue) }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property)\n    }\n  }\n  return target\n}","import Accessors from '../accessors/index.js'\nconst Options = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n}\nexport default function propertyDirectory($object, $options) {\n  const _propertyDirectory = []\n  const options = Object.assign({}, Options, $options)\n  options.depth++\n  if(options.depth > options.maxDepth) { return _propertyDirectory }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object)\n    const object = accessor($object)\n    if(!object) continue iterateAccessors\n    iterateObjectProperties: \n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _propertyDirectory.push($key) }\n      else if(options.values) { _propertyDirectory.push([$key, $value]) }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        $value !== object\n      ) {\n        const subtargets = propertyDirectory($value, options)\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.')\n            _propertyDirectory.push(path)\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.')\n            _propertyDirectory.push([path, $subtarget])\n          }\n        }\n      }\n    }\n  }\n  return _propertyDirectory\n}","import typeOf from '../type-of/index.js'\nexport default function recursiveAssign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = recursiveAssign($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nexport default function recursiveAssignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    iterateSourceEntries: \n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey])\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue)\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = recursiveAssignConcat($target[$sourcePropertyKey], $sourcePropertyValue)\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue)\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue\n      }\n    }\n  }\n  return $target\n}","import typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport recursiveGetOwnPropertyDescriptors from '../recursive-get-own-property-descriptors/index.js'\nexport default function recursiveGetOwnPropertyDescriptor($properties, $propertyKey) {\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey)\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = recursiveGetOwnPropertyDescriptors(propertyDescriptor.value)\n  }\n  return propertyDescriptor\n}","import recursiveGetOwnPropertyDescriptor from '../recursive-get-own-property-descriptor/index.js'\nexport default function recursiveGetOwnPropertyDescriptors($properties) {\n  const propertyDescriptors = {}\n  for(const $propertyKey of Object.keys(Object.getOwnPropertyDescriptors($properties))) {\n    propertyDescriptors[$propertyKey] = recursiveGetOwnPropertyDescriptor($properties, $propertyKey)\n  }\n  return propertyDescriptors\n}","import typeOf from '../type-of/index.js'\nimport typedObjectLiteral from '../typed-object-literal/index.js'\nimport recursiveDefineProperties from '../recursive-define-properties'\nimport isArrayLike from '../is-array-like/index.js'\nexport default function recursiveDefineProperty($target, $propertyKey, $propertyDescriptor) {\n  const typeOfPropertyValue = typeOf($propertyDescriptor.value)\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), $propertyDescriptor.value\n    )) ? [] : {}\n    $propertyDescriptor.value = recursiveDefineProperties(propertyValue, $propertyDescriptor.value)\n  }\n  Object.defineProperty($target, $propertyKey, $propertyDescriptor)\n  return $target\n}","import recursiveDefineProperty from '../recursive-define-property/index.js'\nexport default function recursiveDefineProperties($target, $propertyDescriptors) {\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    recursiveDefineProperty($target, $propertyKey, $propertyDescriptor)\n  }\n  return $target\n}","function recursiveFreeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if($propertyValue && typeof $propertyValue === 'object') {\n      recursiveFreeze($propertyValue)\n    }\n  }\n  return Object.freeze($target)\n}\nexport default recursiveFreeze"],"names":["Accessors","default","$target","$property","undefined","get","expandEvents","$propEvents","$scopeKey","Array","isArray","propEvents","$propEventSettings","$propEventListener","Object","entries","propEventSettings","trim","split","path","type","listener","options","length","propEvent","enable","push","Primitives","string","String","number","Number","boolean","Boolean","null","PrimitiveKeys","keys","PrimitiveValues","values","Objects","object","array","ObjectKeys","ObjectValues","Types","assign","TypeKeys","TypeValues","TypeMethods","regularExpressions","quotationEscape","typeOf","$data","prototype","toString","call","slice","toLowerCase","subpaths","$path","RegExp","keypaths","_subpaths","pop","key","root","shift","typeofRoot","parse","typedObjectLiteral","$value","_typedObjectLiteral","typeOfValue","value","$source","subtarget","$subpath","set","path.parse","target","expandTree","typeOfProperty","typeOfSource","includes","$sourceKey","$sourceValue","Tree.set","isArrayLike","isInteger","iterateSourceKeys","getOwnPropertyDescriptors","isNaN","impandTree","Tree.get","Options","depth","maxDepth","accessors","propertyDirectory","$object","$options","_propertyDirectory","$accessor","bind","accessor","$key","subtargets","$subtargetKey","$subtarget","join","recursiveAssign","$sources","$sourcePropertyKey","$sourcePropertyValue","typeOfTargetPropertyValue","typeOfSourcePropertyValue","recursiveAssignConcat","concat","recursiveGetOwnPropertyDescriptor","$properties","$propertyKey","propertyDescriptor","getOwnPropertyDescriptor","recursiveGetOwnPropertyDescriptors","propertyDescriptors","recursiveDefineProperty","$propertyDescriptor","typeOfPropertyValue","propertyValue","defineProperties","recursiveDefineProperties","defineProperty","$propertyDescriptors","recursiveFreeze","$propertyValue","freeze"],"mappings":"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"}