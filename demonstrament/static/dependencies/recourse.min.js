function e(e){const t=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,s=[];let n;for(;null!==(n=t.exec(e));)n[1]?s.push(n[1]):n[2]?s.push(parseInt(n[2],10)):n[3]?s.push(n[3]):n[4]&&s.push(n[4]);return s}var t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const s={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},n=Object.keys(s),r=Object.values(s),c={object:Object,array:Array,map:Map},i=Object.keys(c),o=Object.values(c),a=Object.assign({},s,c),u=Object.keys(a),l=Object.values(a),f=[s.String,s.Number,s.Boolean,c.Object,c.Array];var p=Object.freeze({__proto__:null,ObjectKeys:i,ObjectValues:o,Objects:c,PrimitiveKeys:n,PrimitiveValues:r,Primitives:s,TypeKeys:u,TypeMethods:f,TypeValues:l,Types:a});const b={Object:function(...e){if(["object","array"].includes(t(e[0]))){if(1===e.length){const[t]=e;return t}{const[t,s]=e;return t[s]}}return this?.next(...e)},Map:function(...e){if("map"!==t(e[0]))return this?.next(...e);if(1===e.length){let[t]=e;return t}{let[t,s]=e;return t.get(s)}}},g={Object:function(...e){if(["object","array"].includes(t(e[0]))){if(["string","number"].includes(t(e[1]))){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,n]of Object.entries(s))t[e]=n;return t}}return this?.next(...e)},Map:function(...e){if("map"!==t(e[0]))return this?.next(...e);if(2===e.length){let[t,s]=e;t.clear();for(const[e,s]of Object.entries(source))t.set(e,s);return t}{let[t,s,n]=e;return t.set(s,n),t.get(s)}}},d={Object:function(...e){const[s,n]=e;if(!["object","array"].includes(t(s)))return this?.next(...e);if(["string","number"].includes(t(n)))return delete s[n];for(const e of Object.keys(s))delete s[e]},Map:function(...e){if("map"!==t(e[0]))return this?.next(...e);if(2===e`.length`){let[t,s]=e;return t.delete(s)}{let[t]=e;return t.clear()}}};class j extends EventTarget{constructor(e){super();const t=e.map(((t,s)=>t.bind({next:e[s+1]})));Object.defineProperties(this,{cess:{value:function(){try{return t[0](...arguments)}catch(e){console.error(e)}}}})}}var O=Object.freeze({__proto__:null,Deleters:d,Getters:b,Setters:g,Tensors:j});const h={getters:[b.Object,b.Map]};function y(){const[t,s,n]=[...arguments];if(void 0===s)return arguments[0];const r=Object.assign({},h,n),c=new j(r.getters),i=e(s);let o=t;e:for(const e of i)try{if(o=c.cess(o,e),void 0===o)break e}catch(e){break e}return o}const m={getters:[b.Object,b.Map],delimiter:".",depth:0,enumerable:!0,frozen:!1,maxDepth:10,nonenumerable:!1,path:!1,recurse:!0,returnValue:"receiver",sealed:!1,type:!1};function v(e,s,n={}){const r=Object.assign({},m,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++,r.ancestors.includes(e)||r.ancestors.unshift(e);const c=new j(r.getters).cess(e,s);if(void 0!==c){if(i.includes(t(c))){if(r.ancestors.includes(c))return;r.ancestors.unshift(c)}const n="map"!==t(e)?Object.getOwnPropertyDescriptor(e,s):{configurable:!1,enumerable:!0,value:c[1],writable:!0};if(!r.nonenumerable&&!n.enumerable)return;return r.path&&(r.path="string"===t(r.path)?[r.path,s].join(r.delimiter):s,n.path=r.path),r.type&&(n.type=t(c)),r.frozen&&(n.frozen=Object.isFrozen(c)),r.sealed&&(n.sealed=Object.isSealed(c)),r.recurse&&i.includes(t(c))?n.value=w(c,r):n.value=c,n}}function w(e,s={}){const n=Object.assign({},s),r={},c=t(e),i=["array","object"].includes(c)?Object.keys(Object.getOwnPropertyDescriptors(e)):"map"==c?Array.from(e.keys()):[];for(const t of i){const s=v(e,t,n);s&&(r[t]=s)}return r}const k={getters:[b.Object,b.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function x(e,s,n={}){t(e);const r=[],c=Object.assign({},k,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:o,maxDepth:a,enumerable:u,nonenumerable:l,recurse:f}=c;if(c.depth>=a)return;o.includes(e)||o.unshift(e),c.depth++;const p=new j(c.getters),b=p.cess(e),g="map"===t(b)?b.keys():Object.keys(b);for(const n of g){const a=p.cess(e,n),b="map"!==t(e)?Object.getOwnPropertyDescriptor(e,n):{configurable:!1,enumerable:!0,value:a,writable:!0};if(u&&b.enumerable||l&&!b.enumerable){const e=b.value,a=t(e);if(f&&i.includes(a)&&!o.includes(e)){o.unshift(e);const t=x(e,s,c);t.length?"entries"===s?r.push([n,t]):"values"===s?r.push(t):"keys"===s&&r.push(n,t):"entries"===s?r.push([n,e]):"values"===s?r.push(e):"keys"===s&&r.push(n)}else"entries"===s?r.push([n,e]):"values"===s?r.push(e):"keys"===s&&r.push(n)}}return r}const D={strict:!0};function M(e,s){const n=Object.assign({},D,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of x(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const P={strict:!0};function z(e,s){const n=Object.assign({},P,s);let r;const c=t(e);if("map"===c)r=!0;else if("object"===c&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of x(e,"entries",{nonenumerable:!0,recurse:!1})){if(!M(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}function A(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();if("object"===t)return Object();if("array"===t)return Array();if("map"===t)return new Map;s={}}else{if("object"===n)return Object();if(M(e,{strict:!0}))return Array();if(z(e,{strict:!0}))return new Map;s={}}}const N={getters:[b.Object,b.Map],setters:[g.Object,g.Map]};function _(){const s=[...arguments];if("string"===t(s[1])){const[t,n,r,c]=s,i=Object.assign({},N,c),o=new j(i.getters),a=new j(i.setters),{enumerable:u,nonenumerable:l}=i,f=(o.cess(t),e(n)),p=f.pop();let b=t;e:for(const e of f)if(b=o.cess(b,e,i)||a.cess(b,e,isNaN(e)?{}:[]),void 0===b)break e;return a.cess(b,p,r,i),t}{const[e,t]=s;return e}}const C={deleters:[d.Object,d.Map]};function L(t,s,n){const r=Object.assign({},C,n),c=new j(r.deleters),i=e(s),o=i.pop(),a=y(t,i.join("."),r)||t;c.cess(a,o)}const S=["string","function"];function T(e,s,n={}){const r=Object.assign({},n),c=t(s),o=t(e);if(!S.includes(c)||!i.includes(o))return e;let a=A(e);for(const[n,o]of x(e,"entries",Object.assign({},r,{recurse:!1}))){const e=i.includes(t(o))?T(o,s,r):o;c===S[0]?a[n]=_({},s,e,r):c===S[1]&&(a[n]=s(e))}return a}const V={ancestors:[],getters:[b.Object,b.Map],depth:0,maxDepth:10};function I(e,s,n={}){const r=Object.assign({},V,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,values:i}=r;if(r.depth>r.maxDepth)return;r.depth++;const o=new j(r.getters).cess(e);c.includes(o)||c.unshift(o);const a=t(s);let u=A(e);for(const[t,n]of x(e,"entries",Object.assign({},r,{recurse:!1})))"string"===a?u[t]=y(n,s):"function"===a&&(u[t]=s(n)),u[t]&&"object"==typeof u[t]&&(u[t]=I(u[t],s));return u}const B={depth:0,getters:[b.Object,b.Map],maxDepth:10,values:!1};function K(e,t){const s=[],n=Object.assign({},B,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:c}=n;if(n.depth++,n.depth>n.maxDepth)return s;const i=new j(n.getters).cess(e);r.includes(e)||r.unshift(e);const o=x(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of o)if(c?c&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!r.includes(t)){const r=K(t,n);if(c){if(c)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const E={setters:[g.Object,g.Map]};function Z(e,s){const n=Object.assign({},E,s),r="object"===t(e)?x(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)_(c,e,t,n);return c}const F={getters:[b.Object,b.Map],setters:[g.Object,g.Map]};function G(e,s,...n){if(!e)return e;const r=Object.assign({},F),c=new j(r.getters),o=new j(r.setters),a=t(e);e:for(const r of n){if(!i.includes(t(r)))continue e;const n=x(r,"entries",{recurse:!1});for(const[r,u]of n){const n=c.cess(e,r),l=t(n),f=t(u);"array"===a&&"assignConcat"===s?o.cess(e,e.length,u):i.includes(f)&&i.includes(l)?G(n,s,u):o.cess(e,r,u)}}}var J=(e,...t)=>G(e,"assign",...t),q=(e,...t)=>G(e,"assignConcat",...t);const H={typeCoercion:!1};function Q(e,n,r,c){const o=Object.assign({},r);let a=o.value;const u=Object.assign({},H,c),l=t(o.value),f=e[n],p=t(f);if(i.includes(l))if(i.includes(p))o.value=R(f,a,u);else{console.log(a);const e=A(M(Object.defineProperties({},a))?"array":"object");o.value=R(e,a,u)}else u.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(o,"type")&&(o.value=new s[o.type](a));return Object.defineProperty(e,n,o),r.sealed&&Object.seal(e[n]),r.frozen&&Object.freeze(e[n]),e}function R(e,t,s){for(const[n,r]of Object.entries(t))Q(e,n,r,s);return e}const U={getters:[b.Object,b.Map],ancestors:[],depth:0,maxDepth:10};function W(e,s={}){const n=Object.assign({},U,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const o=new j(n.getters).cess(e);r.includes(o)||r.unshift(o);const a=x(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of a)r.includes(s)||i.includes(t(s))&&W(s,n);return Object.freeze(e)}const X={getters:[b.Object,b.Map],ancestors:[],depth:0,maxDepth:10};function Y(e,s={}){const n=Object.assign({},X,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const o=new j(n.getters).cess(e);r.includes(o)||r.unshift(o);const a=x(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of a)r.includes(s)||i.includes(t(s))&&Y(s,n);return Object.seal(e)}var $=(e,t)=>x(e,"keys",t),ee=(e,t)=>x(e,"values",t),te=(e,t)=>x(e,"entries",t);function se(e,s={}){if("receiver"===Object.assign({},s).returnValue)return e;return R(A(t(e)),w(e,s))}const ne={space:0,replacer:null,returnValue:"target",nonenumerable:!0};function re(e,t){const s=Object.assign({},ne,t);return JSON.stringify(se(e,s),s.replacer,s.space)}class ce extends EventTarget{static compand=K;static decompand=Z;static expand=T;static impand=I;static keys=$;static values=ee;static entries=te;static entities=x;static get=y;static set=_;static delete=L;static assign=J;static assignConcat=q;static defineProperties=R;static defineProperty=Q;static freeze=W;static seal=Y;static getOwnPropertyDescriptors=w;static getOwnPropertyDescriptor=v;static isArrayLike=M;static isMapLike=z;static typeOf=t;static toString=re;static valueOf=se;constructor(e){super();for(const[t,s]of Object.entries({compand:ce.compand,decompand:ce.decompand,expand:ce.expand,impand:ce.impand,entities:ce.entities,keys:ce.keys,values:ce.values,entries:ce.entries,get:ce.get,set:ce.set,delete:ce.delete,assign:ce.assign,assignConcat:ce.assignConcat,defineProperties:ce.defineProperties,defineProperty:ce.defineProperty,freeze:ce.freeze,seal:ce.seal,getOwnPropertyDescriptors:ce.getOwnPropertyDescriptors,getOwnPropertyDescriptor:ce.getOwnPropertyDescriptor,isArrayLike:ce.isArrayLike,isMapLike:ce.isMapLike,typeOf:ce.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{ce as Recourse,J as assign,q as assignConcat,K as compand,Z as decompand,R as defineProperties,Q as defineProperty,L as delete,x as entities,te as entries,T as expand,W as freeze,y as get,v as getOwnPropertyDescriptor,w as getOwnPropertyDescriptors,I as impand,M as isArrayLike,$ as keys,Y as seal,_ as set,e as splitPath,O as tensors,re as toString,t as typeOf,A as typedObjectLiteral,se as valueOf,ee as values,p as variables};
//# sourceMappingURL=recourse.min.js.map
