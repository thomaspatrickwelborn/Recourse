var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/,quotationStartStop:/^"(.*)"$/},t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const{quotationEscape:s,quotationStartStop:n}=e;function r(s){const n=t(s);if("string"===n){const t=s.split(new RegExp(e.quotationEscape));let n=0;for(;n<t.length;)t[n]=t[n].replace(new RegExp(e.quotationStartStop),"$1"),n++;return t}if("number"===n)return[s]}const c={Object:function(...e){const s=arguments[0];if(["object","array"].includes(t(s))){if("string"===t(arguments[1])){return s[arguments[1]]}return s}},Map:function(){const e=[...arguments];if("map"===t(e[0])){if("boolean"!==t(e[e.length-1])&&e.push(!0),3===e.length){const[t,s,n]=e;return n?t.get(s):t[s]}if(2===e.length){const[t,s]=e;return s?Array.from(t.entries()):t}}}},o={Object:function(){const e=[...arguments];if(["object","array"].includes(t(e[0]))){if("string"===t(e[1])){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,s]of Object.entries(source))t[e]=s;return t}}},Map:function(){const e=[...arguments];if("map"!==t(e[0]))return;const s=e.length;if(3===s){const[t,s,n]=e;return t.set(s,n),t.get(s)}if(2===s){const[t,s]=e;t.clear();for(const[e,s]of Object.entries(source))t.set(e,s);return t}}},i={Object:function(e,s){const n=[...arguments];if(["object","array"].includes(t(n[0]))){if("string"===t(n[1]))return delete e[s];for(const t of Object.keys(e))delete e[t]}else;},Map:function(){const e=[...arguments];console.log(e);const s=e.length;if("map"===t(e[0])){if(2===s){const[t,s]=e;return t.delete(s)}if(1===s){const[t]=e;return t.clear()}}}};class a extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}var u=Object.freeze({__proto__:null,Deleters:i,Getters:c,Setters:o,Tensors:a});const f={getters:[c.Object,c.Map],returnTarget:!1};function l(){const[e,t,s]=[...arguments];if(void 0===t)return arguments[0];const n=Object.assign({},f,s),c=new a(n.getters),o=r(t);let i=e;e:for(const e of o)try{if(i=c.cess(i,e),void 0===i)break e}catch(e){break e}return i}function p(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();"object"===t?s={}:"array"===t&&(s=[])}else"object"===n?s={}:"array"===n&&(s=[]);return s}const b={enumerable:!0,nonenumerable:!1,getters:[c.Object,c.Map],setters:[o.Object,o.Map],returnTarget:!1};function g(){const e=[...arguments];if("string"===t(e[1])){const[t,s,n,c]=e,o=Object.assign({},b,c),i=new a(o.getters),u=new a(o.setters),{enumerable:f,nonenumerable:l}=o,p=(i.cess(t),r(s)),g=p.pop();let j=t;e:for(const e of p)if(j=i.cess(j,e)||u.cess(j,e,isNaN(e)?{}:[]),void 0===j)break e;return u.cess(j,g,n),t}{const[t,s]=e;return t}}const j={deleters:[i.Object,i.Map]};function O(e,t,s){const n=Object.assign({},j,s),c=new a(n.deleters),o=r(t),i=o.pop(),u=l(e,o.join("."))||e;c.cess(u,i)}const d={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},y=Object.keys(d),h=Object.values(d),m={object:Object,array:Array,map:Map},v=Object.keys(m),w=Object.values(m),k=Object.assign({},d,m),P=Object.keys(k),D=Object.values(k),x=[d.String,d.Number,d.Boolean,m.Object,m.Array];var M=Object.freeze({__proto__:null,ObjectKeys:v,ObjectValues:w,Objects:m,PrimitiveKeys:y,PrimitiveValues:h,Primitives:d,TypeKeys:P,TypeMethods:x,TypeValues:D,Types:k});const S={getters:[c.Object,c.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function z(e,s,n){const r=[],c=Object.assign({},S,n,{ancestors:[].concat(n.ancestors||[])}),{ancestors:o,maxDepth:i,enumerable:u,nonenumerable:f,recurse:l}=c;if(c.depth>=i)return;o.includes(e)||o.push(e);const p=new a(c.getters).cess(e);c.depth++;for(const[e,n]of Object.entries(Object.getOwnPropertyDescriptors(p)))if(u&&n.enumerable||f&&!n.enumerable){const i=n.value,a=t(i);l&&v.includes(a)&&!o.includes(i)?"entries"===s?r.push([e,z(i,s,c)]):"values"===s?r.push(z(i,s,c)):"keys"===s&&r.push(e,z(i,s,c)):"entries"===s?r.push([e,i]):"values"===s?r.push(i):"keys"===s&&r.push(e)}return r}const E={ancestors:[],nonenumerable:!1},A=["string","function"];function C(e,s,n={}){const r=Object.assign({},E,n,{ancestors:[].concat(n.ancestors||[])}),{ancestors:c}=r,o=t(s),i=t(e);if(!A.includes(o)||!v.includes(i))return e;c.includes(e)||c.unshift(e);let a=p(e);for(const[n,i]of z(e,"entries",Object.assign({},r,{recurse:!1}))){const u=v.includes(t(i))?C(i,s):i;o!==A[0]||null===i||Object.is(i,e)||c.includes(i)?o===A[1]&&(a[n]=s(u)):a[n]=g({},s,u,r)}return a}var N=(e,t)=>z(e,"entries",t);const T={};function _(e,s,n){const r=Object.assign({},T,n),c=t(s);let o=p(e);for(const[t,n]of N(e,Object.assign({},r,{recurse:!1})))"string"===c?o[t]=l(n,s):"function"===c&&(o[t]=s(n)),o[t]&&"object"==typeof o[t]&&(o[t]=_(o[t],s));return o}const L={ancestors:[],depth:0,enumerable:!0,getters:[c.Object,c.Map],maxDepth:10,nonenumerable:!1,values:!1};function q(e,t){const s=[],n=Object.assign({},L,t,{ancestors:[].concat(t.ancestors||[])}),{ancestors:r,nonenumerable:c,values:o}=n;if(n.depth++,n.depth>n.maxDepth)return s;const i=new a(n.getters).cess(e);r.includes(i)||r.unshift(i);const u=z(i,"entries",{nonenumerable:c,recurse:!1});for(const[e,t]of u)if(o?o&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!r.includes(t)){const r=q(t,n);if(o){if(o)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const B={setters:[o.Object]};function K(e,s){const n=Object.assign({},B,s),r="object"===t(e)?z(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)g(c,e,t,n);return c}function V(e,s,...n){if(!e)return e;const r=t(e);for(const c of n)if(c)for(const[n,o]of Object.entries(c)){const c=e[n],i=t(c);t(o);"array"===r&&"assignConcat"===s?e.push(o):v.includes(i)?V(c,s,o):Object.assign(e,{[n]:o})}return e}var $=(e,...t)=>V(e,"assign",...t),I=(e,...t)=>V(e,"assignConcat",...t);const R={strict:!0};function F(e,s){const n=Object.assign({},R,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of z(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const G={typeCoercion:!1};function J(e,s,n,r){const c=Object.assign({},n);let o=c.value;const i=Object.assign({},G,r),a=t(c.value),u=e[s],f=t(u);if(v.includes(a))if(v.includes(f))c.value=H(u,o,i);else{const e=p(F(Object.defineProperties({},o))?"array":"object");c.value=H(e,o,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined","null"].includes(a)&&(c.value=d[c.type](o));return Object.defineProperty(e,s,c),n.sealed&&Object.seal(e[s]),n.frozen&&Object.freeze(e[s]),e}function H(e,t,s){for(const[n,r]of Object.entries(t))J(e,n,r,s);return e}const Q={ancestors:[],getters:[c.Object,c.Map]};function U(e,s={}){const n=Object.assign({},Q,s,{ancestors:Object.assign([],s.ancestors)}),r=z(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of r)v.includes(t(s))&&U(s,n);return Object.freeze(e)}const W={};function X(e,t){const s=Object.assign({},W,t,{});throw z(e,"entries",s)}const Y={strict:!0,isArrayLike:!1};function Z(e,s){const n=Object.assign({},Y,s);if("array"!==t(e)){if(!n.isArrayLike||!F(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var ee=(e,t)=>z(e,"keys",t),te=(e,t)=>z(e,"values",t);const se={getters:[c.Object,c.Map],ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function ne(e,s,n={}){const r=Object.assign({},se,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++;const c=new a(r.getters).cess(e,s);if(c){const n=Object.getOwnPropertyDescriptor(e,s);if(!r.nonenumerable&&!n.enumerable)return;if(r.ancestors.includes(e)||r.ancestors.unshift(e),r.ancestors.includes(c))return;return r.path&&(r.path="string"===t(r.path)?[r.path,s].join(r.delimiter):s,n.path=r.path),r.type&&(n.type=t(c)),r.frozen&&(n.frozen=Object.isFrozen(c)),r.sealed&&(n.sealed=Object.isSealed(c)),v.includes(t(c))&&(n.value=re(c,r)),n}}function re(e,t){const s={};for(const[n,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=ne(e,n,t);r&&(s[n]=r)}return s}const ce={ancestors:[],getters:[c.Object,c.Map]};function oe(e,s={}){const n=Object.assign({},ce,s,{ancestors:Object.assign([],s.ancestors)}),r=new a(n.getters).cess(e);if(void 0===r)throw[e,r];n.ancestors.includes(e)||n.ancestors.unshift(e);const c=p(t(r)),o=z(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of o){let r;if(r=v.includes(t(s))?oe(s,n):s,!n.ancestors.includes(r))try{c[e]=r}catch(e){console.error(e)}}return c}const ie={space:0,replacer:null};function ae(e,t){const s=Object.assign({},ie,t);return JSON.stringify(oe(e,s),s.replacer,s.space)}class ue extends EventTarget{static compand=q;static decompand=K;static expand=C;static impand=_;static keys=ee;static values=te;static entries=N;static entities=z;static get=l;static set=g;static delete=O;static assign=$;static assignConcat=I;static defineProperties=H;static defineProperty=J;static freeze=U;static seal=X;static getOwnPropertyDescriptors=re;static getOwnPropertyDescriptor=ne;static isArrayLike=F;static isEntries=Z;static typeOf=t;static toString=ae;static valueOf=oe;constructor(e){super();for(const[t,s]of Object.entries({compand:ue.compand,decompand:ue.decompand,expand:ue.expand,impand:ue.impand,entities:ue.entities,keys:ue.keys,values:ue.values,entries:ue.entries,get:ue.get,set:ue.set,delete:ue.delete,assign:ue.assign,assignConcat:ue.assignConcat,defineProperties:ue.defineProperties,defineProperty:ue.defineProperty,freeze:ue.freeze,seal:ue.seal,getOwnPropertyDescriptors:ue.getOwnPropertyDescriptors,getOwnPropertyDescriptor:ue.getOwnPropertyDescriptor,isArrayLike:ue.isArrayLike,isEntries:ue.isEntries,typeOf:ue.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{ue as Recourse,$ as assign,I as assignConcat,q as compand,K as decompand,H as defineProperties,J as defineProperty,O as delete,z as entities,N as entries,C as expand,U as freeze,l as get,ne as getOwnPropertyDescriptor,re as getOwnPropertyDescriptors,_ as impand,F as isArrayLike,Z as isEntries,ee as keys,e as regularExpressions,X as seal,g as set,r as splitPath,u as tensors,ae as toString,t as typeOf,p as typedObjectLiteral,oe as valueOf,te as values,M as variables};
//# sourceMappingURL=recourse.min.js.map
