function e(e){if(e.length<3)return"{"+e+"}";for(var t=-1,n=2;n<e.length;n++)if("."===e[n]&&"."===e[n-1]&&(n<2||"\\"!==e[n-2])){if(t>-1)return"{"+e+"}";t=n-1}if(t>-1){var r=e.substr(0,t),s=e.substr(t+2);if(r.length>0&&s.length>0)return"["+e.substr(0,t)+"-"+e.substr(t+2)+"]"}return"{"+e+"}"}function t(n){if("string"!=typeof n)throw new TypeError("A pattern must be a string, but "+typeof n+" given");for(var r,s=!1,i=0,a=0,o=-1,c=[""],u=[],l=0;l<n.length;l++){var p=n[l];if("\\"!==p){if("{"===p)if(s)i++;else if(l>o&&!i){r=n.substring(o+1,l);for(var g=0;g<c.length;g++)c[g]+=r;u=[],o=l,s=!0,i++}else i--;else if("}"===p)if(s)a++;else if(1===a){if(r=n.substring(o+1,l),u.length>0){var f=[];u.push(t(r));for(g=0;g<c.length;g++)for(var d=0;d<u.length;d++)for(var h=0;h<u[d].length;h++)f.push(c[g]+u[d][h]);c=f}else{r=e(r);for(g=0;g<c.length;g++)c[g]+=r}o=l,a--}else a--;else s||","!==p||a-i!==1||(r=n.substring(o+1,l),u.push(t(r)),o=l);!s||a!==i&&l!==n.length-1||(s=!1,l=o-1)}else l++}if(-1===o)return[n];var b="{"===n[o]?o:o+1;if(b<n.length){r=n.substr(b);for(g=0;g<c.length;g++)c[g]+=r}return c}function n(e,t){var n,r=!1!==t["!"],s=!1!==t["()"],i=!1;if(r){for(n=0;n<e.length&&"!"===e[n];n++){if(s&&"("===e[n+1]){n--;break}i=!i}n>0&&(e=e.substr(n))}return{pattern:e,isNegated:i}}function r(e){return"-"===e||"^"===e||"$"===e||"+"===e||"."===e||"("===e||")"===e||"|"===e||"["===e||"]"===e||"{"===e||"}"===e||"*"===e||"?"===e||"\\"===e?"\\"+e:e}function s(e,t,n){var s=void 0===t.separator||t.separator,i="",a="",o=".";!0===s?(i="/",a="[/\\\\]",o="[^/\\\\]"):o=s?(a=function(e){for(var t="",n=0;n<e.length;n++)t+=r(e[n]);return t}(i=s)).length>1?"((?!"+(a="(?:"+a+")")+").)":"[^"+a+"]":".";var c=s?a+"+?":"",u=s?a+"*?":"",l=s?e.split(i):[e];return{source:e,segments:l,options:t,separator:s,separatorSplitter:i,separatorMatcher:a,optionalSeparator:u,requiredSeparator:c,wildcard:o,support:{qMark:!1!==t["?"],star:!1!==t["*"],globstar:s&&!1!==t["**"],brackets:!1!==t["[]"],extglobs:!1!==t["()"],excludeDot:n&&!1!==t.excludeDot}}}function i(e,t,n,r){return{source:e,isFirst:n,isLast:r,end:e.length-1}}var a="(?!\\.)";function o(e,t,n){return e.addToUnmatch&&(e.result.unmatch+=t),e.addToMatch&&(n&&!e.dotHandled&&(t=a+t),e.dotHandled=!0,e.result.match+=t),e.result}function c(e,t,n){var s=e.support,i=function(e,t,n){return{pattern:e,segment:t,result:n,openingBracket:t.end+1,closingBracket:-1,openingParens:0,closingParens:0,parensHandledUntil:-1,extglobModifiers:[],scanningForParens:!1,escapeChar:!1,addToMatch:!0,addToUnmatch:e.support.extglobs,dotHandled:!1,i:-1,char:"",nextChar:""}}(e,t,n),c=t.isLast?e.optionalSeparator:e.requiredSeparator;if(s.excludeDot||(i.dotHandled=!0),-1===t.end)return t.isLast&&!t.isFirst?n:o(i,c);if(s.globstar&&"**"===t.source)return o(i,"(?:"+((i.dotHandled?"":a)+e.wildcard+"*?"+c)+")*?");for(;++i.i<=t.end;){if(i.char=i.segment.source[i.i],i.nextChar=i.i<t.end?t.source[i.i+1]:"","\\"===i.char){if(i.i<i.segment.end){i.escapeChar=!0;continue}i.char=""}e=i.pattern,t=i.segment;var u=i.char,l=i.i;if(e.support.brackets&&!i.scanningForParens){if(l>i.openingBracket&&l<=i.closingBracket){i.escapeChar?o(i,r(u)):l===i.closingBracket?(o(i,"]"),i.openingBracket=t.source.length):"-"===u&&l===i.closingBracket-1?o(i,"\\-"):"!"===u&&l===i.openingBracket+1?o(i,"^"):o(i,"]"===u?"\\]":u),i.escapeChar=!1;continue}if(l>i.openingBracket){"]"===u&&!i.escapeChar&&l>i.openingBracket+1&&l>i.closingBracket?(i.closingBracket=l,i.i=i.openingBracket,e.separator?o(i,"(?!"+e.separatorMatcher+")[",!0):o(i,"[",!0)):l===t.end&&(o(i,"\\["),i.i=i.openingBracket,i.openingBracket=t.source.length,i.closingBracket=t.source.length),i.escapeChar=!1;continue}if("["===u&&!i.escapeChar&&l>i.closingBracket&&l<t.end){i.openingBracket=l,i.escapeChar=!1;continue}}if(i.pattern.support.extglobs){var p=i.extglobModifiers,g=(u=i.char,i.nextChar);l=i.i;if("("!==g||i.escapeChar||"@"!==u&&"?"!==u&&"*"!==u&&"+"!==u&&"!"!==u){if(")"!==u||i.escapeChar){if("|"===u&&i.closingParens&&!i.scanningForParens&&!i.escapeChar){o(i,"|");continue}}else if(i.scanningForParens)i.closingParens++;else if(p.length){var f=p.pop();if("!"===f&&-1!==p.indexOf("!"))throw new Error("Nested negated extglobs aren't supported");o(i,")"+(f="!"===f||"@"===f?"":f)),i.addToMatch=!0,i.addToUnmatch=!0,i.closingParens--;continue}}else if(i.scanningForParens)i.openingParens++;else if(l>i.parensHandledUntil&&!i.closingParens)i.parensHandledUntil=l,i.scanningForParens=!0,i.openingParens++;else{if(i.closingParens>=i.openingParens){"!"===u&&(i.addToMatch=!0,i.addToUnmatch=!1,o(i,i.pattern.wildcard+"*?",!0),i.addToMatch=!1,i.addToUnmatch=!0,i.result.useUnmatch=!0),p.push(u),o(i,"(?:",!0),i.openingParens--,i.i++;continue}i.openingParens--}if(i.scanningForParens){i.closingParens!==i.openingParens&&l!==i.segment.end||(i.scanningForParens=!1,i.i=i.parensHandledUntil-1),i.escapeChar=!1;continue}}s=(e=i.pattern).support;!i.escapeChar&&s.star&&"*"===i.char?i.i!==i.segment.end&&"*"===i.nextChar||o(i,e.wildcard+"*?",!0):!i.escapeChar&&s.qMark&&"?"===i.char?o(i,e.wildcard,!0):o(i,r(i.char)),i.escapeChar=!1}return o(i,c)}function u(e,t,n){for(var r=s(e,t,n),a={match:"",unmatch:"",useUnmatch:!1},o=r.segments,u=0;u<o.length;u++){c(r,i(o[u],0,0===u,u===o.length-1),a)}return a.useUnmatch?"(?!^"+a.unmatch+"$)"+a.match:a.match}function l(e,t){if("string"!=typeof t)throw new TypeError("Sample must be a string, but "+typeof t+" given");return e.test(t)}function p(e,r){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("The first argument must be a single pattern string or an array of patterns, but "+typeof e+" given");if("string"!=typeof r&&"boolean"!=typeof r||(r={separator:r}),2===arguments.length&&void 0!==r&&("object"!=typeof r||null===r||Array.isArray(r)))throw new TypeError("The second argument must be an options object or a string/boolean separator, but "+typeof r+" given");if("\\"===(r=r||{}).separator)throw new Error("\\ is not a valid separator");var s=function(e,r){e=Array.isArray(e)?e:[e],!1!==r["{}"]&&(e=function(e,t){for(var n=[],r=0;r<e.length;r++)for(var s=t(e[r]),i=0;i<s.length;i++)n.push(s[i]);return n}(e,t));for(var s=[],i=[],a="",o=0;o<e.length;o++){var c=n(e[o],r),l=u(c.pattern,r,!c.isNegated);c.isNegated?i.push(l):s.push(l)}return i.length&&(a="(?!(?:"+i.join("|")+")$)"),s.length>1?a+="(?:"+s.join("|")+")":1===s.length?a+=s[0]:a.length&&(a+=u("**",r,!0)),"^"+a+"$"}(e,r),i=new RegExp(s,r.flags),a=l.bind(null,i);return a.options=r,a.pattern=e,a.regexp=i,a}function g(e,t){const n=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,r=[];let s;for(;null!==(s=n.exec(e));)s[1]?r.push(s[1]):s[2]?t?r.push(parseInt(s[2],10)):r.push(s[2]):s[3]?r.push(s[3]):s[4]&&r.push(s[4]);return r}var f=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const d={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},h=Object.keys(d),b=Object.values(d),y={object:Object,array:Array,eventtarget:EventTarget,map:Map},O=Object.keys(y),j=Object.values(y),v=Object.assign({},d,y),m=Object.keys(v),P=Object.values(v),k=[d.String,d.Number,d.Boolean,y.Object,y.Array];var w=Object.freeze({__proto__:null,ObjectKeys:O,ObjectValues:j,Objects:y,PrimitiveKeys:h,PrimitiveValues:b,Primitives:d,TypeKeys:m,TypeMethods:k,TypeValues:P,Types:v});const M={Object:function(...e){if(1===e.length){const[t]=e;return t}{const[t,n]=e;return t[n]}},Map:function(...e){if(1===e.length){let[t]=e;return t}{let[t,n]=e;return t.get(n)}}},x={Object:function(...e){if(["string","number"].includes(f(e[1]))){const[t,n,r]=e;return t[n]=r,t[n]}{const[t,n]=e;for(const e of Object.keys(t))delete t[e];for(const[e,r]of Object.entries(n))t[e]=r;return t}},Map:function(...e){if(2===e.length){let[t,n]=e;t.clear();const r="map"===f(n)?n.entries():Object.entries(n);for(const[e,n]of r)t.set(e,n);return t}{let[t,n,r]=e;return t.set(n,r),t.get(n)}}},C={Object:function(...e){const[t,n]=e;if(["string","number"].includes(f(n)))return delete t[n];for(const e of Object.keys(t))delete t[e]},Map:function(...e){if(2===e.length){let[t,n]=e;return t.delete(n)}{let[t]=e;return t.clear()}}},T={Object:e=>!(e instanceof Map)&&["array","object"].includes(typeof e),Map:e=>e instanceof Map};function D(e,...t){const{typeValidators:n}=this,r=this[e],[s]=t;let i=0;for(const e of n){if(e(s))return r[i](...t);if(i++,i===n.length)throw new Error(null)}}class B extends EventTarget{constructor(e){super();const{typeValidators:t,getters:n,setters:r,deleters:s}=e;Object.defineProperties(this,{typeValidators:{value:t},getters:{value:n},setters:{value:r},deleters:{value:s}})}get get(){return Object.defineProperty(this,"get",{value:D.bind(this,"getters")}).get}get set(){return Object.defineProperty(this,"set",{value:D.bind(this,"setters")}).set}get delete(){return Object.defineProperty(this,"delete",{value:D.bind(this,"deleters")}).delete}}var A=Object.freeze({__proto__:null,Deleters:C,Getters:M,Setters:x,TensorProxy:B,TypeValidators:T});function z(e,t={}){const n=Object.assign({},t),r={},s=f(e),i=["array","object"].includes(s)?Object.keys(Object.getOwnPropertyDescriptors(e)):"map"==s?Array.from(e.keys()):[];for(const t of i){const s=N(e,t,n);s&&(r[t]=s)}return r}var L={delimiter:".",path:!1,pathMatch:!1,pathMatchMax:100,pathParseInteger:!1,getters:[M.Object,M.Map],setters:[x.Object,x.Map],deleters:[C.Object,C.Map],typeValidators:[T.Object,T.Map],enumerable:!0,nonenumerable:!1,values:!1,returnValue:"receiver",recurse:!0,depth:0,maxDepth:10,frozen:!1,sealed:!1,type:!1,typeCoercion:!1,strict:!0};function N(e,t,n={}){const r=Object.assign({},L,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++,r.ancestors.includes(e)||r.ancestors.unshift(e);const s=new B(r).get(e,t);if(void 0!==s){if(O.includes(f(s))){if(r.ancestors.includes(s))return;r.ancestors.unshift(s)}const n=f(e),i="map"!==n?Object.getOwnPropertyDescriptor(e,t):"map"===n?{configurable:!1,enumerable:!0,value:s[1],writable:!0}:void 0;if(!i)return;if(!r.nonenumerable&&!i.enumerable)return;return r.path&&(r.path="string"===f(r.path)?[r.path,t].join(r.delimiter):t,i.path=r.path),r.type&&(i.type=f(s)),r.frozen&&(i.frozen=Object.isFrozen(s)),r.sealed&&(i.sealed=Object.isSealed(s)),r.recurse&&O.includes(f(s))?i.value=z(s,r):i.value=s,i}}function I(e,t,n={}){const r=[],s=Object.assign({},L,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:i,maxDepth:a,enumerable:o,nonenumerable:c,recurse:u}=s;if(s.depth>=a)return r;i.includes(e)||i.unshift(e),s.depth++;const l=new B(s),p=l.get(e);if(!p)return r;const g="map"===f(p)?p.keys():c?Object.keys(Object.getOwnPropertyDescriptors(p)):Object.keys(p);for(let n of g){!isNaN(n)&&s.pathParseInteger&&(n=parseInt(n,10));const a=l.get(e,n),p=N(e,n,Object.assign({},s,{recurse:!1}));if(p&&(o&&p.enumerable||c&&!p.enumerable)){const e=f(a);if(u&&O.includes(e)&&!i.includes(a)){i.unshift(a);const e=I(a,t,s);e.length?"entries"===t?r.push([n,e]):"values"===t?r.push(e):"keys"===t&&r.push(n,e):"entries"===t?r.push([n,a]):"values"===t?r.push(a):"keys"===t&&r.push(n)}else"entries"===t?r.push([n,a]):"values"===t?r.push(a):"keys"===t&&r.push(n)}}return r}function S(e,t={}){const n=[],r=Object.assign({},L,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:s,maxDepth:i,values:a}=r;if(r.depth++,r.depth>i)return n;const o=new B(r).get(e);s.includes(e)||s.unshift(e);const c=I(e,"entries",Object.assign({},r,{recurse:!1}));for(const[e,t]of c)if(a?a&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,o)&&!s.includes(t)){const s=S(t,r);if(a){if(a)for(const[t,r]of s){const s=[e,t].join(".");n.push([s,r])}}else for(const t of s){const r=[e,t].join(".");n.push(r)}}return n}function U(){const[e,t,n]=[...arguments],r=Object.assign({},L,n),s=new B(r);if(void 0===t)return s.get(e,r);const i=g(t,r.pathParseInteger);if(r.pathMatch){const n=[],s=S(e,Object.assign({},r,{values:!0})),i=p(t,{separator:"."});for(const[e,t]of s){!0===i(e)&&n.push([e,t])}return n}{let t=e;e:for(const e of i)try{if(t=s.get(t,e),void 0===t)break e}catch(e){break e}return t}}function E(e,t){const n=Object.assign({},L,t);let r;const s=f(e);if("array"===s)r=!0;else if("object"===s&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of I(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const F={strict:!0};function V(e,t){const n=Object.assign({},F,t);let r;const s=f(e);if("map"===s)r=!0;else if("object"===s&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of I(e,"entries",{nonenumerable:!0,recurse:!1})){if(!E(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}function _(e,t=!0){let n;const r=f(e);if("string"===r){const t=e.toLowerCase();if("object"===t)return Object();if("array"===t)return Array();if("map"===t)return new Map;n={}}else{if("object"===r)return Object();if(E(e,{strict:t}))return Array();if(V(e,{strict:t}))return new Map;n={}}}function H(){const e=[...arguments],[t,n,r,s]=e,i=Object.assign({},L,s),a=new B(i);if(i.pathMatch){const e=[],s=S(t,Object.assign({},i,{values:!0})),a=p(n,{separator:"."});for(const[n,o]of s){!0===a(n,{separator:"."})&&(H(t,n,r,{pathMatch:!1,pathParseInteger:i.pathParseInteger}),e.push([n,r]))}return e}if("string"===f(e[1])){const{enumerable:e,nonenumerable:s}=i,o=(a.get(t),g(n,i.pathParseInteger)),c=o.pop();let u=t;e:for(const e of o)if(u=a.get(u,e,i)||a.set(u,e,isNaN(e)?{}:[]),void 0===u)break e;return a.set(u,c,r,i),t}{const[t,n]=e;return t}}function $(e,t,n){const r=Object.assign({},L,n),s=new B(r);if(r.pathMatch){const n=[],s=S(e,Object.assign({},r,{values:!0})),i=p(t,{separator:"."});for(const[t,a]of s){!0===i(t,{separator:"."})&&($(e,t,{pathMatch:!1,pathParseInteger:r.pathParseInteger}),n.push([t,void 0]))}return n}{const n=g(t,r.pathParseInteger),i=n.pop(),a=U(e,n.join("."),r)||e;s.delete(a,i)}}const q=["string","function"];function K(e,t,n={}){const r=Object.assign({},n),s=f(t),i=f(e);if(!q.includes(s)||!O.includes(i))return e;let a=_(e);for(const[n,i]of I(e,"entries",Object.assign({},r,{recurse:!1}))){const e=O.includes(f(i))?K(i,t,r):i;s===q[0]?a[n]=H({},t,e,r):s===q[1]&&(a[n]=t(e))}return a}function Z(e,t,n={}){const r=Object.assign({},L,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:s,values:i}=r;if(r.depth>r.maxDepth)return;r.depth++;const a=new B(r).get(e);s.includes(a)||s.unshift(a);const o=f(t);let c=_(e);for(const[n,s]of I(e,"entries",Object.assign({},r,{recurse:!1})))"string"===o?c[n]=U(s,t):"function"===o&&(c[n]=t(s)),c[n]&&"object"==typeof c[n]&&(c[n]=Z(c[n],t));return c}function G(e,t){const n=Object.assign({},L,t),r="object"===f(e)?I(e,"entries",Object.assign({},n,{recurse:!1})):e;if(r){for(const[t,s]of r)H(e,t,s,n);return e}}function J(e,t,...n){if(!e)return e;const r=Object.assign({},L),s=new B(r),i=f(e);e:for(const r of n){if(!O.includes(f(r)))continue e;const n=I(r,"entries",{recurse:!1});for(const[r,a]of n){const n=s.get(e,r),o=f(n),c=f(a);"array"===i&&"assignConcat"===t?s.set(e,e.length,a):O.includes(c)&&O.includes(o)?J(n,t,a):s.set(e,r,a)}}return e}var R=(e,...t)=>J(e,"assign",...t),Q=(e,...t)=>J(e,"assignConcat",...t);function W(e,t,n,r){const s=Object.assign({},n);let i=s.value;const a=Object.assign({},L,r),o=f(s.value),c=e[t],u=f(c);if(O.includes(o))if(O.includes(u))s.value=X(c,i,a);else{const e=_(E(Object.defineProperties({},i))?"array":"object");s.value=X(e,i,a)}else a.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(s,"type")&&!["undefined"].includes(o)&&(s.value=new d[s.type](i));return Object.defineProperty(e,t,s),n.sealed&&Object.seal(e[t]),n.frozen&&Object.freeze(e[t]),e}function X(e,t,n){for(const[r,s]of Object.entries(t))W(e,r,s,n);return e}function Y(e,t={}){const n=Object.assign({},L,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:s}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new B(n).get(e);r.includes(i)||r.unshift(i);const a=I(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of a)r.includes(t)||O.includes(f(t))&&Y(t,n);return Object.freeze(e)}function ee(e,t={}){const n=Object.assign({},L,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:s}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new B(n).get(e);r.includes(i)||r.unshift(i);const a=I(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of a)r.includes(t)||O.includes(f(t))&&ee(t,n);return Object.seal(e)}var te=(e,t)=>I(e,"keys",t),ne=(e,t)=>I(e,"values",t),re=(e,t)=>I(e,"entries",t);function se(e,t={}){const n=Object.assign({},L,t);return new B(n).get(e)}const ie={space:0,replacer:null};function ae(e,t){const n=Object.assign({},ie,t);return JSON.stringify(se(e,n),n.replacer,n.space)}class oe extends EventTarget{#e;#t;static compand=S;static decompand=G;static expand=K;static impand=Z;static keys=te;static values=ne;static entries=re;static entities=I;static get=U;static set=H;static delete=$;static assign=R;static assignConcat=Q;static defineProperties=X;static defineProperty=W;static freeze=Y;static seal=ee;static getOwnPropertyDescriptors=z;static getOwnPropertyDescriptor=N;static isArrayLike=E;static isMapLike=V;static typeOf=f;static toString=ae;static valueOf=se;get toString(){return Object.defineProperty(this,$staticMethodName,{value:$staticMethod.bind(null,this.#e,this.#t)})}get compand(){return Object.defineProperty(this,"compand",{value:oe.compand.bind(null,this.#e)}).compand}get decompand(){return Object.defineProperty(this,"decompand",{value:oe.decompand.bind(null,this.#e)}).decompand}get expand(){return Object.defineProperty(this,"expand",{value:oe.expand.bind(null,this.#e)}).expand}get impand(){return Object.defineProperty(this,"impand",{value:oe.impand.bind(null,this.#e)}).impand}get entities(){return Object.defineProperty(this,"entities",{value:oe.entities.bind(null,this.#e)}).entities}get keys(){return Object.defineProperty(this,"keys",{value:oe.keys.bind(null,this.#e)}).keys}get values(){return Object.defineProperty(this,"values",{value:oe.values.bind(null,this.#e)}).values}get entries(){return Object.defineProperty(this,"entries",{value:oe.entries.bind(null,this.#e)}).entries}get get(){return Object.defineProperty(this,"get",{value:oe.get.bind(null,this.#e)}).get}get set(){return Object.defineProperty(this,"set",{value:oe.set.bind(null,this.#e)}).set}get delete(){return Object.defineProperty(this,"delete",{value:oe.delete.bind(null,this.#e)}).delete}get assign(){return Object.defineProperty(this,"assign",{value:oe.assign.bind(null,this.#e)}).assign}get assignConcat(){return Object.defineProperty(this,"assignConcat",{value:oe.assignConcat.bind(null,this.#e)}).assignConcat}get defineProperties(){return Object.defineProperty(this,"defineProperties",{value:oe.defineProperties.bind(null,this.#e)}).defineProperties}get defineProperty(){return Object.defineProperty(this,"defineProperty",{value:oe.defineProperty.bind(null,this.#e)}).defineProperty}get freeze(){return Object.defineProperty(this,"freeze",{value:oe.freeze.bind(null,this.#e)}).freeze}get seal(){return Object.defineProperty(this,"seal",{value:oe.seal.bind(null,this.#e)}).seal}get getOwnPropertyDescriptors(){return Object.defineProperty(this,"getOwnPropertyDescriptors",{value:oe.getOwnPropertyDescriptors.bind(null,this.#e)}).getOwnPropertyDescriptors}get getOwnPropertyDescriptor(){return Object.defineProperty(this,"getOwnPropertyDescriptor",{value:oe.getOwnPropertyDescriptor.bind(null,this.#e)}).getOwnPropertyDescriptor}get isArrayLike(){return Object.defineProperty(this,"isArrayLike",{value:oe.isArrayLike.bind(null,this.#e)}).isArrayLike}get isMapLike(){return Object.defineProperty(this,"isMapLike",{value:oe.isMapLike.bind(null,this.#e)}).isMapLike}get typeOf(){return Object.defineProperty(this,"typeOf",{value:oe.typeOf.bind(null,this.#e)}).typeOf}constructor(e,t={}){super(),this.#e=e,this.#t=t}}export{oe as Recourse,A as Tensors,w as Variables,R as assign,Q as assignConcat,S as compand,G as decompand,X as defineProperties,W as defineProperty,$ as delete,I as entities,re as entries,K as expand,Y as freeze,U as get,N as getOwnPropertyDescriptor,z as getOwnPropertyDescriptors,Z as impand,E as isArrayLike,te as keys,ee as seal,H as set,g as splitPath,ae as toString,f as typeOf,_ as typedObjectLiteral,se as valueOf,ne as values};
//# sourceMappingURL=recourse.min.js.map
