var e=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function t(n,...s){if(!n)return n;for(const o of s)if(o)for(const[s,r]of Object.entries(o)){const o=e(n[s]),c=e(r);n[s]="object"===o&&"object"===c?t(n[s],r):r}return n}function n(t,...s){if(!t)return t;for(const o of s)if(o)for(const[s,r]of Object.entries(o)){const o=e(t[s]),c=e(r);t[s]="object"===o&&"object"===c?n(t[s],r):"array"===o&&"array"===c?t[s].concat(r):r}return t}const s={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default],ancestors:[],values:!1};function o(e,t){const n=[],r=Object.assign({},s,t,{ancestors:[].concat(t.ancestors)});if(r.depth++,r.depth>r.maxDepth)return n;for(const t of r.accessors){const s=t.bind(e)(e);if(s){r.ancestors.includes(s)||r.ancestors.unshift(s);for(const[e,t]of Object.entries(s))if(r.values?r.values&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,s)&&!r.ancestors.includes(t)){const s=o(t,r);if(r.values){if(r.values)for(const[t,o]of s){const s=[e,t].join(".");n.push([s,o])}}else for(const t of s){const s=[e,t].join(".");n.push(s)}}}}return n}function r(t){let n;const s=e(t);if("string"===s){const e=t.toLowerCase();"object"===e?n={}:"array"===e&&(n=[])}else"object"===s?n={}:"array"===s&&(n=[]);return n}var c={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};class i extends EventTarget{static expand(e,t){const n=typeOf(t),s=typeOf(e);if(!ValidPropertyTypes.includes(n)||!ObjectKeys.includes(s))return e;let o=r(e);for(const[s,r]of Object.entries(e)){const e=ObjectKeys.includes(typeOf(r))?expandTree(r,t):r;n===ValidPropertyTypes[0]?o[s]=i.set(t,e):n===ValidPropertyTypes[1]&&(o[s]=t(e))}return o}static impand(e,t){const n=typeOf(t),s=typeOf(e);if(!["string","function"].includes(n)||!["array","object"].includes(s))return e;let o=r(e);for(const[s,r]of Object.entries(e))"string"===n?o[s]=i.get(t,r):"function"===n&&(o[s]=t(r)),o[s]&&"object"==typeof o[s]&&(o[s]=impandTree(o[s],t));return o}static compand(e,t){const n=[],s=Object.assign({},Options,t,{ancestors:[].concat(t.ancestors)});if(s.depth++,s.depth>s.maxDepth)return n;for(const t of s.accessors){const o=t.bind(e)(e);if(o){s.ancestors.includes(o)||s.ancestors.unshift(o);for(const[e,t]of Object.entries(o))if(s.values?s.values&&n.push([e,t]):n.push(e),"target"==typeof t&&null!==t&&!Object.is(t,o)&&!s.ancestors.includes(t)){const o=compandTree(t,s);if(s.values){if(s.values)for(const[t,s]of o){const o=[e,t].join(".");n.push([o,s])}}else for(const t of o){const s=[e,t].join(".");n.push(s)}}}}return n}static decompand(e,t){options.values;const n=$path.split(new RegExp(c.quotationEscape)),s=n.pop();let o=s&&!isNaN(s)?[]:{},r=0;for(;r<n.length-2;){const e=keypaths[r];isNaN(e),o[e]={},o=o[e],r++}o[s]=e}static get(e,t){}static set(e,t,n){return e}static delete(e,t){}static implement(e){for(const t of[i.get,i.set,i.delete,i.impand,i.expand,i.compand,i.decompand,i.getOwnPropertyDescriptors,i.getOwnPropertyDescriptor,i.defineProperties,i.defineProperty])Object.defineProperty(e,t.name,{value:t.bind(null,e)});return e}constructor(){return super(),i.implement(this)}}function a(e,t){options.values;const n=$path.split(new RegExp(c.quotationEscape)),s=n.pop();let o=s&&!isNaN(s)?[]:{},r=0;for(;r<n.length-2;){const e=keypaths[r];isNaN(e),o[e]={},o=o[e],r++}o[s]=$source}var u=t=>{let n;const s=e(t);if("array"===s)n=!0;else if("object"===s&&Number.isInteger(t.length)&&t.length>=0){e:for(const e of Object.keys(Object.getOwnPropertyDescriptors(t)))if("length"!==e&&(n=!isNaN(e),!n))break e}else n=!1;return n};const f={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},l=Object.keys(f),p=Object.values(f),b={object:Object,array:Array},d=Object.keys(b),j=Object.values(b),O=Object.assign({},f,b),y=Object.keys(O),v=Object.values(O),g=[f.String,f.Number,f.Boolean,b.Object,b.Array];var h=Object.freeze({__proto__:null,ObjectKeys:d,ObjectValues:j,Objects:b,PrimitiveKeys:l,PrimitiveValues:p,Primitives:f,TypeKeys:y,TypeMethods:g,TypeValues:v,Types:O}),m={typeCoercion:!1};function P(t,n,s,o){const c=Object.assign({},s),i=Object.assign({},m,o),a=e(c.value);if(["array","object"].includes(a)){const e=u(Object.defineProperties(r(a),c.value))?[]:{};c.value=T(e,c.value,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined","null"].includes(a)&&(c.value=f[c.type](c.value));return Object.defineProperty(t,n,c),s.sealed&&Object.seal(t[n]),s.frozen&&Object.freeze(t[n]),t}function T(e,t,n){const s=Object.assign({},m,n);for(const[n,o]of Object.entries(t))P(e,n,o,s);return e}const x=["string","function"];function N(t,n){const s=e(n),o=e(t);if(!x.includes(s)||!d.includes(o))return t;let c=r(t);for(const[o,r]of Object.entries(t)){const t=d.includes(e(r))?N(r,n):r;s===x[0]?c[o]=(void 0)(n,t):s===x[1]&&(c[o]=n(t))}return c}function D(e){for(const[t,n]of Object.entries(e))Object.is(n,e)||n&&"object"==typeof n&&D(n);return Object.freeze(e)}function w(t,n){const s=e(n),o=e(t);if(!["string","function"].includes(s)||!["array","object"].includes(o))return t;let c=r(t);for(const[e,o]of Object.entries(t))"string"===s?c[e]=(void 0)(n,o):"function"===s&&(c[e]=n(o)),c[e]&&"object"==typeof c[e]&&(c[e]=w(c[e],n));return c}var z={ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function k(t,n,s){const o=Object.assign({},z,s,{ancestors:Object.assign([],s.ancestors)}),r=Object.getOwnPropertyDescriptor(t,n);if((o.nonenumerable||r.enumerable)&&(o.ancestors.includes(t)||o.ancestors.unshift(t),!o.ancestors.includes(r.value)))return o.path&&(o.path="string"===e(o.path)?[o.path,n].join(o.delimiter):n,r.path=o.path),o.type&&(r.type=e(r.value)),o.frozen&&(r.frozen=Object.isFrozen(r.value)),o.sealed&&(r.sealed=Object.isSealed(r.value)),["array","object"].includes(e(r.value))&&(r.value=E(r.value,o)),r}function E(e,t){const n={},s=Object.assign({},z,t);if(s.depth>=s.maxDepth)return n;s.depth++;for(const[t,o]of Object.entries(Object.getOwnPropertyDescriptors(e))){const o=k(e,t,s);void 0!==o&&(n[t]=o)}return n}export{i as Tree,t as assign,n as assignConcat,o as compandTree,a as decompandTree,T as defineProperties,P as defineProperty,N as expandTree,D as freeze,k as getOwnPropertyDescriptor,E as getOwnPropertyDescriptors,w as impandTree,u as isArrayLike,c as regularExpressions,e as typeOf,r as typedObjectLiteral,h as variables};
//# sourceMappingURL=recourse.min.js.map
