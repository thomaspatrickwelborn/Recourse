var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/,quotationStartStop:/^"(.*)"$/},t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const{quotationEscape:s,quotationStartStop:n}=e;function r(s){const n=t(s);if("string"===n){const t=s.split(new RegExp(e.quotationEscape));let n=0;for(;n<t.length;)t[n]=t[n].replace(new RegExp(e.quotationStartStop),"$1"),n++;return t}if("number"===n)return[s]}const c={Object:function(...e){const s=e[0];if(["object","array"].includes(t(s))){if("string"===t(e[1])){return s[e[1]]}return s}},Map:function(...e){if("map"===t(e[0])){if("string"===t(e[1])){let[t,s,n]=e;n=n||{returnValue:"target"};let{returnValue:r}=n;return"target"===r?t.get(s):"receiver"===r?t[s]:"entry"===r?[s,t.get(s)]:void 0}{let[t,s]=e;s=s||{returnValue:"target"};let{returnValue:n}=s;return"target"===n?Object.fromEntries(t):"receiver"===n?t:"entry"===n?Array.from(t):t}}}},i={Object:function(...e){if(["object","array"].includes(t(e[0]))){if("string"===t(e[1])){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,s]of Object.entries(source))t[e]=s;return t}}},Map:function(...e){if("map"===t(e[0])){if("string"===t(e[1])){let[t,s,n,r]=e;r=r||{returnValue:"target"};let{returnValue:c}=r;return t.set(s,n,c),t.get(s,c)}{let[t,s,n]=e;n=n||{returnValue:"target"};let{returnValue:r}=n;t.clear();for(const[e,s]of Object.entries(source))t.set(e,s);return t}}}},o={Object:function(...e){if(["object","array"].includes(t(e[0]))){if("string"===t(e[1]))return delete $target[$property];for(const e of Object.keys($target))delete $target[e]}else;},Map:function(...e){const s=e.length;if("map"===t(e[0])){if(2===s){let[t,s]=e;return t.delete(s)}if(1===s){let[t]=e;return t.clear()}}}};class a extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}var u=Object.freeze({__proto__:null,Deleters:o,Getters:c,Setters:i,Tensors:a});const f={getters:[c.Object,c.Map]};function l(){const[e,t,s]=[...arguments];if(void 0===t)return arguments[0];const n=Object.assign({},f,s),c=new a(n.getters),i=r(t);let o=e;e:for(const e of i)try{if(o=c.cess(o,e,n),void 0===o)break e}catch(e){break e}return o}function p(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();s="object"===t?{}:"array"===t?[]:{}}else s="object"===n?{}:"array"===n?[]:{};return s}const b={getters:[c.Object,c.Map],setters:[i.Object,i.Map]};function g(){const e=[...arguments];if("string"===t(e[1])){const[t,s,n,c]=e,i=Object.assign({},b,c),o=new a(i.getters),u=new a(i.setters),{enumerable:f,nonenumerable:l}=i,p=(o.cess(t,i),r(s)),g=p.pop();let d=t;e:for(const e of p)if(d=o.cess(d,e,i)||u.cess(d,e,isNaN(e)?{}:[],i),void 0===d)break e;return u.cess(d,g,n,i),t}{const[t,s]=e;return t}}const d={deleters:[o.Object,o.Map],returnValue:"target"};function j(e,t,s){const n=Object.assign({},d,s),c=new a(n.deleters),i=r(t),o=i.pop(),u=l(e,i.join("."),n)||e;c.cess(u,o,n)}const O={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},y=Object.keys(O),h=Object.values(O),m={object:Object,array:Array,map:Map},v=Object.keys(m),k=Object.values(m),w=Object.assign({},O,m),D=Object.keys(w),P=Object.values(w),x=[O.String,O.Number,O.Boolean,m.Object,m.Array];var M=Object.freeze({__proto__:null,ObjectKeys:v,ObjectValues:k,Objects:m,PrimitiveKeys:y,PrimitiveValues:h,Primitives:O,TypeKeys:D,TypeMethods:x,TypeValues:P,Types:w});const z={getters:[c.Object,c.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0,returnValue:"target"};function V(e,s,n){const r=[],c=Object.assign({},z,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:i,maxDepth:o,enumerable:u,nonenumerable:f,recurse:l}=c;if(c.depth>=o)return;i.includes(e)||i.push(e);const p=new a(c.getters).cess(e,Object.assign(c,{returnValue:"target"}));c.depth++;for(const[e,n]of Object.entries(Object.getOwnPropertyDescriptors(p)))if(u&&n.enumerable||f&&!n.enumerable){const o=n.value,a=t(o);l&&v.includes(a)&&!i.includes(o)?"entries"===s?r.push([e,V(o,s,c)]):"values"===s?r.push(V(o,s,c)):"keys"===s&&r.push(e,V(o,s,c)):"entries"===s?r.push([e,o]):"values"===s?r.push(o):"keys"===s&&r.push(e)}return r}const S=["string","function"];function E(e,s,n={}){const r=Object.assign({},n),c=t(s),i=t(e);if(!S.includes(c)||!v.includes(i))return e;let o=p(e);for(const[n,i]of V(e,"entries",Object.assign({},r,{recurse:!1}))){const e=v.includes(t(i))?E(i,s):i;c===S[0]?o[n]=g({},s,e,r):c===S[1]&&(o[n]=s(e))}return o}const L={ancestors:[],getters:[c.Object,c.Map],depth:0,maxDepth:10};function N(e,s,n={}){const r=Object.assign({},L,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,values:i}=r;if(r.depth>r.maxDepth)return;r.depth++;const o=new a(r.getters).cess(e,r);c.includes(o)||c.unshift(o);const u=t(s);let f=p(e);for(const[t,n]of V(e,"entries",Object.assign({},r,{recurse:!1})))"string"===u?f[t]=l(n,s):"function"===u&&(f[t]=s(n)),f[t]&&"object"==typeof f[t]&&(f[t]=N(f[t],s));return f}const A={depth:0,getters:[c.Object,c.Map],maxDepth:10,values:!1};function C(e,t){const s=[],n=Object.assign({},A,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:c}=n;if(n.depth++,n.depth>n.maxDepth)return s;const i=new a(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const o=V(i,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of o)if(c?c&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!r.includes(t)){const r=C(t,n);if(c){if(c)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const _={setters:[i.Object,i.Map]};function T(e,s){const n=Object.assign({},_,s),r="object"===t(e)?V(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)g(c,e,t,n);return c}const $={getters:[c.Object,c.Map],setters:[i.Object,i.Map]};function q(e,s,...n){if(!e)return e;const r=Object.assign({},$),c=(new a(r.getters),new a(r.setters)),i=t(e);e:for(const o of n){if(!v.includes(t(o)))continue e;const n=V(o,"entries",{recurse:!1});console.log("sourceEntries",n);for(const[o,a]of n){const n=e[o],u=t(n);t(a);"array"===i&&"assignConcat"===s?e.push(a):v.includes(u)?q(n,s,a):c.cess(e,o,a,r)}}return e}var B=(e,...t)=>q(e,"assign",...t),I=(e,...t)=>q(e,"assignConcat",...t);const K={strict:!0};function R(e,s){const n=Object.assign({},K,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of V(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const F={typeCoercion:!1};function G(e,s,n,r){const c=Object.assign({},n);let i=c.value;const o=Object.assign({},F,r),a=t(c.value),u=e[s],f=t(u);if(v.includes(a))if(v.includes(f))c.value=J(u,i,o);else{const e=p(R(Object.defineProperties({},i))?"array":"object");c.value=J(e,i,o)}else o.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined"].includes(a)&&(c.value=O[c.type](i));return Object.defineProperty(e,s,c),n.sealed&&Object.seal(e[s]),n.frozen&&Object.freeze(e[s]),e}function J(e,t,s){for(const[n,r]of Object.entries(t))G(e,n,r,s);return e}const H={ancestors:[],depth:0,maxDepth:10};function Q(e,s={}){const n=Object.assign({},H,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new a(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const o=V(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of o)r.includes(s)||v.includes(t(s))&&Q(s,n);return Object.freeze(e)}const U={ancestors:[],depth:0,maxDepth:10};function W(e,s={}){const n=Object.assign({},U,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new a(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const o=V(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of o)r.includes(s)||v.includes(t(s))&&W(s,n);return Object.seal(e)}const X={strict:!0};function Y(e,s){const n=Object.assign({},X,s);let r;const c=t(e);if("map"===c)r=!0;else if("object"===c&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of V(e,"entries",{nonenumerable:!0,recurse:!1})){if(!R(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}const Z={strict:!0,isArrayLike:!1};function ee(e,s){const n=Object.assign({},Z,s);if("array"!==t(e)){if(!n.isArrayLike||!R(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var te=(e,t)=>V(e,"keys",t),se=(e,t)=>V(e,"values",t),ne=(e,t)=>V(e,"entries",t);const re={getters:[c.Object,c.Map],delimiter:".",depth:0,frozen:!1,nonenumerable:!0,path:!1,sealed:!1,type:!1};function ce(e,s,n={}){const r=Object.assign({},re,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++;const c=new a(r.getters).cess(e,s,r);if(c){const n=Object.getOwnPropertyDescriptor(e,s);if(!r.nonenumerable&&!n.enumerable)return;if(r.ancestors.includes(e)||r.ancestors.unshift(e),r.ancestors.includes(c))return;return r.path&&(r.path="string"===t(r.path)?[r.path,s].join(r.delimiter):s,n.path=r.path),r.type&&(n.type=t(c)),r.frozen&&(n.frozen=Object.isFrozen(c)),r.sealed&&(n.sealed=Object.isSealed(c)),v.includes(t(c))&&(n.value=ie(c,r)),n}}function ie(e,t){const s={};for(const[n,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=ce(e,n,t);r&&(s[n]=r)}return s}const oe={ancestors:[],depth:0,maxDepth:10,getters:[c.Object,c.Map]};function ae(e,s={}){const n=Object.assign({},oe,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,maxDepth:c}=n;if(n.depth>=c)return;n.depth++;const i=new a(n.getters).cess(e,n);if(void 0===i)return;r.includes(e)||r.unshift(e);const o=p(t(i)),u=V(e,"entries",{recurse:!1});e:for(const[e,s]of u){let c;if(v.includes(t(s))){if(r.includes(s))continue e;c=ae(s,n)}else c=s;try{o[e]=c}catch(e){console.error(e)}}return o}const ue={space:0,replacer:null};function fe(e,t){const s=Object.assign({},ue,t);return JSON.stringify(ae(e,s),s.replacer,s.space)}class le extends EventTarget{static compand=C;static decompand=T;static expand=E;static impand=N;static keys=te;static values=se;static entries=ne;static entities=V;static get=l;static set=g;static delete=j;static assign=B;static assignConcat=I;static defineProperties=J;static defineProperty=G;static freeze=Q;static seal=W;static getOwnPropertyDescriptors=ie;static getOwnPropertyDescriptor=ce;static isArrayLike=R;static isMapLike=Y;static isEntries=ee;static typeOf=t;static toString=fe;static valueOf=ae;constructor(e){super();for(const[t,s]of Object.entries({compand:le.compand,decompand:le.decompand,expand:le.expand,impand:le.impand,entities:le.entities,keys:le.keys,values:le.values,entries:le.entries,get:le.get,set:le.set,delete:le.delete,assign:le.assign,assignConcat:le.assignConcat,defineProperties:le.defineProperties,defineProperty:le.defineProperty,freeze:le.freeze,seal:le.seal,getOwnPropertyDescriptors:le.getOwnPropertyDescriptors,getOwnPropertyDescriptor:le.getOwnPropertyDescriptor,isArrayLike:le.isArrayLike,isEntries:le.isEntries,isMapLike:le.isMapLike,typeOf:le.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{le as Recourse,B as assign,I as assignConcat,C as compand,T as decompand,J as defineProperties,G as defineProperty,j as delete,V as entities,ne as entries,E as expand,Q as freeze,l as get,ce as getOwnPropertyDescriptor,ie as getOwnPropertyDescriptors,N as impand,R as isArrayLike,ee as isEntries,te as keys,e as regularExpressions,W as seal,g as set,r as splitPath,u as tensors,fe as toString,t as typeOf,p as typedObjectLiteral,ae as valueOf,se as values,M as variables};
//# sourceMappingURL=recourse.min.js.map
