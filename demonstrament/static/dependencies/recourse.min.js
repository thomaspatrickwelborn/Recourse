function e(e){if(e.length<3)return"{"+e+"}";for(var t=-1,r=2;r<e.length;r++)if("."===e[r]&&"."===e[r-1]&&(r<2||"\\"!==e[r-2])){if(t>-1)return"{"+e+"}";t=r-1}if(t>-1){var n=e.substr(0,t),s=e.substr(t+2);if(n.length>0&&s.length>0)return"["+e.substr(0,t)+"-"+e.substr(t+2)+"]"}return"{"+e+"}"}function t(r){if("string"!=typeof r)throw new TypeError("A pattern must be a string, but "+typeof r+" given");for(var n,s=!1,a=0,i=0,o=-1,c=[""],u=[],l=0;l<r.length;l++){var p=r[l];if("\\"!==p){if("{"===p)if(s)a++;else if(l>o&&!a){n=r.substring(o+1,l);for(var f=0;f<c.length;f++)c[f]+=n;u=[],o=l,s=!0,a++}else a--;else if("}"===p)if(s)i++;else if(1===i){if(n=r.substring(o+1,l),u.length>0){var g=[];u.push(t(n));for(f=0;f<c.length;f++)for(var d=0;d<u.length;d++)for(var h=0;h<u[d].length;h++)g.push(c[f]+u[d][h]);c=g}else{n=e(n);for(f=0;f<c.length;f++)c[f]+=n}o=l,i--}else i--;else s||","!==p||i-a!==1||(n=r.substring(o+1,l),u.push(t(n)),o=l);!s||i!==a&&l!==r.length-1||(s=!1,l=o-1)}else l++}if(-1===o)return[r];var b="{"===r[o]?o:o+1;if(b<r.length){n=r.substr(b);for(f=0;f<c.length;f++)c[f]+=n}return c}function r(e,t){var r,n=!1!==t["!"],s=!1!==t["()"],a=!1;if(n){for(r=0;r<e.length&&"!"===e[r];r++){if(s&&"("===e[r+1]){r--;break}a=!a}r>0&&(e=e.substr(r))}return{pattern:e,isNegated:a}}function n(e){return"-"===e||"^"===e||"$"===e||"+"===e||"."===e||"("===e||")"===e||"|"===e||"["===e||"]"===e||"{"===e||"}"===e||"*"===e||"?"===e||"\\"===e?"\\"+e:e}function s(e,t,r){var s=void 0===t.separator||t.separator,a="",i="",o=".";!0===s?(a="/",i="[/\\\\]",o="[^/\\\\]"):o=s?(i=function(e){for(var t="",r=0;r<e.length;r++)t+=n(e[r]);return t}(a=s)).length>1?"((?!"+(i="(?:"+i+")")+").)":"[^"+i+"]":".";var c=s?i+"+?":"",u=s?i+"*?":"",l=s?e.split(a):[e];return{source:e,segments:l,options:t,separator:s,separatorSplitter:a,separatorMatcher:i,optionalSeparator:u,requiredSeparator:c,wildcard:o,support:{qMark:!1!==t["?"],star:!1!==t["*"],globstar:s&&!1!==t["**"],brackets:!1!==t["[]"],extglobs:!1!==t["()"],excludeDot:r&&!1!==t.excludeDot}}}function a(e,t,r,n){return{source:e,isFirst:r,isLast:n,end:e.length-1}}var i="(?!\\.)";function o(e,t,r){return e.addToUnmatch&&(e.result.unmatch+=t),e.addToMatch&&(r&&!e.dotHandled&&(t=i+t),e.dotHandled=!0,e.result.match+=t),e.result}function c(e,t,r){var s=e.support,a=function(e,t,r){return{pattern:e,segment:t,result:r,openingBracket:t.end+1,closingBracket:-1,openingParens:0,closingParens:0,parensHandledUntil:-1,extglobModifiers:[],scanningForParens:!1,escapeChar:!1,addToMatch:!0,addToUnmatch:e.support.extglobs,dotHandled:!1,i:-1,char:"",nextChar:""}}(e,t,r),c=t.isLast?e.optionalSeparator:e.requiredSeparator;if(s.excludeDot||(a.dotHandled=!0),-1===t.end)return t.isLast&&!t.isFirst?r:o(a,c);if(s.globstar&&"**"===t.source)return o(a,"(?:"+((a.dotHandled?"":i)+e.wildcard+"*?"+c)+")*?");for(;++a.i<=t.end;){if(a.char=a.segment.source[a.i],a.nextChar=a.i<t.end?t.source[a.i+1]:"","\\"===a.char){if(a.i<a.segment.end){a.escapeChar=!0;continue}a.char=""}e=a.pattern,t=a.segment;var u=a.char,l=a.i;if(e.support.brackets&&!a.scanningForParens){if(l>a.openingBracket&&l<=a.closingBracket){a.escapeChar?o(a,n(u)):l===a.closingBracket?(o(a,"]"),a.openingBracket=t.source.length):"-"===u&&l===a.closingBracket-1?o(a,"\\-"):"!"===u&&l===a.openingBracket+1?o(a,"^"):o(a,"]"===u?"\\]":u),a.escapeChar=!1;continue}if(l>a.openingBracket){"]"===u&&!a.escapeChar&&l>a.openingBracket+1&&l>a.closingBracket?(a.closingBracket=l,a.i=a.openingBracket,e.separator?o(a,"(?!"+e.separatorMatcher+")[",!0):o(a,"[",!0)):l===t.end&&(o(a,"\\["),a.i=a.openingBracket,a.openingBracket=t.source.length,a.closingBracket=t.source.length),a.escapeChar=!1;continue}if("["===u&&!a.escapeChar&&l>a.closingBracket&&l<t.end){a.openingBracket=l,a.escapeChar=!1;continue}}if(a.pattern.support.extglobs){var p=a.extglobModifiers,f=(u=a.char,a.nextChar);l=a.i;if("("!==f||a.escapeChar||"@"!==u&&"?"!==u&&"*"!==u&&"+"!==u&&"!"!==u){if(")"!==u||a.escapeChar){if("|"===u&&a.closingParens&&!a.scanningForParens&&!a.escapeChar){o(a,"|");continue}}else if(a.scanningForParens)a.closingParens++;else if(p.length){var g=p.pop();if("!"===g&&-1!==p.indexOf("!"))throw new Error("Nested negated extglobs aren't supported");o(a,")"+(g="!"===g||"@"===g?"":g)),a.addToMatch=!0,a.addToUnmatch=!0,a.closingParens--;continue}}else if(a.scanningForParens)a.openingParens++;else if(l>a.parensHandledUntil&&!a.closingParens)a.parensHandledUntil=l,a.scanningForParens=!0,a.openingParens++;else{if(a.closingParens>=a.openingParens){"!"===u&&(a.addToMatch=!0,a.addToUnmatch=!1,o(a,a.pattern.wildcard+"*?",!0),a.addToMatch=!1,a.addToUnmatch=!0,a.result.useUnmatch=!0),p.push(u),o(a,"(?:",!0),a.openingParens--,a.i++;continue}a.openingParens--}if(a.scanningForParens){a.closingParens!==a.openingParens&&l!==a.segment.end||(a.scanningForParens=!1,a.i=a.parensHandledUntil-1),a.escapeChar=!1;continue}}s=(e=a.pattern).support;!a.escapeChar&&s.star&&"*"===a.char?a.i!==a.segment.end&&"*"===a.nextChar||o(a,e.wildcard+"*?",!0):!a.escapeChar&&s.qMark&&"?"===a.char?o(a,e.wildcard,!0):o(a,n(a.char)),a.escapeChar=!1}return o(a,c)}function u(e,t,r){for(var n=s(e,t,r),i={match:"",unmatch:"",useUnmatch:!1},o=n.segments,u=0;u<o.length;u++){c(n,a(o[u],0,0===u,u===o.length-1),i)}return i.useUnmatch?"(?!^"+i.unmatch+"$)"+i.match:i.match}function l(e,t){if("string"!=typeof t)throw new TypeError("Sample must be a string, but "+typeof t+" given");return e.test(t)}function p(e,n){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("The first argument must be a single pattern string or an array of patterns, but "+typeof e+" given");if("string"!=typeof n&&"boolean"!=typeof n||(n={separator:n}),2===arguments.length&&void 0!==n&&("object"!=typeof n||null===n||Array.isArray(n)))throw new TypeError("The second argument must be an options object or a string/boolean separator, but "+typeof n+" given");if("\\"===(n=n||{}).separator)throw new Error("\\ is not a valid separator");var s=function(e,n){e=Array.isArray(e)?e:[e],!1!==n["{}"]&&(e=function(e,t){for(var r=[],n=0;n<e.length;n++)for(var s=t(e[n]),a=0;a<s.length;a++)r.push(s[a]);return r}(e,t));for(var s=[],a=[],i="",o=0;o<e.length;o++){var c=r(e[o],n),l=u(c.pattern,n,!c.isNegated);c.isNegated?a.push(l):s.push(l)}return a.length&&(i="(?!(?:"+a.join("|")+")$)"),s.length>1?i+="(?:"+s.join("|")+")":1===s.length?i+=s[0]:i.length&&(i+=u("**",n,!0)),"^"+i+"$"}(e,n),a=new RegExp(s,n.flags),i=l.bind(null,a);return i.options=n,i.pattern=e,i.regexp=a,i}function f(e,t){const r=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,n=[];let s;for(;null!==(s=r.exec(e));)s[1]?n.push(s[1]):s[2]?t?n.push(parseInt(s[2],10)):n.push(s[2]):s[3]?n.push(s[3]):s[4]&&n.push(s[4]);return n}var g=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const d={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},h=Object.keys(d),b=Object.values(d),y={object:Object,array:Array,eventtarget:EventTarget,map:Map},O=Object.keys(y),j=Object.values(y),v=Object.assign({},d,y),m=Object.keys(v),P=Object.values(v),k=[d.String,d.Number,d.Boolean,y.Object,y.Array];var w=Object.freeze({__proto__:null,ObjectKeys:O,ObjectValues:j,Objects:y,PrimitiveKeys:h,PrimitiveValues:b,Primitives:d,TypeKeys:m,TypeMethods:k,TypeValues:P,Types:v});const M={Object:function(...e){if(1===e.length){const[t]=e;return t}{const[t,r]=e;return t[r]}},Map:function(...e){if(1===e.length){let[t]=e;return t}{let[t,r]=e;return t.get(r)}}},x={Object:function(...e){if(["string","number"].includes(g(e[1]))){const[t,r,n]=e;return t[r]=n,t[r]}{const[t,r]=e;for(const e of Object.keys(t))delete t[e];for(const[e,n]of Object.entries(r))t[e]=n;return t}},Map:function(...e){if(2===e.length){let[t,r]=e;t.clear();const n="map"===g(r)?r.entries():Object.entries(r);for(const[e,r]of n)t.set(e,r);return t}{let[t,r,n]=e;return t.set(r,n),t.get(r)}}},C={Object:function(...e){const[t,r]=e;if(["string","number"].includes(g(r)))return delete t[r];for(const e of Object.keys(t))delete t[e]},Map:function(...e){if(2===e.length){let[t,r]=e;return t.delete(r)}{let[t]=e;return t.clear()}}},T={Object:e=>!(e instanceof Map)&&["array","object"].includes(typeof e),Map:e=>e instanceof Map};class D extends EventTarget{constructor(e,t){super(),Object.defineProperties(this,{cess:{value:function(...r){const[n]=r;let s=0;for(const a of t){if(a(n))return e[s](...r);if(s++,s===t.length)throw new Error(null)}}}})}}var B=Object.freeze({__proto__:null,Deleters:C,Getters:M,Setters:x,Tensors:D,TypeValidators:T});function V(e,t={}){const r=Object.assign({},t),n={},s=g(e),a=["array","object"].includes(s)?Object.keys(Object.getOwnPropertyDescriptors(e)):"map"==s?Array.from(e.keys()):[];for(const t of a){const s=z(e,t,r);s&&(n[t]=s)}return n}var A={delimiter:".",path:!1,pathMatch:!1,pathMatchMax:100,pathParseInteger:!1,getters:[M.Object,M.Map],setters:[x.Object,x.Map],deleters:[C.Object,C.Map],typeValidators:[T.Object,T.Map],enumerable:!0,nonenumerable:!1,values:!1,returnValue:"receiver",recurse:!0,depth:0,maxDepth:10,frozen:!1,sealed:!1,type:!1,typeCoercion:!1,strict:!0};function z(e,t,r={}){const n=Object.assign({},A,r,{ancestors:Object.assign([],r.ancestors)});if(n.depth>=n.maxDepth)return;n.depth++,n.ancestors.includes(e)||n.ancestors.unshift(e);const s=new D(n.getters,n.typeValidators).cess(e,t);if(void 0!==s){if(O.includes(g(s))){if(n.ancestors.includes(s))return;n.ancestors.unshift(s)}const r=g(e),a="map"!==r?Object.getOwnPropertyDescriptor(e,t):"map"===r?{configurable:!1,enumerable:!0,value:s[1],writable:!0}:void 0;if(!a)return;if(!n.nonenumerable&&!a.enumerable)return;return n.path&&(n.path="string"===g(n.path)?[n.path,t].join(n.delimiter):t,a.path=n.path),n.type&&(a.type=g(s)),n.frozen&&(a.frozen=Object.isFrozen(s)),n.sealed&&(a.sealed=Object.isSealed(s)),n.recurse&&O.includes(g(s))?a.value=V(s,n):a.value=s,a}}function N(e,t,r={}){const n=[],s=Object.assign({},A,r,{ancestors:Object.assign([],r.ancestors)}),{ancestors:a,maxDepth:i,enumerable:o,nonenumerable:c,recurse:u}=s;if(s.depth>=i)return n;a.includes(e)||a.unshift(e),s.depth++;const l=new D(s.getters,s.typeValidators),p=l.cess(e);if(!p)return n;const f="map"===g(p)?p.keys():c?Object.keys(Object.getOwnPropertyDescriptors(p)):Object.keys(p);for(let r of f){!isNaN(r)&&s.pathParseInteger&&(r=parseInt(r,10));const i=l.cess(e,r),p=z(e,r,Object.assign({},s,{recurse:!1}));if(p&&(o&&p.enumerable||c&&!p.enumerable)){const e=g(i);if(u&&O.includes(e)&&!a.includes(i)){a.unshift(i);const e=N(i,t,s);e.length?"entries"===t?n.push([r,e]):"values"===t?n.push(e):"keys"===t&&n.push(r,e):"entries"===t?n.push([r,i]):"values"===t?n.push(i):"keys"===t&&n.push(r)}else"entries"===t?n.push([r,i]):"values"===t?n.push(i):"keys"===t&&n.push(r)}}return n}function L(e,t={}){const r=[],n=Object.assign({},A,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:s,values:a}=n;if(n.depth++,n.depth>n.maxDepth)return r;const i=new D(n.getters,n.typeValidators).cess(e);s.includes(e)||s.unshift(e);const o=N(e,"entries",Object.assign({},n,{recurse:!1}));for(const[e,t]of o)if(a?a&&r.push([e,t]):r.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!s.includes(t)){const s=L(t,n);if(a){if(a)for(const[t,n]of s){const s=[e,t].join(".");r.push([s,n])}}else for(const t of s){const n=[e,t].join(".");r.push(n)}}return r}function I(){const[e,t,r]=[...arguments],n=Object.assign({},A,r),s=new D(n.getters,n.typeValidators);if(void 0===t)return s.cess(e,n);const a=f(t,n.pathParseInteger);if(n.pathMatch){const r=[],s=L(e,Object.assign({},n,{values:!0})),a=p(t,{separator:"."});for(const[e,t]of s){!0===a(e)&&r.push([e,t])}return r}{let t=e;e:for(const e of a)try{if(t=s.cess(t,e),void 0===t)break e}catch(e){break e}return t}}function S(e,t){const r=Object.assign({},A,t);let n;const s=g(e);if("array"===s)n=!0;else if("object"===s&&e.length>=0&&Number.isInteger(e.length))if(!1===r.strict)n=!0;else{e:for(const t of N(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){n=!0;break e}}void 0===n&&(n=!1)}else n=!1;return n}const U={strict:!0};function E(e,t){const r=Object.assign({},U,t);let n;const s=g(e);if("map"===s)n=!0;else if("object"===s&&e.size>=0&&Number.isInteger(e.size))if(!1===r.strict)n=!0;else{e:for(const t of N(e,"entries",{nonenumerable:!0,recurse:!1})){if(!S(t,r)&&2!==t.length){n=!1;break e}n=!0}void 0===n&&(n=!1)}else n=!1;return n}function F(e,t=!0){let r;const n=g(e);if("string"===n){const t=e.toLowerCase();if("object"===t)return Object();if("array"===t)return Array();if("map"===t)return new Map;r={}}else{if("object"===n)return Object();if(S(e,{strict:t}))return Array();if(E(e,{strict:t}))return new Map;r={}}}function _(){const e=[...arguments],[t,r,n,s]=e,a=Object.assign({},A,s),i=new D(a.getters,a.typeValidators),o=new D(a.setters,a.typeValidators);if(a.pathMatch){const e=[],s=L(t,Object.assign({},a,{values:!0})),i=p(r,{separator:"."});for(const[r,o]of s){!0===i(r,{separator:"."})&&(_(t,r,n,{pathMatch:!1,pathParseInteger:a.pathParseInteger}),e.push([r,n]))}return e}if("string"===g(e[1])){const{enumerable:e,nonenumerable:s}=a,c=(i.cess(t),f(r,a.pathParseInteger)),u=c.pop();let l=t;e:for(const e of c)if(l=i.cess(l,e,a)||o.cess(l,e,isNaN(e)?{}:[]),void 0===l)break e;return o.cess(l,u,n,a),t}{const[t,r]=e;return t}}function H(e,t,r){const n=Object.assign({},A,r),s=new D(n.deleters,n.typeValidators);if(n.pathMatch){const r=[],s=L(e,Object.assign({},n,{values:!0})),a=p(t,{separator:"."});for(const[t,i]of s){!0===a(t,{separator:"."})&&(H(e,t,{pathMatch:!1,pathParseInteger:n.pathParseInteger}),r.push([t,void 0]))}return r}{const r=f(t,n.pathParseInteger),a=r.pop(),i=I(e,r.join("."),n)||e;s.cess(i,a)}}const $=["string","function"];function q(e,t,r={}){const n=Object.assign({},r),s=g(t),a=g(e);if(!$.includes(s)||!O.includes(a))return e;let i=F(e);for(const[r,a]of N(e,"entries",Object.assign({},n,{recurse:!1}))){const e=O.includes(g(a))?q(a,t,n):a;s===$[0]?i[r]=_({},t,e,n):s===$[1]&&(i[r]=t(e))}return i}function K(e,t,r={}){const n=Object.assign({},A,r,{ancestors:Object.assign([],r.ancestors)}),{ancestors:s,values:a}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new D(n.getters,n.typeValidators).cess(e);s.includes(i)||s.unshift(i);const o=g(t);let c=F(e);for(const[r,s]of N(e,"entries",Object.assign({},n,{recurse:!1})))"string"===o?c[r]=I(s,t):"function"===o&&(c[r]=t(s)),c[r]&&"object"==typeof c[r]&&(c[r]=K(c[r],t));return c}function Z(e,t){const r=Object.assign({},A,t),n="object"===g(e)?N(e,"entries",r):e;if(!n)return;const s=isNaN(n[0][0])?{}:[];for(const[e,t]of n)_(s,e,t,r);return s}function G(e,t,...r){if(!e)return e;const n=Object.assign({},A),s=new D(n.getters,n.typeValidators),a=new D(n.setters,n.typeValidators),i=g(e);e:for(const n of r){if(!O.includes(g(n)))continue e;const r=N(n,"entries",{recurse:!1});for(const[n,o]of r){const r=s.cess(e,n),c=g(r),u=g(o);"array"===i&&"assignConcat"===t?a.cess(e,e.length,o):O.includes(u)&&O.includes(c)?G(r,t,o):a.cess(e,n,o)}}return e}var J=(e,...t)=>G(e,"assign",...t),R=(e,...t)=>G(e,"assignConcat",...t);function Q(e,t,r,n){const s=Object.assign({},r);let a=s.value;const i=Object.assign({},A,n),o=g(s.value),c=e[t],u=g(c);if(O.includes(o))if(O.includes(u))s.value=W(c,a,i);else{const e=F(S(Object.defineProperties({},a))?"array":"object");s.value=W(e,a,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(s,"type")&&!["undefined"].includes(o)&&(s.value=new d[s.type](a));return Object.defineProperty(e,t,s),r.sealed&&Object.seal(e[t]),r.frozen&&Object.freeze(e[t]),e}function W(e,t,r){for(const[n,s]of Object.entries(t))Q(e,n,s,r);return e}function X(e,t={}){const r=Object.assign({},A,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:n,values:s}=r;if(r.depth>r.maxDepth)return;r.depth++;const a=new D(r.getters,r.typeValidators).cess(e);n.includes(a)||n.unshift(a);const i=N(e,"entries",Object.assign(r,{recurse:!1}));for(const[e,t]of i)n.includes(t)||O.includes(g(t))&&X(t,r);return Object.freeze(e)}function Y(e,t={}){const r=Object.assign({},A,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:n,values:s}=r;if(r.depth>r.maxDepth)return;r.depth++;const a=new D(r.getters,r.typeValidators).cess(e);n.includes(a)||n.unshift(a);const i=N(e,"entries",Object.assign(r,{recurse:!1}));for(const[e,t]of i)n.includes(t)||O.includes(g(t))&&Y(t,r);return Object.seal(e)}var ee=(e,t)=>N(e,"keys",t),te=(e,t)=>N(e,"values",t),re=(e,t)=>N(e,"entries",t);function ne(e,t={}){const r=Object.assign({},A,t);new D(r.getters,r.typeValidators).cess(e);return e}const se={space:0,replacer:null};function ae(e,t){const r=Object.assign({},se,t);return JSON.stringify(ne(e,r),r.replacer,r.space)}class ie extends EventTarget{#e;#t;static compand=L;static decompand=Z;static expand=q;static impand=K;static keys=ee;static values=te;static entries=re;static entities=N;static get=I;static set=_;static delete=H;static assign=J;static assignConcat=R;static defineProperties=W;static defineProperty=Q;static freeze=X;static seal=Y;static getOwnPropertyDescriptors=V;static getOwnPropertyDescriptor=z;static isArrayLike=S;static isMapLike=E;static typeOf=g;static toString=ae;static valueOf=ne;get toString(){return Object.defineProperty(this,$staticMethodName,{value:$staticMethod.bind(null,this.#e,this.#t)})}get compand(){return Object.defineProperty(this,"compand",{value:ie.compand.bind(null,this.#e)}).compand}get decompand(){return Object.defineProperty(this,"decompand",{value:ie.decompand.bind(null,this.#e)}).decompand}get expand(){return Object.defineProperty(this,"expand",{value:ie.expand.bind(null,this.#e)}).expand}get impand(){return Object.defineProperty(this,"impand",{value:ie.impand.bind(null,this.#e)}).impand}get entities(){return Object.defineProperty(this,"entities",{value:ie.entities.bind(null,this.#e)}).entities}get keys(){return Object.defineProperty(this,"keys",{value:ie.keys.bind(null,this.#e)}).keys}get values(){return Object.defineProperty(this,"values",{value:ie.values.bind(null,this.#e)}).values}get entries(){return Object.defineProperty(this,"entries",{value:ie.entries.bind(null,this.#e)}).entries}get get(){return Object.defineProperty(this,"get",{value:ie.get.bind(null,this.#e)}).get}get set(){return Object.defineProperty(this,"set",{value:ie.set.bind(null,this.#e)}).set}get delete(){return Object.defineProperty(this,"delete",{value:ie.delete.bind(null,this.#e)}).delete}get assign(){return Object.defineProperty(this,"assign",{value:ie.assign.bind(null,this.#e)}).assign}get assignConcat(){return Object.defineProperty(this,"assignConcat",{value:ie.assignConcat.bind(null,this.#e)}).assignConcat}get defineProperties(){return Object.defineProperty(this,"defineProperties",{value:ie.defineProperties.bind(null,this.#e)}).defineProperties}get defineProperty(){return Object.defineProperty(this,"defineProperty",{value:ie.defineProperty.bind(null,this.#e)}).defineProperty}get freeze(){return Object.defineProperty(this,"freeze",{value:ie.freeze.bind(null,this.#e)}).freeze}get seal(){return Object.defineProperty(this,"seal",{value:ie.seal.bind(null,this.#e)}).seal}get getOwnPropertyDescriptors(){return Object.defineProperty(this,"getOwnPropertyDescriptors",{value:ie.getOwnPropertyDescriptors.bind(null,this.#e)}).getOwnPropertyDescriptors}get getOwnPropertyDescriptor(){return Object.defineProperty(this,"getOwnPropertyDescriptor",{value:ie.getOwnPropertyDescriptor.bind(null,this.#e)}).getOwnPropertyDescriptor}get isArrayLike(){return Object.defineProperty(this,"isArrayLike",{value:ie.isArrayLike.bind(null,this.#e)}).isArrayLike}get isMapLike(){return Object.defineProperty(this,"isMapLike",{value:ie.isMapLike.bind(null,this.#e)}).isMapLike}get typeOf(){return Object.defineProperty(this,"typeOf",{value:ie.typeOf.bind(null,this.#e)}).typeOf}constructor(e,t={}){super(),this.#e=e,this.#t=t}}export{ie as Recourse,B as Tensors,w as Variables,J as assign,R as assignConcat,L as compand,Z as decompand,W as defineProperties,Q as defineProperty,H as delete,N as entities,re as entries,q as expand,X as freeze,I as get,z as getOwnPropertyDescriptor,V as getOwnPropertyDescriptors,K as impand,S as isArrayLike,ee as keys,Y as seal,_ as set,f as splitPath,ae as toString,g as typeOf,F as typedObjectLiteral,ne as valueOf,te as values};
//# sourceMappingURL=recourse.min.js.map
