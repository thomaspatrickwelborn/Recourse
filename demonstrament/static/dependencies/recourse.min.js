function e(e){const t=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,s=[];let n;for(;null!==(n=t.exec(e));)n[1]?s.push(n[1]):n[2]?s.push(parseInt(n[2],10)):n[3]?s.push(n[3]):n[4]&&s.push(n[4]);return s}var t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const s={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},n=Object.keys(s),r=Object.values(s),c={object:Object,array:Array,map:Map},o=Object.keys(c),i=Object.values(c),a=Object.assign({},s,c),u=Object.keys(a),f=Object.values(a),l=[s.String,s.Number,s.Boolean,c.Object,c.Array];var p=Object.freeze({__proto__:null,ObjectKeys:o,ObjectValues:i,Objects:c,PrimitiveKeys:n,PrimitiveValues:r,Primitives:s,TypeKeys:u,TypeMethods:l,TypeValues:f,Types:a});const b={Object:function(...e){if(["object","array"].includes(t(e[0]))){if(1===e.length){const[t]=e;return t}{const[t,s]=e;return t[s]}}return this?.next(...e)},Map:function(...e){if("map"!==t(e[0]))return this?.next(...e);if(1===e.length){let[t]=e;return Object.fromEntries(t)}{let[t,s]=e;return t.get(s)}}},g={Object:function(...e){if(["object","array"].includes(t(e[0]))){if(["string","number"].includes(t(e[1]))){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,n]of Object.entries(s))t[e]=n;return t}}return this?.next(...e)},Map:function(...e){if("map"!==t(e[0]))return this?.next(...e);if(2===e.length){let[t,s]=e;t.clear();for(const[e,s]of Object.entries(source))t.set(e,s);return t}{let[t,s,n]=e;return t.set(s,n),t.get(s)}}},d={Object:function(...e){const[s,n]=e;if(!["object","array"].includes(t(s)))return this?.next(...e);if(["string","number"].includes(t(n)))return delete s[n];for(const e of Object.keys(s))delete s[e]},Map:function(...e){if(e.length,"map"!==t(e[0]))return this?.next(...e);if(2===e.length){let[t,s]=e;return t.delete(s)}{let[t]=e;return t.clear()}}};class j extends EventTarget{constructor(e){super();const t=e.map(((t,s)=>t.bind({next:e[s+1]})));Object.defineProperties(this,{cess:{value:function(){try{return t[0](...arguments)}catch(e){console.error(e)}}}})}}var O=Object.freeze({__proto__:null,Deleters:d,Getters:b,Setters:g,Tensors:j});const h={getters:[b.Object,b.Map]};function y(){const[t,s,n]=[...arguments];if(void 0===s)return arguments[0];const r=Object.assign({},h,n),c=new j(r.getters),o=e(s);let i=t;e:for(const e of o)try{if(i=c.cess(i,e,r),void 0===i)break e}catch(e){break e}return i}function m(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();s="object"===t?new Object:"array"===t?new Array:"map"===t?new Map:{}}else s="object"===n?new Object:"array"===n?new Array:"map"===value?new Map:{};return s}const v={getters:[b.Object,b.Map],setters:[g.Object,g.Map]};function w(){const s=[...arguments];if("string"===t(s[1])){const[t,n,r,c]=s,o=Object.assign({},v,c),i=new j(o.getters),a=new j(o.setters),{enumerable:u,nonenumerable:f}=o,l=(i.cess(t,o),e(n)),p=l.pop();let b=t;e:for(const e of l)if(b=i.cess(b,e,o)||a.cess(b,e,isNaN(e)?{}:[],o),void 0===b)break e;return a.cess(b,p,r,o),t}{const[e,t]=s;return e}}const x={deleters:[d.Object,d.Map],returnValue:"target"};function M(t,s,n){const r=Object.assign({},x,n),c=new j(r.deleters),o=e(s),i=o.pop(),a=y(t,o.join("."),r)||t;c.cess(a,i,r)}const D={getters:[b.Object,b.Map],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function k(e,t,s={}){const n=Object.assign({},D,s,{ancestors:Object.assign([],s.ancestors)});if(n.depth>=n.maxDepth)return;n.depth++;const r=new j(n.getters).cess(e,t,n);throw[t,r,n.returnValue]}function P(e,s={}){const n=Object.assign({},s),r="entries"!==n.returnValue?{}:[],c=t(e),o=["array","object"].includes(c)?Object.keys(Object.getOwnPropertyDescriptors(e)):"map"==c?Array.from(e.keys()):[];for(const t of o){const s=k(e,t,n);throw[e,t,s]}return r}const z={getters:[b.Object,b.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0,returnValue:"target"};function V(e,s,n={}){t(e);const r=Object.assign({},z,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,maxDepth:o,enumerable:i,nonenumerable:a,recurse:u}=r;if(r.depth>=o)return;c.includes(e)||c.unshift(e),r.depth++;throw P(e,{returnValue:"entries",recursive:!1})}const A=["string","function"];function N(e,s,n={}){const r=Object.assign({},n),c=t(s),i=t(e);if(!A.includes(c)||!o.includes(i))return e;let a=m(e);for(const[n,i]of V(e,0,Object.assign({},r,{recurse:!1}))){const e=o.includes(t(i))?N(i,s,r):i;c===A[0]?a[n]=w({},s,e,r):c===A[1]&&(a[n]=s(e))}return a}const _={ancestors:[],getters:[b.Object,b.Map],depth:0,maxDepth:10};function C(e,s,n={}){const r=Object.assign({},_,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,values:o}=r;if(r.depth>r.maxDepth)return;r.depth++;const i=new j(r.getters).cess(e,r);c.includes(i)||c.unshift(i);const a=t(s);let u=m(e);for(const[t,n]of V(e,0,Object.assign({},r,{recurse:!1})))"string"===a?u[t]=y(n,s):"function"===a&&(u[t]=s(n)),u[t]&&"object"==typeof u[t]&&(u[t]=C(u[t],s));return u}const L={depth:0,getters:[b.Object,b.Map],maxDepth:10,values:!1};function T(e,t){const s=[],n=Object.assign({},L,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:c}=n;if(n.depth++,n.depth>n.maxDepth)return s;const o=new j(n.getters).cess(e,n);r.includes(e)||r.unshift(e);const i=V(e,0,Object.assign(n,{recurse:!1}));for(const[e,t]of i)if(c?c&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,o)&&!r.includes(t)){const r=T(t,n);if(c){if(c)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const S={setters:[g.Object,g.Map]};function I(e,s){const n=Object.assign({},S,s),r="object"===t(e)?V(e,0,n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)w(c,e,t,n);return c}const B={getters:[b.Object,b.Map],setters:[g.Object,g.Map]};function E(e,s,...n){if(!e)return e;const r=Object.assign({},B),c=new j(r.getters),i=new j(r.setters),a=t(e);e:for(const r of n){if(!o.includes(t(r)))continue e;const n=V(r,0,{recurse:!1});for(const[r,u]of n){const n=c.cess(e,r),f=t(n),l=t(u);"array"===a&&"assignConcat"===s?i.cess(e,e.length,u):o.includes(l)&&o.includes(f)?E(n,s,u):i.cess(e,r,u)}}}var K=(e,...t)=>E(e,"assign",...t),Z=(e,...t)=>E(e,"assignConcat",...t);const G={strict:!0};function J(e,s){const n=Object.assign({},G,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of V(e,0,{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const q={typeCoercion:!1};function F(e,n,r,c){const i=Object.assign({},r);let a=i.value;const u=Object.assign({},q,c),f=t(i.value),l=e[n],p=t(l);if(o.includes(f))if(o.includes(p))i.value=H(l,a,u);else{const e=m(J(Object.defineProperties({},a))?"array":"object");i.value=H(e,a,u)}else u.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(i,"type")&&!["undefined"].includes(f)&&(i.value=s[i.type](a));return Object.defineProperty(e,n,i),r.sealed&&Object.seal(e[n]),r.frozen&&Object.freeze(e[n]),e}function H(e,t,s){for(const[n,r]of Object.entries(t))F(e,n,r,s);return e}const Q={getters:[b.Object,b.Map],ancestors:[],depth:0,maxDepth:10};function R(e,s={}){const n=Object.assign({},Q,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new j(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const a=V(e,0,Object.assign(n,{recurse:!1}));for(const[e,s]of a)r.includes(s)||o.includes(t(s))&&R(s,n);return Object.freeze(e)}const U={getters:[b.Object,b.Map],ancestors:[],depth:0,maxDepth:10};function W(e,s={}){const n=Object.assign({},U,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const i=new j(n.getters).cess(e,n);r.includes(i)||r.unshift(i);const a=V(e,0,Object.assign(n,{recurse:!1}));for(const[e,s]of a)r.includes(s)||o.includes(t(s))&&W(s,n);return Object.seal(e)}const X={strict:!0};function Y(e,s){const n=Object.assign({},X,s);let r;const c=t(e);if("map"===c)r=!0;else if("object"===c&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of V(e,0,{nonenumerable:!0,recurse:!1})){if(!J(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}var $=(e,t)=>V(e,0,t),ee=(e,t)=>V(e,0,t),te=(e,t)=>V(e,0,t);const se={ancestors:[],depth:0,maxDepth:10,getters:[b.Object,b.Map],returnValue:"receiver"};function ne(e,s={}){const n=Object.assign({},se,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,maxDepth:c,returnValue:i}=n;if(r.includes(e)||r.unshift(e),n.depth>=c)return;n.depth++;const a=new j(n.getters).cess(e,n);if(void 0===a)return;const u=m(t(a)),f=V(e,0,Object.assign({},n,{recurse:!1}));e:for(const[e,s]of f){let c;if(o.includes(t(s))){if(r.includes(s))continue e;r.unshift(s),c=ne(s,n)}else c=s;try{u[e]=c}catch(e){console.error(e)}}return u}const re={space:0,replacer:null,returnValue:"receiver"};function ce(e,t){const s=Object.assign({},re,t);return JSON.stringify(ne(e,s),s.replacer,s.space)}class oe extends EventTarget{static compand=T;static decompand=I;static expand=N;static impand=C;static keys=$;static values=ee;static entries=te;static entities=V;static get=y;static set=w;static delete=M;static assign=K;static assignConcat=Z;static defineProperties=H;static defineProperty=F;static freeze=R;static seal=W;static getOwnPropertyDescriptors=P;static getOwnPropertyDescriptor=k;static isArrayLike=J;static isMapLike=Y;static typeOf=t;static toString=ce;static valueOf=ne;constructor(e){super();for(const[t,s]of Object.entries({compand:oe.compand,decompand:oe.decompand,expand:oe.expand,impand:oe.impand,entities:oe.entities,keys:oe.keys,values:oe.values,entries:oe.entries,get:oe.get,set:oe.set,delete:oe.delete,assign:oe.assign,assignConcat:oe.assignConcat,defineProperties:oe.defineProperties,defineProperty:oe.defineProperty,freeze:oe.freeze,seal:oe.seal,getOwnPropertyDescriptors:oe.getOwnPropertyDescriptors,getOwnPropertyDescriptor:oe.getOwnPropertyDescriptor,isArrayLike:oe.isArrayLike,isMapLike:oe.isMapLike,typeOf:oe.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{oe as Recourse,K as assign,Z as assignConcat,T as compand,I as decompand,H as defineProperties,F as defineProperty,M as delete,V as entities,te as entries,N as expand,R as freeze,y as get,k as getOwnPropertyDescriptor,P as getOwnPropertyDescriptors,C as impand,J as isArrayLike,$ as keys,W as seal,w as set,e as splitPath,O as tensors,ce as toString,t as typeOf,m as typedObjectLiteral,ne as valueOf,ee as values,p as variables};
//# sourceMappingURL=recourse.min.js.map
