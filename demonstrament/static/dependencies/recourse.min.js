const e={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},t=Object.keys(e),n=Object.values(e),s={object:Object,array:Array},o=Object.keys(s),r=Object.values(s),c=Object.assign({},e,s),i=Object.keys(c),a=Object.values(c),u=[e.String,e.Number,e.Boolean,s.Object,s.Array];var f=Object.freeze({__proto__:null,ObjectKeys:o,ObjectValues:r,Objects:s,PrimitiveKeys:t,PrimitiveValues:n,Primitives:e,TypeKeys:i,TypeMethods:u,TypeValues:a,Types:c}),l=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function b(e){let t;const n=l(e);if("string"===n){const n=e.toLowerCase();"object"===n?t={}:"array"===n&&(t=[])}else"object"===n?t={}:"array"===n&&(t=[]);return t}var p={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};function j(e,t){const n=e.split(new RegExp(p.quotationEscape)),s=n.pop();let o=t;for(const e of n)o=o[e];return o[s]}function O(e,t){const n=e.split(new RegExp(p.quotationEscape)),s=n.pop(),o=s&&!isNaN(s)?[]:{};let r=o,c=0;for(;c<n.length-2;){const e=keypaths[c];isNaN(e),r[e]={},r=r[e],c++}return r[s]=t,o}const d=["string","function"];function y(e,t){const n=l(t),s=l(e);if(!d.includes(n)||!o.includes(s))return e;let r=b(e);for(const[s,c]of Object.entries(e)){const e=o.includes(l(c))?y(c,t):c;n===d[0]?r[s]=O(t,e):n===d[1]&&(r[s]=t(e))}return r}function v(e,t){const n=l(t),s=l(e);if(!["string","function"].includes(n)||!["array","object"].includes(s))return e;let o=b(e);for(const[s,r]of Object.entries(e))"string"===n?o[s]=j(t,r):"function"===n&&(o[s]=t(r)),o[s]&&"object"==typeof o[s]&&(o[s]=v(o[s],t));return o}var g=e=>{let t;const n=l(e);if("array"===n)t=!0;else if("object"===n&&Number.isInteger(e.length)&&e.length>=0){e:for(const n of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==n&&(t=!isNaN(n),!t))break e}else t=!1;return t};const h={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default],ancestors:[]};function m(e,t){const n=[],s=Object.assign({},h,t,{ancestors:[].concat(t.ancestors)});if(s.depth++,s.depth>s.maxDepth)return n;for(const t of s.accessors){const o=t.bind(e)(e);if(o){s.ancestors.includes(o)||s.ancestors.unshift(o);for(const[e,t]of Object.entries(o))if(s.values?s.values&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,o)&&!s.ancestors.includes(t)){const o=m(t,s);if(s.values){if(s.values)for(const[t,s]of o){const o=[e,t].join(".");n.push([o,s])}}else for(const t of o){const s=[e,t].join(".");n.push(s)}}}}return n}function N(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,s]of Object.entries(n)){const n=l(e[t]),o=l(s);e[t]="object"===n&&"object"===o?N(e[t],s):s}return e}function P(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,s]of Object.entries(n)){const n=l(e[t]),o=l(s);e[t]="object"===n&&"object"===o?P(e[t],s):"array"===n&&"array"===o?e[t].concat(s):s}return e}var w={ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function z(e,t,n){const s=Object.assign({},w,n,{ancestors:Object.assign([],n.ancestors)}),o=Object.getOwnPropertyDescriptor(e,t);if((s.nonenumerable||o.enumerable)&&(s.ancestors.includes(e)||s.ancestors.unshift(e),!s.ancestors.includes(o.value)))return s.path&&(s.path="string"===l(s.path)?[s.path,t].join(s.delimiter):t,o.path=s.path),s.type&&(o.type=l(o.value)),s.frozen&&(o.frozen=Object.isFrozen(o.value)),s.sealed&&(o.sealed=Object.isSealed(o.value)),["array","object"].includes(l(o.value))&&(o.value=D(o.value,s)),o}function D(e,t){const n={},s=Object.assign({},w,t);if(s.depth>=s.maxDepth)return n;s.depth++;for(const[t,o]of Object.entries(Object.getOwnPropertyDescriptors(e))){const o=z(e,t,s);void 0!==o&&(n[t]=o)}return n}var x={typeCoercion:!1};function k(t,n,s,o){const r=Object.assign({},s),c=Object.assign({},x,o),i=l(r.value);if(["array","object"].includes(i)){const e=g(Object.defineProperties(b(i),r.value))?[]:{};r.value=E(e,r.value,c)}else c.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(r,"type")&&!["undefined","null"].includes(i)&&(r.value=e[r.type](r.value));return Object.defineProperty(t,n,r),s.sealed&&Object.seal(t[n]),s.frozen&&Object.freeze(t[n]),t}function E(e,t,n){const s=Object.assign({},x,n);for(const[n,o]of Object.entries(t))k(e,n,o,s);return e}function C(e){for(const[t,n]of Object.entries(e))Object.is(n,e)||n&&"object"==typeof n&&C(n);return Object.freeze(e)}export{N as assign,P as assignConcat,m as compandTree,E as defineProperties,k as defineProperty,y as expandTree,C as freeze,z as getOwnPropertyDescriptor,D as getOwnPropertyDescriptors,v as impandTree,g as isArrayLike,p as regularExpressions,l as typeOf,b as typedObjectLiteral,f as variables};
//# sourceMappingURL=recourse.min.js.map
