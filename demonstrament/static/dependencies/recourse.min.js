var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/,quotationStartStop:/^"(.*)"$/},t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const{quotationEscape:s,quotationStartStop:n}=e;function r(s){const n=t(s);if("string"===n){const t=s.split(new RegExp(e.quotationEscape));let n=0;for(;n<t.length;)t[n]=t[n].replace(new RegExp(e.quotationStartStop),"$1"),n++;return t}if("number"===n)return[s]}const c={Object:function(...e){const s=e[0];if(["object","array"].includes(t(s))){if("string"===t(e[1])){return s[e[1]]}return s}},Map:function(...e){if("map"===t(e[0])){if("string"===t(e[1])){let[s,n,r]=e;r=r||{returnTarget:!0};let{returnTarget:c}=r;return"boolean"!==t(c)||c?s.get(n):s[n]}{let[s,n]=e;n=n||{returnTarget:!0};let{returnTarget:r}=n;return"boolean"!==t(r)||r?Array.from(s.entries()):s}}}},o={Object:function(...e){if(["object","array"].includes(t(e[0]))){if("string"===t(e[1])){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,s]of Object.entries(source))t[e]=s;return t}}},Map:function(...e){if("map"===t(e[0])){if("string"===t(e[1])){let[s,n,r,c]=e;c=c||{returnTarget:!0};let{returnTarget:o}=c;return o="boolean"!==t(o)||o,s.set(n,r,o),s.get(n,o)}{let[s,n,r]=e;r=r||{returnTarget:!0};let{returnTarget:c}=r;c="boolean"!==t(c)||c,s.clear();for(const[e,t]of Object.entries(source))s.set(e,t);return s}}}},i={Object:function(...e){if(["object","array"].includes(t(e[0]))){if("string"===t(e[1]))return delete $target[$property];for(const e of Object.keys($target))delete $target[e]}else;},Map:function(...e){console.log(e);const s=e.length;if("map"===t(e[0])){if(2===s){let[t,s]=e;return t.delete(s)}if(1===s){let[t]=e;return t.clear()}}}};class a extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}var u=Object.freeze({__proto__:null,Deleters:i,Getters:c,Setters:o,Tensors:a});const f={getters:[c.Object,c.Map]};function l(){const[e,t,s]=[...arguments];if(void 0===t)return arguments[0];const n=Object.assign({},f,s),c=new a(n.getters),o=r(t);let i=e;e:for(const e of o)try{if(i=c.cess(i,e,n),void 0===i)break e}catch(e){break e}return i}function p(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();"object"===t?s={}:"array"===t&&(s=[])}else"object"===n?s={}:"array"===n&&(s=[]);return s}const b={getters:[c.Object,c.Map],setters:[o.Object,o.Map]};function g(){const e=[...arguments];if("string"===t(e[1])){const[t,s,n,c]=e,o=Object.assign({},b,c),i=new a(o.getters),u=new a(o.setters),{enumerable:f,nonenumerable:l}=o,p=(i.cess(t,o),r(s)),g=p.pop();let d=t;e:for(const e of p)if(d=i.cess(d,e,o)||u.cess(d,e,isNaN(e)?{}:[],o),void 0===d)break e;return u.cess(d,g,n,o),t}{const[t,s]=e;return t}}const d={deleters:[i.Object,i.Map],returnTarget:!0};function j(e,t,s){const n=Object.assign({},d,s),c=new a(n.deleters),o=r(t),i=o.pop(),u=l(e,o.join("."),n)||e;c.cess(u,i,n)}const O={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},h=Object.keys(O),y=Object.values(O),m={object:Object,array:Array,map:Map},v=Object.keys(m),k=Object.values(m),w=Object.assign({},O,m),D=Object.keys(w),P=Object.values(w),x=[O.String,O.Number,O.Boolean,m.Object,m.Array];var M=Object.freeze({__proto__:null,ObjectKeys:v,ObjectValues:k,Objects:m,PrimitiveKeys:h,PrimitiveValues:y,Primitives:O,TypeKeys:D,TypeMethods:x,TypeValues:P,Types:w});const T={getters:[c.Object,c.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0,returnTarget:!0};function z(e,s,n){const r=[],c=Object.assign({},T,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:o,maxDepth:i,enumerable:u,nonenumerable:f,recurse:l}=c;if(c.depth>=i)return;o.includes(e)||o.push(e);const p=new a(c.getters).cess(e,Object.assign(c,{returnTarget:!0}));c.depth++;for(const[e,n]of Object.entries(Object.getOwnPropertyDescriptors(p)))if(u&&n.enumerable||f&&!n.enumerable){const i=n.value,a=t(i);l&&v.includes(a)&&!o.includes(i)?"entries"===s?r.push([e,z(i,s,c)]):"values"===s?r.push(z(i,s,c)):"keys"===s&&r.push(e,z(i,s,c)):"entries"===s?r.push([e,i]):"values"===s?r.push(i):"keys"===s&&r.push(e)}return r}const S=["string","function"];function E(e,s,n={}){const r=Object.assign({},n),c=t(s),o=t(e);if(!S.includes(c)||!v.includes(o))return e;let i=p(e);for(const[n,o]of z(e,"entries",Object.assign({},r,{recurse:!1}))){const e=v.includes(t(o))?E(o,s):o;c===S[0]?i[n]=g({},s,e,r):c===S[1]&&(i[n]=s(e))}return i}const L={ancestors:[],getters:[c.Object,c.Map],depth:0,maxDepth:10};function N(e,s,n={}){const r=Object.assign({},L,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,values:o}=r;if(r.depth>r.maxDepth)return;r.depth++;const i=new a(r.getters).cess(e,r);c.includes(i)||c.unshift(i);const u=t(s);let f=p(e);for(const[t,n]of z(e,"entries",Object.assign({},r,{recurse:!1})))"string"===u?f[t]=l(n,s):"function"===u&&(f[t]=s(n)),f[t]&&"object"==typeof f[t]&&(f[t]=N(f[t],s));return f}const A={depth:0,getters:[c.Object,c.Map],maxDepth:10,values:!1};function C(e,t){const s=[],n=Object.assign({},A,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:c}=n;if(n.depth++,n.depth>n.maxDepth)return s;const o=new a(n.getters).cess(e,n);r.includes(o)||r.unshift(o);const i=z(o,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of i)if(c?c&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,o)&&!r.includes(t)){const r=C(t,n);if(c){if(c)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const _={setters:[o.Object,o.Map]};function $(e,s){const n=Object.assign({},_,s),r="object"===t(e)?z(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)g(c,e,t,n);return c}const q={getters:[c.Object,c.Map],setters:[o.Object,o.Map]};function B(e,s,...n){if(!e)return e;const r=Object.assign({},q),c=(new a(r.getters),new a(r.setters)),o=t(e);for(const i of n)if(i)for(const[n,a]of Object.entries(i)){const i=e[n],u=t(i);t(a);"array"===o&&"assignConcat"===s?e.push(a):v.includes(u)?B(i,s,a):c.cess(e,n,a,r)}return e}var I=(e,...t)=>B(e,"assign",...t),K=(e,...t)=>B(e,"assignConcat",...t);const V={strict:!0};function R(e,s){const n=Object.assign({},V,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of z(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const F={typeCoercion:!1};function G(e,s,n,r){const c=Object.assign({},n);let o=c.value;const i=Object.assign({},F,r),a=t(c.value),u=e[s],f=t(u);if(v.includes(a))if(v.includes(f))c.value=J(u,o,i);else{const e=p(R(Object.defineProperties({},o))?"array":"object");c.value=J(e,o,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined"].includes(a)&&(c.value=O[c.type](o));return Object.defineProperty(e,s,c),n.sealed&&Object.seal(e[s]),n.frozen&&Object.freeze(e[s]),e}function J(e,t,s){for(const[n,r]of Object.entries(t))G(e,n,r,s);return e}const H={ancestors:[],depth:0,maxDepth:10};function Q(e,s={}){const n=Object.assign({},H,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const o=new a(n.getters).cess(e,n);r.includes(o)||r.unshift(o);const i=z(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of i)r.includes(s)||v.includes(t(s))&&Q(s,n);return Object.freeze(e)}const U={ancestors:[],depth:0,maxDepth:10};function W(e,s={}){const n=Object.assign({},U,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const o=new a(n.getters).cess(e,n);r.includes(o)||r.unshift(o);const i=z(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of i)r.includes(s)||v.includes(t(s))&&W(s,n);return Object.seal(e)}const X={strict:!0};function Y(e,s){const n=Object.assign({},X,s);let r;const c=t(e);if("map"===c)r=!0;else if("object"===c&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of z(e,"entries",{nonenumerable:!0,recurse:!1})){if(!R(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}const Z={strict:!0,isArrayLike:!1};function ee(e,s){const n=Object.assign({},Z,s);if("array"!==t(e)){if(!n.isArrayLike||!R(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var te=(e,t)=>z(e,"keys",t),se=(e,t)=>z(e,"values",t),ne=(e,t)=>z(e,"entries",t);const re={getters:[c.Object,c.Map],delimiter:".",depth:0,frozen:!1,nonenumerable:!0,path:!1,sealed:!1,type:!1};function ce(e,s,n={}){const r=Object.assign({},re,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++;const c=new a(r.getters).cess(e,s,r);if(c){const n=Object.getOwnPropertyDescriptor(e,s);if(!r.nonenumerable&&!n.enumerable)return;if(r.ancestors.includes(e)||r.ancestors.unshift(e),r.ancestors.includes(c))return;return r.path&&(r.path="string"===t(r.path)?[r.path,s].join(r.delimiter):s,n.path=r.path),r.type&&(n.type=t(c)),r.frozen&&(n.frozen=Object.isFrozen(c)),r.sealed&&(n.sealed=Object.isSealed(c)),v.includes(t(c))&&(n.value=oe(c,r)),n}}function oe(e,t){const s={};for(const[n,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=ce(e,n,t);r&&(s[n]=r)}return s}const ie={ancestors:[],depth:0,maxDepth:10,getters:[c.Object,c.Map]};function ae(e,s={}){const n=Object.assign({},ie,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,maxDepth:c}=n;if(n.depth>=c)return;n.depth++;const o=new a(n.getters).cess(e,n);if(void 0===o)return;r.includes(e)||r.unshift(e);const i=p(t(o)),u=z(e,"entries",{recurse:!1});e:for(const[e,s]of u){let c;if(v.includes(t(s))){if(r.includes(s))continue e;c=ae(s,n)}else c=s;try{i[e]=c}catch(e){console.error(e)}}return i}const ue={space:0,replacer:null};function fe(e,t){const s=Object.assign({},ue,t);return JSON.stringify(ae(e,s),s.replacer,s.space)}class le extends EventTarget{static compand=C;static decompand=$;static expand=E;static impand=N;static keys=te;static values=se;static entries=ne;static entities=z;static get=l;static set=g;static delete=j;static assign=I;static assignConcat=K;static defineProperties=J;static defineProperty=G;static freeze=Q;static seal=W;static getOwnPropertyDescriptors=oe;static getOwnPropertyDescriptor=ce;static isArrayLike=R;static isMapLike=Y;static isEntries=ee;static typeOf=t;static toString=fe;static valueOf=ae;constructor(e){super();for(const[t,s]of Object.entries({compand:le.compand,decompand:le.decompand,expand:le.expand,impand:le.impand,entities:le.entities,keys:le.keys,values:le.values,entries:le.entries,get:le.get,set:le.set,delete:le.delete,assign:le.assign,assignConcat:le.assignConcat,defineProperties:le.defineProperties,defineProperty:le.defineProperty,freeze:le.freeze,seal:le.seal,getOwnPropertyDescriptors:le.getOwnPropertyDescriptors,getOwnPropertyDescriptor:le.getOwnPropertyDescriptor,isArrayLike:le.isArrayLike,isEntries:le.isEntries,isMapLike:le.isMapLike,typeOf:le.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{le as Recourse,I as assign,K as assignConcat,C as compand,$ as decompand,J as defineProperties,G as defineProperty,j as delete,z as entities,ne as entries,E as expand,Q as freeze,l as get,ce as getOwnPropertyDescriptor,oe as getOwnPropertyDescriptors,N as impand,R as isArrayLike,ee as isEntries,te as keys,e as regularExpressions,W as seal,g as set,r as splitPath,u as tensors,fe as toString,t as typeOf,p as typedObjectLiteral,ae as valueOf,se as values,M as variables};
//# sourceMappingURL=recourse.min.js.map
