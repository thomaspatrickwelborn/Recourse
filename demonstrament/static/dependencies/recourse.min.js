function e(e){const t=/([a-zA-Z_][a-zA-Z0-9_]*)|(\d+)|\["([^"]*)"\]|"([^"]*)"|\./g,s=[];let n;for(;null!==(n=t.exec(e));)n[1]?s.push(n[1]):n[2]?s.push(parseInt(n[2],10)):n[3]?s.push(n[3]):n[4]&&s.push(n[4]);return s}var t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();const s={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},n=Object.keys(s),r=Object.values(s),c={object:Object,array:Array,map:Map},i=Object.keys(c),o=Object.values(c),a=Object.assign({},s,c),u=Object.keys(a),l=Object.values(a),f=[s.String,s.Number,s.Boolean,c.Object,c.Array];var p=Object.freeze({__proto__:null,ObjectKeys:i,ObjectValues:o,Objects:c,PrimitiveKeys:n,PrimitiveValues:r,Primitives:s,TypeKeys:u,TypeMethods:f,TypeValues:l,Types:a});const b={returnValue:"target"};const d={returnValue:"target"};const g={Object:function(...e){const s=e[0];if(["object","array"].includes(t(s))){if(["string","number"].includes(t(e[1]))){const[t,n,r]=e,{returnValue:c}=Object.assign({},b,r);return"entries"!==c?s[n]:[n,s[n]]}{const[t,n]=e,{returnValue:r}=Object.assign({},b,n);return"entries"!==r?s:Object.entries(s)}}},Map:function(...e){if("map"===t(e[0])){if(n.includes(t(e[1]))){const[t,s,n]=e,{returnValue:r}=Object.assign({},d,n);return"target"===r?t.get(s):"receiver"===r?t[s]:"entries"===r?[s,t.get(s)]:void 0}{const[t,s]=e,{returnValue:n}=Object.assign({},d,s);return"target"===n?Object.fromEntries(t):"receiver"===n?t:"entries"===n?Array.from(t.entries()):void 0}}}},j={Object:function(...e){if(["object","array"].includes(t(e[0]))){if(["string","number"].includes(t(e[1]))){const[t,s,n]=e;return t[s]=n,t[s]}{const[t,s]=e;for(const e of Object.keys(t))delete t[e];for(const[e,n]of Object.entries(s))t[e]=n;return t}}},Map:function(...e){if("map"===t(e[0])){if(n.includes(t(e[1]))){let[t,s,n,r]=e;const{returnValue:c}=Object.assign({},d,r);return t.set(s,n),t.get(s)}{let[t,s,n]=e;const{returnValue:r}=Object.assign({},d,n);t.clear();for(const[e,s]of Object.entries(source))t.set(e,s);return t}}}},O={Object:function(...e){const[s,n]=e;if(["object","array"].includes(t(s))){if(["string","number"].includes(t(n)))return delete s[n];for(const e of Object.keys(s))delete s[e]}else;},Map:function(...e){if(e.length,"map"===t(e[0])){if(n.includes(t(e[1]))){let[t,s,n]=e;const{returnValue:r}=Object.assign({},d,n);return t.delete(s)}{let[t]=e;return t.clear()}}}};class h extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}var y=Object.freeze({__proto__:null,Deleters:O,Getters:g,Setters:j,Tensors:h});const m={getters:[g.Object,g.Map]};function v(){const[t,s,n]=[...arguments];if(void 0===s)return arguments[0];const r=Object.assign({},m,n),c=new h(r.getters),i=e(s);let o=t;e:for(const e of i)try{if(o=c.cess(o,e,r),void 0===o)break e}catch(e){break e}return o}function w(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();s="object"===t?new Object:"array"===t?new Array:"map"===t?new Map:{}}else s="object"===n?new Object:"array"===n?new Array:"map"===value?new Map:{};return s}const k={getters:[g.Object,g.Map],setters:[j.Object,j.Map]};function D(){const s=[...arguments];if("string"===t(s[1])){const[t,n,r,c]=s,i=Object.assign({},k,c),o=new h(i.getters),a=new h(i.setters),{enumerable:u,nonenumerable:l}=i,f=(o.cess(t,i),e(n)),p=f.pop();let b=t;e:for(const e of f)if(b=o.cess(b,e,i)||a.cess(b,e,isNaN(e)?{}:[],i),void 0===b)break e;return a.cess(b,p,r,i),t}{const[e,t]=s;return e}}const M={deleters:[O.Object,O.Map],returnValue:"target"};function P(t,s,n){const r=Object.assign({},M,n),c=new h(r.deleters),i=e(s),o=i.pop(),a=v(t,i.join("."),r)||t;c.cess(a,o,r)}const x={getters:[g.Object,g.Map],delimiter:".",depth:0,frozen:!1,nonenumerable:!0,path:!1,sealed:!1,type:!1};function V(e,s,n={}){const r=Object.assign({},x,n,{ancestors:Object.assign([],n.ancestors)});if(r.depth>=r.maxDepth)return;r.depth++;const c=new h(r.getters).cess(e,s,r);if(void 0!==c){const n=t(e),o="map"!==n?Object.getOwnPropertyDescriptor(e,s):{configurable:!0,enumerable:!0,value:c[1],writable:!0};if(!r.nonenumerable&&!o.enumerable)return;if(r.ancestors.includes(e)||r.ancestors.unshift(e),r.ancestors.includes(c))return;return r.path&&(r.path="string"===t(r.path)?[r.path,s].join(r.delimiter):s,o.path=r.path),r.type&&(o.type=t(c)),r.frozen&&(o.frozen=Object.isFrozen(c)),r.sealed&&(o.sealed=Object.isSealed(c)),i.includes(t(c))&&"map"!==n?o.value=z(c,r):i.includes(t(c[1]))&&"map"===n&&(o.value=z(c[1],r)),o}}function z(e,s){const n=Object.assign({},s),r={},c=["array","object"].includes(t(e))?Object.keys(Object.getOwnPropertyDescriptors(e)):Array.from(e.keys());for(const t of c){const s=V(e,t,n);s&&(r[t]=s)}return r}const A={getters:[g.Object,g.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0,returnValue:"target"};function L(e,s,n={}){const r=[],c=Object.assign({},A,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:o,maxDepth:a,enumerable:u,nonenumerable:l,recurse:f}=c;if(!(c.depth>=a)){o.includes(e)||o.unshift(e),console.log(z(e,{nonenumerable:!0,returnValue:"entries"})),c.depth++;for(const[n,a]of z(e,{nonenumerable:!0,returnValue:"entries"}))if(u&&a.enumerable||l&&!a.enumerable){const e=a.value,u=t(e);f&&i.includes(u)&&!o.includes(e)?"entries"===s?r.push([n,L(e,s,c)]):"values"===s?r.push(L(e,s,c)):"keys"===s&&r.push(n,L(e,s,c)):"entries"===s?r.push([n,e]):"values"===s?r.push(e):"keys"===s&&r.push(n)}return r}}const N=["string","function"];function _(e,s,n={}){const r=Object.assign({},n),c=t(s),o=t(e);if(!N.includes(c)||!i.includes(o))return e;let a=w(e);for(const[n,o]of L(e,"entries",Object.assign({},r,{recurse:!1}))){console.log(n,o);const e=i.includes(t(o))?_(o,s,r):o;c===N[0]?a[n]=D({},s,e,r):c===N[1]&&(a[n]=s(e))}return a}const C={ancestors:[],getters:[g.Object,g.Map],depth:0,maxDepth:10};function S(e,s,n={}){const r=Object.assign({},C,n,{ancestors:Object.assign([],n.ancestors)}),{ancestors:c,values:i}=r;if(r.depth>r.maxDepth)return;r.depth++;const o=new h(r.getters).cess(e,r);c.includes(o)||c.unshift(o);const a=t(s);let u=w(e);for(const[t,n]of L(e,"entries",Object.assign({},r,{recurse:!1})))"string"===a?u[t]=v(n,s):"function"===a&&(u[t]=s(n)),u[t]&&"object"==typeof u[t]&&(u[t]=S(u[t],s));return u}const T={depth:0,getters:[g.Object,g.Map],maxDepth:10,values:!1};function E(e,t){const s=[],n=Object.assign({},T,t,{ancestors:Object.assign([],t.ancestors)}),{ancestors:r,values:c}=n;if(n.depth++,n.depth>n.maxDepth)return s;const i=new h(n.getters).cess(e,n);r.includes(e)||r.unshift(e);const o=L(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,t]of o)if(c?c&&s.push([e,t]):s.push(e),"object"==typeof t&&null!==t&&!Object.is(t,i)&&!r.includes(t)){const r=E(t,n);if(c){if(c)for(const[t,n]of r){const r=[e,t].join(".");s.push([r,n])}}else for(const t of r){const n=[e,t].join(".");s.push(n)}}return s}const I={setters:[j.Object,j.Map]};function B(e,s){const n=Object.assign({},I,s),r="object"===t(e)?L(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)D(c,e,t,n);return c}const K={getters:[g.Object,g.Map],setters:[j.Object,j.Map]};function Z(e,s,...n){if(!e)return e;const r=Object.assign({},K),c=(new h(r.getters),new h(r.setters)),o=t(e);e:for(const a of n){if(!i.includes(t(a)))continue e;const n=L(a,"entries",{recurse:!1});for(const[a,u]of n){const n=e[a],l=t(n);t(u);"array"===o&&"assignConcat"===s?e.push(u):i.includes(l)?Z(n,s,u):c.cess(e,a,u,r)}}return e}var F=(e,...t)=>Z(e,"assign",...t),G=(e,...t)=>Z(e,"assignConcat",...t);const J={strict:!0};function q(e,s){const n=Object.assign({},J,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of L(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const H={typeCoercion:!1};function Q(e,n,r,c){const o=Object.assign({},r);let a=o.value;const u=Object.assign({},H,c),l=t(o.value),f=e[n],p=t(f);if(i.includes(l))if(i.includes(p))o.value=R(f,a,u);else{const e=w(q(Object.defineProperties({},a))?"array":"object");o.value=R(e,a,u)}else u.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(o,"type")&&!["undefined"].includes(l)&&(o.value=s[o.type](a));return Object.defineProperty(e,n,o),r.sealed&&Object.seal(e[n]),r.frozen&&Object.freeze(e[n]),e}function R(e,t,s){for(const[n,r]of Object.entries(t))Q(e,n,r,s);return e}const U={ancestors:[],depth:0,maxDepth:10};function W(e,s={}){const n=Object.assign({},U,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const o=new h(n.getters).cess(e,n);r.includes(o)||r.unshift(o);const a=L(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of a)r.includes(s)||i.includes(t(s))&&W(s,n);return Object.freeze(e)}const X={ancestors:[],depth:0,maxDepth:10};function Y(e,s={}){const n=Object.assign({},X,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,values:c}=n;if(n.depth>n.maxDepth)return;n.depth++;const o=new h(n.getters).cess(e,n);r.includes(o)||r.unshift(o);const a=L(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of a)r.includes(s)||i.includes(t(s))&&Y(s,n);return Object.seal(e)}const $={strict:!0};function ee(e,s){const n=Object.assign({},$,s);let r;const c=t(e);if("map"===c)r=!0;else if("object"===c&&e.size>=0&&Number.isInteger(e.size))if(!1===n.strict)r=!0;else{e:for(const t of L(e,"entries",{nonenumerable:!0,recurse:!1})){if(!q(t,n)&&2!==t.length){r=!1;break e}r=!0}void 0===r&&(r=!1)}else r=!1;return r}const te={strict:!0,isArrayLike:!1};function se(e,s){const n=Object.assign({},te,s);if("array"!==t(e)){if(!n.isArrayLike||!q(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var ne=(e,t)=>L(e,"keys",t),re=(e,t)=>L(e,"values",t),ce=(e,t)=>L(e,"entries",t);const ie={ancestors:[],depth:0,maxDepth:10,getters:[g.Object,g.Map],returnValue:"receiver"};function oe(e,s={}){const n=Object.assign({},ie,s,{ancestors:Object.assign([],s.ancestors)}),{ancestors:r,maxDepth:c,returnValue:o}=n;if("receiver"===o)return e;if(n.depth>=c)return;n.depth++;const a=new h(n.getters).cess(e,n);if(void 0===a)return;r.includes(e)||r.unshift(e);const u=w(t(a)),l=L(e,"entries",Object.assign({},n,{recurse:!1}));e:for(const[e,s]of l){let c;if(i.includes(t(s))){if(r.includes(s))continue e;c=oe(s,n)}else c=s;try{u[e]=c}catch(e){console.error(e)}}return u}const ae={space:0,replacer:null,returnValue:"receiver"};function ue(e,t){const s=Object.assign({},ae,t);return JSON.stringify(oe(e,s),s.replacer,s.space)}class le extends EventTarget{static compand=E;static decompand=B;static expand=_;static impand=S;static keys=ne;static values=re;static entries=ce;static entities=L;static get=v;static set=D;static delete=P;static assign=F;static assignConcat=G;static defineProperties=R;static defineProperty=Q;static freeze=W;static seal=Y;static getOwnPropertyDescriptors=z;static getOwnPropertyDescriptor=V;static isArrayLike=q;static isMapLike=ee;static isEntries=se;static typeOf=t;static toString=ue;static valueOf=oe;constructor(e){super();for(const[t,s]of Object.entries({compand:le.compand,decompand:le.decompand,expand:le.expand,impand:le.impand,entities:le.entities,keys:le.keys,values:le.values,entries:le.entries,get:le.get,set:le.set,delete:le.delete,assign:le.assign,assignConcat:le.assignConcat,defineProperties:le.defineProperties,defineProperty:le.defineProperty,freeze:le.freeze,seal:le.seal,getOwnPropertyDescriptors:le.getOwnPropertyDescriptors,getOwnPropertyDescriptor:le.getOwnPropertyDescriptor,isArrayLike:le.isArrayLike,isEntries:le.isEntries,isMapLike:le.isMapLike,typeOf:le.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{le as Recourse,F as assign,G as assignConcat,E as compand,B as decompand,R as defineProperties,Q as defineProperty,P as delete,L as entities,ce as entries,_ as expand,W as freeze,v as get,V as getOwnPropertyDescriptor,z as getOwnPropertyDescriptors,S as impand,q as isArrayLike,se as isEntries,ne as keys,Y as seal,D as set,e as splitPath,y as tensors,ue as toString,t as typeOf,w as typedObjectLiteral,oe as valueOf,re as values,p as variables};
//# sourceMappingURL=recourse.min.js.map
