const e={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},t=Object.keys(e),n=Object.values(e),o={object:Object,array:Array},s=Object.keys(o),r=Object.values(o),c=Object.assign({},e,o),i=Object.keys(c),a=Object.values(c),u=[e.String,e.Number,e.Boolean,o.Object,o.Array];var l=Object.freeze({__proto__:null,ObjectKeys:s,ObjectValues:r,Objects:o,PrimitiveKeys:t,PrimitiveValues:n,Primitives:e,TypeKeys:i,TypeMethods:u,TypeValues:a,Types:c}),f=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function b(e){let t;const n=f(e);if("string"===n){const n=e.toLowerCase();"object"===n?t={}:"array"===n&&(t=[])}else"object"===n?t={}:"array"===n&&(t=[]);return t}var p={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};function j(e,t){const n=e.split(new RegExp(p.quotationEscape)),o=n.pop();let s=t;for(const e of n)s=s[e];return s[o]}function O(e,t){const n=e.split(new RegExp(p.quotationEscape)),o=n.pop(),s=o&&!isNaN(o)?[]:{};let r=s,c=0;for(;c<n.length-2;){const e=keypaths[c];isNaN(e),r[e]={},r=r[e],c++}return r[o]=t,s}const d=["string","function"];function y(e,t){const n=f(t),o=f(e);if(!d.includes(n)||!s.includes(o))return e;let r=b(e);for(const[o,c]of Object.entries(e)){const e=s.includes(f(c))?y(c,t):c;n===d[0]?r[o]=O(t,e):n===d[1]&&(r[o]=t(e))}return r}function v(e,t){const n=f(t),o=f(e);if(!["string","function"].includes(n)||!["array","object"].includes(o))return e;let s=b(e);for(const[o,r]of Object.entries(e))"string"===n?s[o]=j(t,r):"function"===n&&(s[o]=t(r)),s[o]&&"object"==typeof s[o]&&(s[o]=v(s[o],t));return s}var g=e=>{let t;const n=f(e);if("array"===n)t=!0;else if("object"===n&&Number.isInteger(e.length)&&e.length>=0){e:for(const n of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==n&&(t=!isNaN(n),!t))break e}else t=!1;return t};const h={depth:0,maxDepth:10,accessors:[{default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)}.default],ancestors:[]};function m(e,t){const n=[],o=Object.assign({},h,t,{ancestors:[].concat(t.ancestors)});if(o.depth++,o.depth>o.maxDepth)return n;for(const t of o.accessors){const s=t.bind(e)(e);if(s){o.ancestors.includes(s)||o.ancestors.unshift(s);for(const[e,t]of Object.entries(s))if(o.values?o.values&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,s)&&!o.ancestors.includes(t)){const s=m(t,o);if(o.values){if(o.values)for(const[t,o]of s){const s=[e,t].join(".");n.push([s,o])}}else for(const t of s){const o=[e,t].join(".");n.push(o)}}}}return n}function w(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,o]of Object.entries(n)){const n=f(e[t]),s=f(o);e[t]="object"===n&&"object"===s?w(e[t],o):o}return e}function z(e,...t){if(!e)return e;for(const n of t)if(n)for(const[t,o]of Object.entries(n)){const n=f(e[t]),s=f(o);e[t]="object"===n&&"object"===s?z(e[t],o):"array"===n&&"array"===s?e[t].concat(o):o}return e}var N={depth:0,path:null,ancestors:[]},P={delimiter:".",frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,retrocursion:!1,sealed:!1,type:!1};function D(e,t,n){const o=Object.assign({},N,P,n,{ancestors:Object.assign([],n.ancestors)}),s=Object.getOwnPropertyDescriptor(e,t);if((o.nonenumerable||s.enumerable)&&(o.ancestors.includes(e)||o.ancestors.unshift(e),o.retrocursion||!o.ancestors.includes(s.value)))return o.path&&(o.path="string"===f(o.path)?[o.path,t].join(o.delimiter):t,s.path=o.path),o.type&&(s.type=f(s.value)),o.frozen&&(s.frozen=Object.isFrozen(s.value)),o.sealed&&(s.sealed=Object.isSealed(s.value)),["array","object"].includes(f(s.value))&&(s.value=x(s.value,o)),s}function x(e,t){const n={},o=Object.assign({},N,P,t);if(o.depth>=o.maxDepth)return n;o.depth++;for(const[t,s]of Object.entries(Object.getOwnPropertyDescriptors(e))){const s=D(e,t,o);void 0!==s&&(n[t]=s)}return n}var k={configurable:!1,enumerable:!1,frozen:!1,sealed:!1,typeCoercion:!1,writable:!1};function E(t,n,o,s){const r=Object.assign({},o),c=Object.assign({},k,s),i=f(r.value);if(["array","object"].includes(i)){const e=g(Object.defineProperties(b(i),r.value))?[]:{};r.value=C(e,r.value,c)}else c.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(r,"type")&&!["undefined","null"].includes(i)&&(r.value=e[r.type](r.value));return Object.defineProperty(t,n,r),o.sealed&&Object.seal(t[n]),o.frozen&&Object.freeze(t[n]),t}function C(e,t,n){const o=Object.assign({},k,n);for(const[n,s]of Object.entries(t))E(e,n,s,o);return e}function S(e){for(const[t,n]of Object.entries(e))Object.is(n,e)||n&&"object"==typeof n&&S(n);return Object.freeze(e)}export{y as expandTree,v as impandTree,g as isArrayLike,m as propertyDirectory,w as recursiveAssign,z as recursiveAssignConcat,C as recursiveDefineProperties,E as recursiveDefineProperty,S as recursiveFreeze,D as recursiveGetOwnPropertyDescriptor,x as recursiveGetOwnPropertyDescriptors,p as regularExpressions,f as typeOf,b as typedObjectLiteral,l as variables};
//# sourceMappingURL=recourse.min.js.map
