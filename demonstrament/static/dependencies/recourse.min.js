var e={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/,quotationStartStop:/^"(.*)"$/},t=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();class s extends EventTarget{constructor(e){super();const t=Object.assign([],e);Object.defineProperties(this,{cess:{value:function(){let e;e:for(const s of t)if(e=s(...arguments),void 0!==e)break e;return e}}})}}const n={Object:function(){const e=arguments[0];if(["object","array"].includes(t(e))){if("string"===t(arguments[1])){return e[arguments[1]]}return e}},Map:function(){const e=arguments[0];if("map"===t(e)){if("string"===t(arguments[1])){const t=arguments[1];return e.get(t)}return Object.fromEntries(e)}}},r={Object:function(){const e=[...arguments];if(["object","array"].includes(t(e[0]))){if("string"===t(e[1])){const[t,s,n,r]=e;return t[s]=n,t[s]}{const[t,s,n]=e;for(const e of Object.keys(t))delete t[e];for(const[e,s]of Object.entries(source))t[e]=s;return t}}},Map:function(){const e=[...arguments];if("map"===t(e[0])){if("string"===t(e[1])){const[t,s,n,r]=e;return t.set(s,n),t.get(s)}{const[t,s,n]=e;t.clear();for(const[e,s]of Object.entries(source))t.set(e,s);return t}}}},c={Object:function(e,s,n){const r=[...arguments];if(["object","array"].includes(t(r[0]))){if("string"===t(r[1]))return delete e[s];for(const t of Object.keys(e))delete e[t]}else;},Map:function(){const e=[...arguments];if("map"===t(e[0])){if("string"===t(e[1])){const[t,s,n]=e;return t.delete(s)}{const[t,s]=e;return t.clear()}}}};var o=Object.freeze({__proto__:null,Cessors:s,Deleters:c,Getters:n,Setters:r});const i={getters:[n.Object,n.Map]};function a(){const[t,n,r]=[...arguments],c=Object.assign({},i,r);if(void 0===n)return arguments[0];const o=new s(c.getters),a=n.split(new RegExp(e.quotationEscape));let u=t;e:for(const e of a)try{if(u=o.cess(u,e),void 0===u)break e}catch(e){break e}return u}function u(e){let s;const n=t(e);if("string"===n){const t=e.toLowerCase();"object"===t?s={}:"array"===t&&(s=[])}else"object"===n?s={}:"array"===n&&(s=[]);return s}const f={enumerable:!0,nonenumerable:!1,getters:[n.Object,n.Map],setters:[r.Object]};function l(){const n=[...arguments];if("string"===t(n[1])){const[t,r,c,o]=n,i=Object.assign({},f,o),a=new s(i.getters),u=new s(i.setters),{enumerable:l,nonenumerable:p}=i,b=(a.cess(t),r.split(new RegExp(e.quotationEscape))),g=b.pop();let O=t;e:for(const e of b)if(O=a.cess(O,e,i)||u.cess(O,e,isNaN(e)?{}:[],i),void 0===O)break e;return u.cess(O,g,c),t}{const[e,t]=n;return e}}function p(t,s){const n=s.split(new RegExp(e.quotationEscape)),r=n.pop();let c=t;for(const e of n)c=c[e];delete c[r]}const b={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},g=Object.keys(b),O=Object.values(b),j={object:Object,array:Array,map:Map},d=Object.keys(j),y=Object.values(j),h=Object.assign({},b,j),m=Object.keys(h),v=Object.values(h),w=[b.String,b.Number,b.Boolean,j.Object,j.Array];var k=Object.freeze({__proto__:null,ObjectKeys:d,ObjectValues:y,Objects:j,PrimitiveKeys:g,PrimitiveValues:O,Primitives:b,TypeKeys:m,TypeMethods:w,TypeValues:v,Types:h});const P={getters:[n.Object,n.Map],ancestors:[],depth:0,maxDepth:10,enumerable:!0,nonenumerable:!1,recurse:!0};function x(e,n,r){const c=[],o=Object.assign({},P,r,{ancestors:[].concat(r.ancestors||[])}),{ancestors:i,maxDepth:a,enumerable:u,nonenumerable:f,recurse:l}=o;if(o.depth>=a)return;i.includes(e)||i.push(e);const p=new s(o.getters).cess(e);o.depth++;for(const[e,s]of Object.entries(Object.getOwnPropertyDescriptors(p)))if(u&&s.enumerable||f&&!s.enumerable){const r=s.value,a=t(r);l&&d.includes(a)&&!i.includes(r)?"entries"===n?c.push([e,x(r,n,o)]):"values"===n?c.push(x(r,n,o)):"keys"===n&&c.push(e,x(r,n,o)):"entries"===n?c.push([e,r]):"values"===n?c.push(r):"keys"===n&&c.push(e)}return c}const D={ancestors:[],nonenumerable:!1},E=["string","function"];function M(e,s,n={}){const r=Object.assign({},D,n,{ancestors:[].concat(n.ancestors||[])}),{ancestors:c}=r,o=t(s),i=t(e);if(!E.includes(o)||!d.includes(i))return e;c.includes(e)||c.unshift(e);let a=u(e);for(const[n,i]of x(e,"entries",Object.assign({},r,{recurse:!1}))){const u=d.includes(t(i))?M(i,s):i;o!==E[0]||null===i||Object.is(i,e)||c.includes(i)?o===E[1]&&(a[n]=s(u)):a[n]=l({},s,u,r)}return a}var S=(e,t)=>x(e,"entries",t);const z={};function C(e,s,n){const r=Object.assign({},z,n),c=t(s);let o=u(e);for(const[t,n]of S(e,Object.assign({},r,{recurse:!1})))"string"===c?o[t]=a(n,s):"function"===c&&(o[t]=s(n)),o[t]&&"object"==typeof o[t]&&(o[t]=C(o[t],s));return o}const q={ancestors:[],depth:0,enumerable:!0,getters:[n.Object,n.Map],maxDepth:10,nonenumerable:!1,values:!1};function N(e,t){const n=[],r=Object.assign({},q,t,{ancestors:[].concat(t.ancestors||[])}),{ancestors:c,nonenumerable:o,values:i}=r;if(r.depth++,r.depth>r.maxDepth)return n;const a=new s(r.getters).cess(e);c.includes(a)||c.unshift(a);const u=x(a,"entries",{nonenumerable:o,recurse:!1});for(const[e,t]of u)if(i?i&&n.push([e,t]):n.push(e),"object"==typeof t&&null!==t&&!Object.is(t,a)&&!c.includes(t)){const s=N(t,r);if(i){if(i)for(const[t,r]of s){const s=[e,t].join(".");n.push([s,r])}}else for(const t of s){const s=[e,t].join(".");n.push(s)}}return n}const A={setters:[r.Object]};function _(e,s){const n=Object.assign({},A,s),r="object"===t(e)?x(e,"entries",n):e;if(!r)return;const c=isNaN(r[0][0])?{}:[];for(const[e,t]of r)l(c,e,t,n);return c}function L(e,s,...n){if(!e)return e;const r=t(e);for(const c of n)if(c)for(const[n,o]of Object.entries(c)){const c=e[n],i=t(c);t(o);"array"===r&&"assignConcat"===s?e.push(o):d.includes(i)?L(c,s,o):Object.assign(e,{[n]:o})}return e}var T=(e,...t)=>L(e,"assign",...t),R=(e,...t)=>L(e,"assignConcat",...t);const B={strict:!0};function K(e,s){const n=Object.assign({},B,s);let r;const c=t(e);if("array"===c)r=!0;else if("object"===c&&e.length>=0&&Number.isInteger(e.length))if(!1===n.strict)r=!0;else{e:for(const t of x(e,"keys",{nonenumerable:!0,recurse:!1}).reverse()){if(Number(t)===e.length-1){r=!0;break e}}void 0===r&&(r=!1)}else r=!1;return r}const V={typeCoercion:!1};function $(e,s,n,r){const c=Object.assign({},n);let o=c.value;const i=Object.assign({},V,r),a=t(c.value),f=e[s],l=t(f);if(d.includes(a))if(d.includes(l))c.value=I(f,o,i);else{const e=u(K(Object.defineProperties({},o))?"array":"object");c.value=I(e,o,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined","null"].includes(a)&&(c.value=b[c.type](o));return Object.defineProperty(e,s,c),n.sealed&&Object.seal(e[s]),n.frozen&&Object.freeze(e[s]),e}function I(e,t,s){for(const[n,r]of Object.entries(t))$(e,n,r,s);return e}const F={ancestors:[],getters:[n.Object,n.Map]};function G(e,s={}){const n=Object.assign({},F,s,{ancestors:Object.assign([],s.ancestors)}),r=x(e,"entries",Object.assign(n,{recurse:!1}));for(const[e,s]of r)d.includes(t(s))&&G(s,n);return Object.freeze(e)}const J={};function H(e,t){const s=Object.assign({},J,t,{});throw x(e,"entries",s)}const Q={strict:!0,isArrayLike:!1};function U(e,s){const n=Object.assign({},Q,s);if("array"!==t(e)){if(!n.isArrayLike||!K(e,{strict:n.strict}))return!1;e=Array.from(e)}if(n.strict||e.length){let s;e:for(const n of e)if(s="array"===t(n)&&2===n.length&&["string","number","symbol"].includes(t(n[0])),!1===s)break e;return s}return!0}var W=(e,t)=>x(e,"keys",t),X=(e,t)=>x(e,"values",t);const Y={getters:[n.Object,n.Map],ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function Z(e,n,r={}){const c=Object.assign({},Y,r,{ancestors:Object.assign([],r.ancestors)});if(c.depth>=c.maxDepth)return;c.depth++;const o=new s(c.getters).cess(e,n);if(o){const s=Object.getOwnPropertyDescriptor(e,n);if(!c.nonenumerable&&!s.enumerable)return;if(c.ancestors.includes(e)||c.ancestors.unshift(e),c.ancestors.includes(o))return;return c.path&&(c.path="string"===t(c.path)?[c.path,n].join(c.delimiter):n,s.path=c.path),c.type&&(s.type=t(o)),c.frozen&&(s.frozen=Object.isFrozen(o)),c.sealed&&(s.sealed=Object.isSealed(o)),d.includes(t(o))&&(s.value=ee(o,c)),s}}function ee(e,t){const s={};for(const[n,r]of Object.entries(Object.getOwnPropertyDescriptors(e))){const r=Z(e,n,t);r&&(s[n]=r)}return s}const{quotationEscape:te,quotationStartStop:se}=e;function ne(t){const s=t.split(new RegExp(e.quotationEscape));let n=0;for(;n<s.length;)s[n]=s[n].replace(new RegExp(e.quotationStartStop),"$1"),n++;return s}const re={ancestors:[],getters:[n.Object,n.Map]};function ce(e,n={}){const r=Object.assign({},re,n,{ancestors:Object.assign([],n.ancestors)}),c=new s(r.getters).cess(e,r);if(void 0===c)throw[e,c];r.ancestors.includes(e)||r.ancestors.unshift(e);const o=u(t(c)),i=x(e,"entries",Object.assign(r,{recurse:!1}));for(const[e,s]of i){let n;if(n=d.includes(t(s))?ce(s,r):s,!r.ancestors.includes(n))try{o[e]=n}catch(e){console.error(e)}}return o}const oe={getters:[n.Object,n.Map],space:0,replacer:null};function ie(e,t){const s=Object.assign({},oe,t);return JSON.stringify(ce(e,s),s.replacer,s.space)}class ae extends EventTarget{static compand=N;static decompand=_;static expand=M;static impand=C;static keys=W;static values=X;static entries=S;static entities=x;static get=a;static set=l;static delete=p;static assign=T;static assignConcat=R;static defineProperties=I;static defineProperty=$;static freeze=G;static seal=H;static getOwnPropertyDescriptors=ee;static getOwnPropertyDescriptor=Z;static isArrayLike=K;static isEntries=U;static typeOf=t;static toString=ie;static valueOf=ce;constructor(e){super();for(const[t,s]of Object.entries({compand:ae.compand,decompand:ae.decompand,expand:ae.expand,impand:ae.impand,entities:ae.entities,keys:ae.keys,values:ae.values,entries:ae.entries,get:ae.get,set:ae.set,delete:ae.delete,assign:ae.assign,assignConcat:ae.assignConcat,defineProperties:ae.defineProperties,defineProperty:ae.defineProperty,freeze:ae.freeze,seal:ae.seal,getOwnPropertyDescriptors:ae.getOwnPropertyDescriptors,getOwnPropertyDescriptor:ae.getOwnPropertyDescriptor,isArrayLike:ae.isArrayLike,isEntries:ae.isEntries,typeOf:ae.typeOf}))Object.defineProperty(this,t,{value:s.bind(this,e)})}}export{ae as Recourse,T as assign,R as assignConcat,o as cessors,N as compand,_ as decompand,I as defineProperties,$ as defineProperty,p as delete,x as entities,S as entries,M as expand,G as freeze,a as get,Z as getOwnPropertyDescriptor,ee as getOwnPropertyDescriptors,C as impand,K as isArrayLike,U as isEntries,W as keys,e as regularExpressions,H as seal,l as set,ne as splitPath,ie as toString,t as typeOf,u as typedObjectLiteral,ce as valueOf,X as values,k as variables};
//# sourceMappingURL=recourse.min.js.map
